<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Re0:提瓦特幸存者 | ChaosのBlog</title><meta name="author" content="Chaos"><meta name="copyright" content="Chaos"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Re0:从零开始的C++游戏开发前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。第一集 追鼠标の小球12345678910111213141516171819202122232425262728293031323334353637#include &lt;graphics.h&gt;#include &lt;io">
<meta property="og:type" content="article">
<meta property="og:title" content="Re0:提瓦特幸存者">
<meta property="og:url" content="https://www.chaos-ljc.top/2024/10/22/Rouguelike-%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/index.html">
<meta property="og:site_name" content="ChaosのBlog">
<meta property="og:description" content="Re0:从零开始的C++游戏开发前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。第一集 追鼠标の小球12345678910111213141516171819202122232425262728293031323334353637#include &lt;graphics.h&gt;#include &lt;io">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.chaos-ljc.top/assets/images/cover_18.png">
<meta property="article:published_time" content="2024-10-22T09:39:37.819Z">
<meta property="article:modified_time" content="2024-10-22T12:11:24.874Z">
<meta property="article:author" content="Chaos">
<meta property="article:tag" content="c++游戏开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.chaos-ljc.top/assets/images/cover_18.png"><link rel="shortcut icon" href="/assets/images/avatar.png"><link rel="canonical" href="https://www.chaos-ljc.top/2024/10/22/Rouguelike-%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Re0:提瓦特幸存者',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-22 20:11:24'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/assets/images/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-simple"></i><span> Charts</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/assets/images/cover_18.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ChaosのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">Re0:提瓦特幸存者</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-chart-simple"></i><span> Charts</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Re0:提瓦特幸存者</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-22T09:39:37.819Z" title="发表于 2024-10-22 17:39:37">2024-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-22T12:11:24.874Z" title="更新于 2024-10-22 20:11:24">2024-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Re0-从零开始的C-游戏开发"><a href="#Re0-从零开始的C-游戏开发" class="headerlink" title="Re0:从零开始的C++游戏开发"></a>Re0:从零开始的C++游戏开发</h1><h5 id="前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。"><a href="#前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。" class="headerlink" title="前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。"></a>前言：本笔记是Chaos观看B站up<a target="_blank" rel="noopener" href="https://space.bilibili.com/25864506">Voidmatrix</a>的课程<a target="_blank" rel="noopener" href="https://space.bilibili.com/25864506/channel/collectiondetail?sid=1825182">从零开始的提瓦特幸存者</a>的个人笔记；所用为适合新手入门的easyx图形库。</h5><h2 id="第一集-追鼠标の小球"><a href="#第一集-追鼠标の小球" class="headerlink" title="第一集 追鼠标の小球"></a>第一集 追鼠标の小球</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1280</span>, <span class="number">720</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> x = <span class="number">640</span>;</span><br><span class="line">	<span class="type">int</span> y = <span class="number">360</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 双缓冲绘图</span></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line">	<span class="comment">// 主循环</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ExMessage msg;</span><br><span class="line">		<span class="comment">// 读取操作</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 在这里进行消息处理逻辑</span></span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_MOUSEMOVE)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 数据处理（由于数据处理逻辑简单，所以嵌套在读取操作中）</span></span><br><span class="line">				x = msg.x;</span><br><span class="line">				y = msg.y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 绘制画面</span></span><br><span class="line">		<span class="built_in">cleardevice</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">solidcircle</span>(x, y, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘图坐标系"><a href="#绘图坐标系" class="headerlink" title="绘图坐标系"></a>绘图坐标系</h3><p>easyx中，绘图坐标系相似于二维数组坐标系，即y轴的反转</p>
<h3 id="渲染缓冲区"><a href="#渲染缓冲区" class="headerlink" title="渲染缓冲区"></a>渲染缓冲区</h3><p>渲染缓冲区：类似画笔在画布上画画，先绘制的内容就可能被后绘制的内容覆盖掉</p>
<p><code> cleardevice()</code>就是使当前填充颜色将画布覆盖，默认填充色为黑色</p>
<p>当我们调用<code>solidcircle()</code>这类绘图函数时，一个无边框的填充圆被“逐渐地”绘制到这张画布上<br>当我们不断清屏，不断画圆，逐渐地过程在“宏观上”体现出来了</p>
<p>而当我们调用<code>BeginBatchDraw();</code>easyx为我们新建一个渲染缓冲区，不同于窗口的渲染缓冲区，它默认是不可见的，随后执行的所有绘制都将在新的画布上进行<br>而当我们调用<code>FlushBatchDraw();</code>或<code>EndBatchDraw();</code>时，easyx会将窗口所显示的缓冲区和新建的缓冲区进行“迅速”交换，这样的交换迅速到我们不会因绘图过程频繁而导致闪烁</p>
<h3 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h3><h4 id="主循环"><a href="#主循环" class="headerlink" title="*主循环"></a>*主循环</h4><p>在上述程序中，我们通过一个<code>while(true)</code>死循环阻塞程序退出，同时不断执行清屏和绘制的操作，这其实就是游戏框架最核心的部分——主循环</p>
<p>在主循环中，我们不断读取玩家的(鼠标、键盘等)操作，将这些操作翻译成我们的数理逻辑，最后再根据现有的数据将画面内容绘制出来<br>简而言之，就是<strong>读取操作、处理数据、绘制画面</strong>这三大要素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	读取操作();</span><br><span class="line">	处理数据();</span><br><span class="line">	绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure>

<p>如上述代码，我们游戏的渲染部分只依赖于当前的数据，依旧是变量x和y的值，而与如何处理得到这些数据的处理逻辑并未有直接关系。这就是软件工程理论中的”解耦耦合“，或者说这就是”数据驱动”，或者说“渲染与逻辑分离”中最朴素的思想。</p>
<p>当然，在主循环开始之前，我们需要把主循环过程中所需要的数据初始化，如：将圆的位置坐标初始化、初始化窗口等。</p>
<p>而在主循环结束后，需要对游戏程序使用的资源进行释放。</p>
<h2 id="第二集-进击の井字棋"><a href="#第二集-进击の井字棋" class="headerlink" title="第二集 进击の井字棋"></a>第二集 进击の井字棋</h2><h3 id="三大元素"><a href="#三大元素" class="headerlink" title="三大元素"></a>三大元素</h3><p>在代码编写之前，</p>
<p>我们首先根据前面所讲述的游戏框架，思考在井字棋的<strong>主循环中三大要素</strong>如何设计实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	读取操作();</span><br><span class="line">	处理数据();</span><br><span class="line">	绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure>

<ol>
<li><h5 id="读取操作："><a href="#读取操作：" class="headerlink" title="读取操作："></a>读取操作：</h5><p>在本程序中，我们只对鼠标输入进行考虑，所以我们只需对鼠标按键按下的消息进行处理：当鼠标点击在空白的棋盘网格时，便执行落子操作。</p>
</li>
<li><h5 id="数据处理："><a href="#数据处理：" class="headerlink" title="数据处理："></a>数据处理：</h5><p>我们只需要对游戏的胜负条件进行检测即可，游戏结束的条件是同类型三颗棋子连成一条直线或棋盘被填满。</p>
<p>游戏结束时，使用弹窗告诉玩家游戏结果，然后退出主循环。</p>
</li>
<li><h5 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h5><p>网格棋盘：使用<code>line()</code>函数绘制直线将窗口等分为<code>3X3</code>的网格</p>
<p><code>X棋子</code>：使用<code>line()</code>函数绘制连接网格对角线的两条直线</p>
<p><code>O棋子</code>：使用<code>circle()</code>函数绘制圆心在网格中心的无填充原型</p>
<p>除此之外，我们应会在窗口左上角输出一行文字<code>当前妻子类型：X</code>，用以告诉玩家当前被放置的棋子类型。</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>接下来，便是考虑如何组织<strong>游戏的数据结构</strong>。</p>
<ol>
<li><h5 id="棋盘："><a href="#棋盘：" class="headerlink" title="棋盘："></a>棋盘：</h5><p>显而易见，我们可以使用<strong>二维数组</strong>来表示棋盘。我们将二维数组中每个元素类型设置为<code>char</code>类型，再<strong>约定</strong><code>&#39;X&#39;字符</code>表示叉号棋子、<code> &#39;O&#39;字符</code>表示圆形棋子、 <code>&#39;-&#39;字符</code>默认值表示网格中没有棋子</p>
</li>
<li><h5 id="游戏结束条件"><a href="#游戏结束条件" class="headerlink" title="游戏结束条件"></a>游戏结束条件</h5><p>2.1 某玩家<strong>获胜</strong>的情况</p>
<p>我们著需要对<code>&#39;X&#39;字符</code>、<code>&#39;O&#39;字符</code>进行穷举，可能出现的情况一共有<strong>8种</strong>：分别是横向的三行棋子出现同类型符号、竖向的三行棋子出现同类型符号和两条对角线的棋子出现同类型符号。</p>
<p>2.2 两玩家<strong>平局</strong>的情况</p>
<p>即没有玩家获胜的情况，也就是说数组中的每一个元素<strong>均不是</strong><code>&#39;-&#39;字符</code>，即可判定玩家平局。</p>
</li>
</ol>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>到现在，在我们的思路已经十分明晰后，我们着手编写代码。</p>
<p>在代码编写的过程中，我们同样遵循<strong>先框架后细化</strong>的思路。</p>
<p>我们先把上述思路转变成代码，细节部分先使用注释进行替代，再将每一部分的注释替换为代码。这样可以确保我们在编写代码的过程中不会被突然出现的代码细节打扰。</p>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 简单粗暴的全局变量并非一个好习惯</span></span><br><span class="line"><span class="type">char</span> board_data[<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当前落子类型，初始化为&#x27;O&#x27;</span></span><br><span class="line"><span class="type">char</span> cur_piece = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"><span class="comment">// 检测指定棋子的玩家是否获胜</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckWin</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">2</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测当前是否出现平局</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">			<span class="keyword">if</span> (board_data[i][j] == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制网格棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBoard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制棋子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPiece</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (board_data[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">				<span class="built_in">circle</span>(<span class="number">200</span> * j + <span class="number">100</span>, <span class="number">200</span> * i + <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">				<span class="built_in">line</span>(<span class="number">200</span> * j, <span class="number">200</span> * i, <span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line">				<span class="built_in">line</span>(<span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * i, <span class="number">200</span> * j, <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制左上角文本提示信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTipText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> TCHAR str[<span class="number">64</span>];</span><br><span class="line">	_stprintf_s(str, <span class="string">&quot;Current Type of Piece: %c&quot;</span>, cur_piece);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">225</span>, <span class="number">175</span>, <span class="number">45</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">0</span>, <span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化窗口</span></span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line">	<span class="comment">// 控制主循环是否进行下去</span></span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 消息处理</span></span><br><span class="line">	ExMessage msg;</span><br><span class="line">	<span class="comment">// 双缓冲</span></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line">	<span class="comment">// 主循环</span></span><br><span class="line">	<span class="keyword">while</span> (running)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD start_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">		<span class="comment">// 鼠标消息检测</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 检查鼠标左键按下消息</span></span><br><span class="line">			<span class="keyword">if</span> (msg.message == WM_LBUTTONDOWN)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 计算点击位置</span></span><br><span class="line"></span><br><span class="line">				<span class="type">int</span> x = msg.x;</span><br><span class="line">				<span class="type">int</span> y = msg.y;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 由于每个网格都是200X200</span></span><br><span class="line">				<span class="type">int</span> ind_x = x / <span class="number">200</span>;</span><br><span class="line">				<span class="type">int</span> ind_y = y / <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 尝试落子</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (board_data[ind_y][ind_x] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					board_data[ind_y][ind_x] = cur_piece;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 切换棋子类型</span></span><br><span class="line">					<span class="keyword">if</span> (cur_piece == <span class="string">&#x27;O&#x27;</span>) cur_piece = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">					<span class="keyword">else</span> cur_piece = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 绘制图像</span></span><br><span class="line">		<span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">DrawBoard</span>();</span><br><span class="line">		<span class="built_in">DrawPiece</span>();</span><br><span class="line">		<span class="built_in">DrawTipText</span>();</span><br><span class="line"></span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// X玩家获胜逻辑</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">CheckWin</span>(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 弹窗</span></span><br><span class="line">			<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;X Player WIN!&quot;</span>, <span class="string">&quot;Game End&quot;</span>, MB_OK);</span><br><span class="line">			<span class="comment">// 修改主循环控制条件</span></span><br><span class="line">			running = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// O玩家获胜逻辑</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">CheckWin</span>(<span class="string">&#x27;O&#x27;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 弹窗</span></span><br><span class="line">			<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;O Player WIN!&quot;</span>, <span class="string">&quot;Game End.&quot;</span>, MB_OK);</span><br><span class="line">			<span class="comment">// 修改主循环控制条件</span></span><br><span class="line">			running = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 上述条件都不满足时，对游戏平局检测</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CheckDraw</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 弹窗</span></span><br><span class="line">			<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;Ops!It&#x27;s DRAW.&quot;</span>, <span class="string">&quot;Game End.&quot;</span>, MB_OK);</span><br><span class="line">			<span class="comment">// 修改主循环控制条件</span></span><br><span class="line">			running = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 依据间隔时间动态分配休眠时间</span></span><br><span class="line">		DWORD end_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">		DWORD delta_time = end_time - start_time;</span><br><span class="line">		<span class="comment">// 按每秒60帧刷新页面</span></span><br><span class="line">		<span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">60</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - delta_time);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>值得注意的是，在程序运行时的程序占用率过高，通过任务管理器也可以发现一个小小的井字棋游戏，CPU占用率甚至已经超过了电脑中的绝大部分软件。这是因为计算机在执行<code>while循环</code>时速度较快，我们编写的主循环在顷刻间已经执行完了成千上万次，占用了大量的CPU时间片。对于大部分物理刷新率仅有<code>60Hz</code>的显示设备来说，这无疑是一种性能浪费。所以我们可以使用<code>Sleep();</code>函数来让程序在执行完一次循环后休眠一小段时间，从而减少计算资源的浪费。</p>
<p>在大多教程中，这里或许会简答粗暴的写一句<code>Sleep(15)</code>，来让程序在每一次循环结束后强制等待15毫秒。但是，这种设计是不太合适的，随游戏体量的增大，程序每次执行主循环所执行的计算任务可能是不同的，以及涉及到操作系统CPU计算资源的分配，这就导致每次执行主循环所实际消耗的时间可能是不一样的。所以我们需要根据每一帧执行的实际耗时，动态的计算在这之后要休眠多长时间，这是引入一个新的函数<code>GetTickCount()</code>。我们可以使用它来获得程序自运行开始以来到现在的毫秒数<code>DWORD time = GetTickCount();</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD start_time = <span class="built_in">GetTickCount</span>(); <span class="comment">// 获取此次循环初始时间</span></span><br><span class="line">    </span><br><span class="line">	读取操作();</span><br><span class="line">	处理数据();</span><br><span class="line">	绘制画面();</span><br><span class="line">  </span><br><span class="line">	DWORD end_time = <span class="built_in">GetTickCount</span>(); <span class="comment">// 获取此次循环结束时间</span></span><br><span class="line">    </span><br><span class="line">	DWORD delta_time = end_time - start_time; <span class="comment">// 计算间隔时间</span></span><br><span class="line">    <span class="comment">// 依据间隔时间动态分配休眠时间</span></span><br><span class="line">    <span class="comment">// 按每秒60帧刷新页面</span></span><br><span class="line">	<span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">60</span>) <span class="comment">// 如果间隔时间&lt;每秒60帧，要进行休眠；否则不需要。</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - delta_time);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure>

<h2 id="第三集-提瓦特の幸存者"><a href="#第三集-提瓦特の幸存者" class="headerlink" title="第三集 提瓦特の幸存者"></a>第三集 提瓦特の幸存者</h2><h3 id="3-1-程序动画实现及角色移动"><a href="#3-1-程序动画实现及角色移动" class="headerlink" title="3.1 程序动画实现及角色移动"></a>3.1 程序动画实现及角色移动</h3><p>在开始之前，我们应该认识到，尽管A我们可以通过<strong>点线面</strong>绘制简单的画面，但是想要只用这种<strong>矢量绘图</strong>的方式完成游戏内全部素材是远远不够的。想要绘制一个简单的人物就要洋洋洒洒300+行代码，那更不用提什A么画质精美的3A大作了。</p>
<p>所以，使用经过专业绘图软件(如：PS等)处理的<strong>位图素材</strong>是必不可少的。<strong>位图素材</strong>也就是我们常说的图片资源素材。</p>
<p>那么，我们如何在Easyx中<strong>加载并渲染图片资源</strong>呢？我们查看<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/intro">文档</a>就可发现，Easyx使用了一个叫做**<code>IMAGE</code>的类<strong>来表示</strong>图片对象<strong>；而加载图片使用一个叫做</strong><code>loadimage</code>的函数<strong>，这个函数负责将图片文件数据</strong>加载到<code>IMAGE对象</code>中**、或者直接将图片加载到绘图窗口中，同时这个函数还有一个重载，用以从资源文件中加载图像。                            		</p>
<p> 加载图片完成后，就是如何<strong>渲染图片</strong>，这里使用**<code>putimage</code>函数**。<code>putimage</code>函数同样有两个重载。</p>
<p>所以整套图片<strong>绘制的流程</strong>就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img,<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">100</span>,<span class="number">200</span>,&amp;img);</span><br></pre></td></tr></table></figure>

<p>掌握这两个函数后，我们就可以开始编写代码了。</p>
<p>在一切开始之前按照先前所讲述的，将<strong>游戏框架</strong>写出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">1280</span>, <span class="number">720</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	ExMessage msg;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (running)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD start_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cleardevice</span>();</span><br><span class="line">		<span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">		DWORD end_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">		DWORD delta_time = start_time - end_time;</span><br><span class="line">		<span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">144</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">144</span> - delta_time);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以将背景绘制在窗口中了：首先，将素材文件copy到工程目录下。<strong>需要注意</strong>的是，<u>VS在调试时使用的相对路径、根目录和新建代码的默认位置相同。</u></p>
<p>在加载渲染好背景图片后，就到了我们的重点——<strong>如何让画面”动“起来？</strong></p>
<p>在<strong>游戏开发技术</strong>中，<strong>角色动画</strong>的常见实现可以笼统的分为<strong>两类</strong>：<u>序列帧动画和关键帧动画</u>。<strong>序列帧动画</strong>通常由<strong>一组图片素材</strong>组成，我们在程序中<strong>随着时间的推移不断切换</strong>显示这一序列的图片，借助视觉暂留效应，便有了动画效果；而<strong>关键帧动画</strong>如<strong>骨骼动画</strong>等往往涉及到更复杂的图形学技术，在此暂不作讨论。</p>
<p>现在我们使用一组二次元人物图片作为游戏素材，要想实现每个一段时间切换一张图片显示，该<strong>如何处理</strong>呢？</p>
<h4 id="3-1-1-动画实现"><a href="#3-1-1-动画实现" class="headerlink" title="3.1.1 动画实现"></a>3.1.1 动画实现</h4><p>我们或许会想到<code>Sleep()</code>函数，例如：我们希望在一秒钟切换10次图片，那么只需要写下<code>Sleep(100);</code>这样的代码就可以了，吗？但是，我们在之前提及过，当调用<code>Sleep()</code>函数时，程序会卡在这里等待对应的时间，这是一个”<strong>阻塞式</strong>“的行为；而在我们的游戏框架设计中，所有的画面渲染等操作，都应该在一次又一次的循环中进行，每次循环的时间都应该控制在1&#x2F;60秒内，也就是说，我们切换动画轮播的任务，应该分摊在多帧之间进行，而不是在单次循环内一次性解决。</p>
<p>这就触及到我们游戏编程的一个<strong>核心思想</strong>：<u>主循环内应尽量避免阻塞式的行为或过于繁重且耗时过长的任务</u>。具体可以进入<strong>“高性能”编程领域</strong>深入学习。</p>
<p>为了<u>确保动画序列帧的能够间隔固定的时间进行切换</u>，我们这里类比定时器的概念实现一个<strong>计数器</strong>。</p>
<p>首先，定义<code>idx_cur_anim</code>变量来存储当前动画的<strong>帧索引</strong>；再定义一个<code>counter</code>用来记录<strong>当前动画帧</strong>一共播放了几个游戏帧，这里使用<code>staic</code>修饰计数器，<strong>保证</strong>计数器只在第一个游戏帧时被初始化为0，我们不妨每5个游戏帧切换动画帧。</p>
<p>随后，我们还要考虑到动画帧序列<strong>播放结束后的行为</strong>，我们希望动画是循环播放的，也就是当动画的帧索引到大帧总数时，将索引<strong>重置</strong>为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_ANIM_NUM = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* ...</span></span><br><span class="line"><span class="comment">    ...*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(++counter % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx_cur_anim ++;</span><br><span class="line">    &#125;</span><br><span class="line">	idx_cur_anim =  idx_cur_anim % PLAYER_ANIM_NUM;</span><br><span class="line">    <span class="comment">/* ...</span></span><br><span class="line"><span class="comment">    ...*/</span></span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了动画的<strong>数据逻辑</strong>部分，接下来就是<strong>动画的渲染部分</strong>。</p>
<p>在这之前，我们首先应该像加载背景图片那样将动画的每一帧图片都<strong>加载</strong>到程序中。定义<code>LoadAnimation()</code>函数。我们将图片规律命名，这样就可以使用循环加载图片。在使用**<code>Unicode</code>字符集**的情况下，我们可以使用<code>wstring</code>来拼凑出文件路径，进而传递给<code>loadimage()</code>函数，将图片加载到数组中。</p>
<p>现在来到<strong>游戏框架中的画面渲染</strong>部分，之前定义的动画帧索引这时便可以当作IMAGE数组的索引来使用。</p>
<p>但运行程序我们会发现，虽然人物动画轮播功能是正常的，但人物的周围套上了<strong>黑黑的边框</strong>。看起来图片的透明区域并未发生作用，这是因为<code>putimage()</code>函数在渲染过程中，并没有使用IMAGE对象的透明度信息，所以我们想要绘制类似这种带有透明度的图片素材，就要自己处理这部分逻辑。这里，我们类比<code>putimage()</code>函数<strong>封装</strong>一个<code>putimage_alpha()</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现透明通道混叠 借助系统绘图函数的比较轻巧的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;MSIMG32.LIB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line">	<span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line">	<span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h,</span><br><span class="line">		<span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, &#123;AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行程序，就可以发现动画被<strong>正常渲染</strong>了。</p>
<h4 id="3-1-2-角色移动"><a href="#3-1-2-角色移动" class="headerlink" title="3.1.2 角色移动"></a>3.1.2 角色移动</h4><p>接着，我们来实现<strong>键盘控制角色移动</strong>的功能。</p>
<p>我们首先定义<code>POINT</code>类型的<code>player_pos</code>变量用来存储玩家的位置，记得将玩家坐标初始化。随后将动画渲染的位置更改为<code>player_pos</code>变量的位置。</p>
<p>这时，只需要在<strong>事件处理部分</strong>根据按键<strong>修改</strong><code>player_pos</code>的值，就可以实现角色的移动。</p>
<p>我们只需要对<strong>键盘按下的消息</strong>进行处理，定义<code>PLAYER_SPEED</code>常量表示玩家速度，并<strong>约定</strong>使用方向键控制玩家移动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.message = WM_KEYDOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    player_pos.y -= PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    player_pos.y += PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    player_pos.x -= PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    player_pos.x += PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br></pre></td></tr></table></figure>

<p>关于<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">键码对照表</a>可以查看微软官方文档。</p>
<p>运行程序，我们可以发现角色可以移动了，但人物的移动“手感”有些奇怪。当我们按下方向键，角色向着对应的方向抽搐了一下，一段时间后才进行较为连贯的移动，在连续移动的过程中顿挫感也十分明显。</p>
<p>出现此等<strong>原因主要有二</strong>：<em>1</em>.<strong>首先</strong>是持续按下一小段时间后才开始连贯移动的问题。这是因为当我们按下方向键时，会首先有一个<code>WM_KEYDOWN</code>消息进入消息事件队列中，随后，当我们我们保持按键按下状态一段时间后，才会有接连不断的<code>WM_KEYDOWN</code>消息被触发；<em>2</em>.<strong>然后</strong>是移动过程中的卡顿问题。这是因为<code>WM_KEYDOWN</code>消息的产生是与我们的主循环<strong>异步进行</strong>的，且触发的频率与操作系统和硬件设备相关，这就导致在有些游戏帧中事件处理部分对多个<code>WM_KEYDOWN</code>消息进行了处理，而在其余游戏帧中<code>WM_KEYDOWN</code>消息较少或没有，这就导致角色在某些游戏帧中前进的距离较远&#x2F;近一些，在宏观上展现为移动过程中的卡顿感。</p>
<p>解决问题就要<strong>理清思路</strong>，我们抽象地总结实际的<strong>功能需求</strong>：当按键按下时，我们要确保在每一个游戏帧中都连贯的移动相同的距离；从玩家的行为角度讲，也就是玩家<strong>按下按键</strong>时，<code>WM_KEYDOWN</code>消息触发，标志角色<strong>开始移动</strong>；而当玩家<strong>按键抬起</strong>时，<code>WM_KEYUP</code>消息触发，标志<strong>移动结束</strong>。</p>
<p>那么我们的<strong>解决方案</strong>就明晰了。我们首先定义4个<code>bool</code>变量分别标志玩家是否向对应方向移动。在<strong>事件处理部分</strong>，不直接对玩家的位置数据进行操作，而是设置这些布尔变量的值，按键按下设为<code>true</code>、按键抬起设为<code>false</code>。在<strong>数据处理部分</strong>，我们再根据这些布尔变量的状态确定是否对玩家的位置进行处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line">	<span class="type">bool</span> is_move_up = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_down = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_left = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_right = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line">	<span class="keyword">while</span>(running)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/*...</span></span><br><span class="line"><span class="comment">		...*/</span></span><br><span class="line">    	<span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">    	&#123;</span><br><span class="line">        	<span class="keyword">if</span>(msg.message = WM_KEYDOWN)</span><br><span class="line">        	&#123;</span><br><span class="line">           		<span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            	&#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    is_move_up = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    is_move_down = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    is_move_left = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    is_move_right = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(msg.message = WM_KEYUP)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            	&#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    is_move_up = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    is_move_down = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    is_move_left = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    is_move_right = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span>(is_move_up) plaayer_pos.y -= PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_down) plaayer_pos.y += PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_left) plaayer_pos.x -= PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_right) plaayer_pos.x += PLAYER_SPEED;</span><br><span class="line">        <span class="comment">/*...</span></span><br><span class="line"><span class="comment">		...*/</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br></pre></td></tr></table></figure>



<h3 id="3-2-敌人随机生成和索敌逻辑实现"><a href="#3-2-敌人随机生成和索敌逻辑实现" class="headerlink" title="3.2 敌人随机生成和索敌逻辑实现"></a>3.2 敌人随机生成和索敌逻辑实现</h3><h4 id="3-2-1-动画类实现"><a href="#3-2-1-动画类实现" class="headerlink" title="3.2.1 动画类实现"></a>3.2.1 动画类实现</h4><p>到目前为止，我们已经实现了人物面向左的动画，那么面向右的动画同理：定义IMAGE数组，加载图片到IMAGE数组中，然后在主循环中使用计数器来更新动画的帧索引，最后在绘图阶段将对应帧索引的图片绘制出来。但是这样一来，我们就有两部分<strong>能极度相似</strong>的<strong>动画播控代码</strong>了，若后续仍有动画加入到游戏中，我们就还要讲这些代码再写一遍，这就造成了<strong>代码冗余</strong>。</p>
<p>我们所使用的不同动画之间的<strong>区别</strong>，无非只是加载和显示的图片不同，而其中更新帧索引和绘制的部分都是完全一样的代码。</p>
<p>于是，我们可以将动画<strong>封装</strong>成结构体或类，相同的逻辑封装成成员方法，不同的部分使用参数传递。没错，这就是面向对象的3大特性之一的<strong>封装</strong>。</p>
<p>我们这里定义**<code>Animation</code>类<strong>，用来封装动画相关的数据和逻辑。接下来，我们在填充类的细节的时候，要考虑的就是有哪些数据和功能放在</strong>类内部**。</p>
<p><strong>首先是动画的图片加载。</strong>考虑到动画所包含的图片帧数量可能是不同的，需要动态的为图片对象序列分配内存，所以这里使用动态数组(向量)<code>vector</code>容器来代替我们常见的数组。</p>
<p><code>vector</code>容器是<strong>STL</strong>(标准模板库，Standard Template Library)中的内容,STL提供了许多方便我们开发中使用的工具。</p>
<p>为了避免不必要的拷贝构造，我们将<code>vector</code>内部存储的元素定义为IMAGE类型的指针：<code>vector&lt;IMAGE*&gt; -&gt; IMAGE*[]</code>。这里，二者的<strong>主要区别</strong>是，<code>vector</code>是一个根据元素数量动态增长的容器，而不需要像数组那样一开始便固定其容量大小。</p>
<ol>
<li><p>我们将动画帧序列的<code>vector</code>容器定义为<strong>私有成员</strong>;</p>
</li>
<li><p>加载图片的部分自然就需要放在构造函数里面。这里抽象一下加载动画所需要的参数<code>Animation(LPCTSTR path,int num,int inteval)</code>分别是：图片文件包含的路径、当前动画所使用的图片数量和帧间隔(由于在目前的动画中，帧与帧之间的时间间隔是固定的)；</p>
</li>
<li><p>循环加载图片。由于我们使用的图片素材命名都十分规律，所以可以直接将路径参数当作字符串格式化的模板；最后，我们将图片对象的指针添加到<code>vector</code>容器中，即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCHAR path_file[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">&#123;</span><br><span class="line">    _stprintf_s(path_file,path,i);</span><br><span class="line">    </span><br><span class="line">    IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">    <span class="built_in">loadimage</span>(frame,path_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：由于我们的<code>vector</code>内部存储的元素定义为IMAGE类型的指针，所以我们这里使用了<code>new</code>关键字来开辟内存。</p>
</li>
</ol>
<p>🔺很多人在初学时会忽略掉有关<strong>内存管理</strong>的问题，所以会养成内存泄漏的坏习惯。我们在这里使用了<code>new</code>关键字，那么我们就要马上警惕起来，在哪里使用<code>delete</code>释放掉内存？</p>
<p>就像在C语言中每个<code>malloc</code>对应一个<code>free</code>一样，在CPP中，我们要养成习惯去检查每一个<code>new</code>也要对应一个<code>delete</code>。</p>
<p>所以在<strong>析构函数</strong>中，我们需要遍历<code>vector</code>的每一个元素，一次将它<code>delete</code>掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animation</span>(LPCTSTR path,<span class="type">int</span> num,<span class="type">int</span> inteval)</span><br><span class="line">    &#123;</span><br><span class="line">        interval_ms = interval;</span><br><span class="line">        </span><br><span class="line">        TCHAR path_file[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">		&#123;</span><br><span class="line">   			_stprintf_s(path_file,path,i);</span><br><span class="line">    </span><br><span class="line">    		IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">    		<span class="built_in">loadimage</span>(frame,path_file);</span><br><span class="line">            frame_list.<span class="built_in">push_back</span>(frame);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Animation</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意这里使用vector存储原始指针似乎是危险的事情，可以使用智能指针。具体还请移步看相关资料文献。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; frame_list.<span class="built_in">size</span>();i ++)</span><br><span class="line">            <span class="keyword">delete</span> frame_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;IMAGE*&gt; frame_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-角色移动优化"><a href="#3-2-2-角色移动优化" class="headerlink" title="3.2.2 角色移动优化"></a>3.2.2 角色移动优化</h4><p><strong>然后是动画播放的部分</strong>。我们定义**<code>Play</code>函数**，暂时将帧索引更新的逻辑和渲染的代码都放置到函数中，这样我们就需要传入<code>x</code>和<code>y</code>两个参数来表示动画当前渲染的位置，最后我们还定义一个参数<code>delta</code>，用来表示距离上一次调用<code>Play</code>函数过去了多久时间。这其实已经将我们之前的动画计数器的思路转变为了计时器的思路。</p>
<p>那这两种思路之间有什么<strong>区别</strong>呢？</p>
<p>一般来说，一个动画的播放速度也就是<strong>帧间隔</strong>，应该是与实际时间有关的，而不是与游戏的帧率有关，我们希望的是无论游戏帧的频率有多快，动画的播放速度是一致的，而不是画面刷新越快，动画播放越快，这样整个游戏画面就如同开了“倍速”一样。所以使用与实际时间有关的定时器，会比每一下调用都累加一次的计数器更能满足这种需求。</p>
<p>我们只需要在每次调用<code>Play</code>函数时，对<code>timer</code>计时器变量增加对应的时间，如果定时器到达帧间隔，那么就切换动画图片到下一帧，同时重置定时器的值。最后通过我们之前定义好的<code>putimage_alpha</code>函数绘制当前动画帧，这是我们就可以使用简洁的代码来加载玩家角色向左向右的动画了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Animation <span class="title">anim_left_player</span><span class="params">(_T(<span class="string">&quot;img/player_left_%d.png&quot;</span>),<span class="number">6</span>,<span class="number">45</span>)</span></span>;</span><br><span class="line"><span class="function">Animation <span class="title">anim_right_player</span><span class="params">(_T(<span class="string">&quot;img/player_right_%d.png&quot;</span>),<span class="number">6</span>,<span class="number">45</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们定义<code>DrawPlayer</code>函数用以绘制玩家动画。由于需要左右翻转还需要传入玩家当前在x轴上的移动方向；动画实现左右翻转的逻辑也很简单：我们定义<code>facing_left</code>静态布尔变量，表示玩家动画是否面向左侧。在绘制动画时，只需要根据<code>facing_left</code>的值判断当前绘制的是向左还是向右的动画即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayer</span><span class="params">(<span class="type">int</span> delta,<span class="type">int</span> dir_x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(dir_x &lt; <span class="number">0</span>)</span><br><span class="line">    	facing_left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dir_x &gt; <span class="number">0</span>)</span><br><span class="line">        facing_left = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(facing_left)</span><br><span class="line">    	anim_left_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        anim_right_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让玩家再游戏画面中更加醒目，我们考虑在玩家的脚底添加<strong>阴影效果</strong>。阴影的实现同样也是使用图片素材<code>IMAGE img_shadow</code>，将它添加进来，并绘制在玩家的脚底。我们定义三个常量用来存储玩家的图片尺寸和阴影宽度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_WIDTH = <span class="number">80</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_HEIGHT = <span class="number">80</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHADOW_WIDTH = <span class="number">32</span>;</span><br></pre></td></tr></table></figure>

<p>在计算阴影的<strong>水平</strong>位置时，我们考虑将阴影居中，<code>int pos_shadow_x = player_pos_x + (PLAYER_WIDTH / 2 - SHADOW_WIDTH / 2);</code>；在计算<strong>竖直</strong>位置时，我们将它放到玩家脚底偏移一小段的地方。然后在绘制玩家动画之前绘制阴影图片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayer</span><span class="params">(<span class="type">int</span> delta,<span class="type">int</span> dir_x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos_shadow_x = player_pos_x + (PLAYER_WIDTH / <span class="number">2</span> - SHADOW_WIDTH / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> pos_shadow_y = player_pos_y + PLAYER_HEIGHT - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">putimage_alpha</span>(pos_shadow_x,pos_shadow_y,&amp;img_shadow);</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(dir_x &lt; <span class="number">0</span>)</span><br><span class="line">    	facing_left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dir_x &gt; <span class="number">0</span>)</span><br><span class="line">        facing_left = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(facing_left)</span><br><span class="line">    	anim_left_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        anim_right_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在玩家所有的<strong>移动功能都已经完成</strong>了。但是，移动手感似乎有些奇怪，玩家在斜向移动的时候速度快一些。</p>
<p>在处理玩家移动的代码中，我们发现，当我们同时按下处于x和y轴两个方向的按键时，玩家的位置坐标就在这一帧内向着两个方向<strong>都</strong>移动了一个单位距离，由勾股定理，这就导致这一帧玩家的位移距离是<strong>根号二</strong>倍的速度，于是就有了<strong>斜向移动更快</strong>的现象。我们这里可以通过<code>if else</code>来判断当玩家按下处于x和y轴两个方向的按键时，x和y坐标改变的数值变为<code>PALYER_SPPED/根号2</code>，但是要处理多种组合的情况，使用<code>if else</code>有些过于<strong>冗长</strong>，所以我们这里只需要借用一点点向量运算的知识，来确保玩家每次位移的大小都是相同的。</p>
<p>只需要确保运算时的速度方向向量是单位向量即可。</p>
<p>这里使用<code>double</code>来尽可能避免浮点数和整形互相转换的精度丢失问题，可是依旧会有小问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir_x = is_move_right - is_move_left;</span><br><span class="line"><span class="type">int</span> dir_y = is_move_down - is_move_up;</span><br><span class="line"><span class="type">double</span> len_dir = <span class="built_in">sqrt</span>(die_x * die_x + dir_y + dir_y);</span><br><span class="line"><span class="keyword">if</span>(len_dir != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> nomalized_x = dir_x / len_dir;</span><br><span class="line">    <span class="type">double</span> nomalized_y = dir_y / len_dir;</span><br><span class="line">    player_pos.x += (<span class="type">int</span>)(PLAYER_SPEED * normalized_x);</span><br><span class="line">    player_pos.y += (<span class="type">int</span>)(PLAYER_SPEED * normalized_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>,<span class="number">0</span>,&amp;img_backguond);</span><br><span class="line"><span class="built_in">DrawPlayer</span>(<span class="number">1000</span> / <span class="number">144</span>,dir_x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br></pre></td></tr></table></figure>

<p>再次运行程序，玩家的移动速度在各个方向上都确定了。</p>
<p>在玩家移动上，我们还有一个细节仍待处理：我们需要玩家<strong>始终处于画面内</strong>，也就是说玩家动画所在矩形必须位于1280X720尺寸的窗口内部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_WIDTH = <span class="number">1280</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_HEIGHT = <span class="number">720</span>;</span><br></pre></td></tr></table></figure>

<p>再根据按键输入更新玩家的位置后，我们就还需要对玩家的位置进行<strong>校准</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(player_pos.x &lt; <span class="number">0</span>) player_pos.x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(player_pos.y &lt; <span class="number">0</span>) player_pos.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(play_pos.x + PLAYER_WIDTH &gt; WINDOW_WIDTH) player_pos.x = WINDOW_WIDTH - PLAYER_WIDTH;</span><br><span class="line"><span class="keyword">if</span>(play_pos.y + PLAYER_HEIGHT &gt; WINDOW_HEIGHT) player_pos.y = WINDOW_HEIGHT - PLAYER_HEIGHT;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-玩家类和敌人类实现"><a href="#3-2-3-玩家类和敌人类实现" class="headerlink" title="3.2.3 玩家类和敌人类实现"></a>3.2.3 玩家类和敌人类实现</h4><p>我们使用野猪🐗表示敌人，野猪同样也有面向左和右两套动画，从<strong>代码设计角度考虑</strong>讲，让这些野猪Animation对象与玩家的Animation对象<strong>混杂</strong>在一起显然不好。</p>
<p>所以我们再次使用<strong>封装</strong>这一特性，将玩家的逻辑封装到<code>Player</code>类中，而与敌人相关的逻辑就封装在<code>Enemy</code>类中。虽然我们可以将玩家和敌人共同的逻辑<strong>抽象出来</strong>，定义<strong>更基础的类</strong>，如<code>Character</code>角色或<code>GameObject</code>游戏对象，这些设计会涉及到面向对象中另<strong>两大特性</strong>——<strong>继承和多态</strong>。</p>
<p>但，目前我们不使用继承和多态进行实践，而仅使用封装来确保数据和逻辑。</p>
<p><strong>首先，玩家类<code>Player</code>的实现。</strong></p>
<p>我们<strong>首先</strong>将和玩家类相关的散落在外部的成员变量和常量放在<code>Player类</code>中；然后定义<code>ProcessEvent</code>函数来处理玩家的操作消息、定义<code>Move</code>函数来处理玩家的移动、定义<code>Draw</code>函数来绘制玩家；然后将对应逻辑的代码移动到函数内部，注意一些微调整。最终玩家类的代码就完成了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Player</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_shadow, _T(<span class="string">&quot;img/shadow_player.png&quot;</span>));</span><br><span class="line">		anim_left = <span class="keyword">new</span> <span class="built_in">Animation</span>(_T(<span class="string">&quot;img/player_left_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>);</span><br><span class="line">		anim_right = <span class="keyword">new</span> <span class="built_in">Animation</span>(_T(<span class="string">&quot;img/player_right_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Player</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span> anim_left;</span><br><span class="line">		<span class="keyword">delete</span> anim_right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ProcessEvent</span><span class="params">(<span class="type">const</span> ExMessage&amp; msg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> delta)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SPEED = <span class="number">3</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> FRAME_WIDTH = <span class="number">80</span>; <span class="comment">// 玩家宽度</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> FRAME_HEIGHT = <span class="number">80</span>; <span class="comment">// 玩家高度</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SHADOW_WIDTH = <span class="number">32</span>; <span class="comment">// 阴影宽度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	IMAGE img_shadow;</span><br><span class="line">	Animation* anim_left;</span><br><span class="line">	Animation* anim_right;</span><br><span class="line">	POINT position = &#123; <span class="number">500</span>,<span class="number">500</span> &#125;; <span class="comment">// 玩家位置</span></span><br><span class="line">	<span class="type">bool</span> is_move_up = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_down = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_left = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> is_move_right = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>然后，是子弹类<code>Bullet</code>的实现。</strong></p>
<p>其中并没有太多复杂的数据和逻辑。成员变量只需要有位置信息，而在<strong>渲染方法</strong><code>Draw</code>里面我们使用橙红色填充圆来进行绘制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	POINT position = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bullet</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">Bullet</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">setlinecolor</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">155</span>, <span class="number">50</span>));</span><br><span class="line">		<span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">200</span>, <span class="number">75</span>, <span class="number">10</span>));</span><br><span class="line">		<span class="built_in">fillcircle</span>(position.x, position.y, RADIUS);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> RADIUS = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>随后，是敌人类<code>Enemy</code>的实现。</strong></p>
<p>我们<strong>仿照</strong>着Player类定义Enemy类。</p>
<p>接下来便是设计敌人类中的成员方法，不过在此之前，我们要先想清楚敌人的<strong>行动逻辑</strong>：我们希望敌人从地图外的<strong>随机位置刷新</strong>出来，并<strong>向着玩家移动</strong>，敌人<strong>触碰玩家</strong>时会对玩家造成伤害<strong>游戏结束</strong>；敌人<strong>触碰</strong>到玩家周围的<strong>子弹</strong>时会<strong>消失</strong>。</p>
<p><strong>首先是敌人的刷新机制</strong>，即敌人在生成时随机初始化自己位置。所以此逻辑要放在<strong>构造函数</strong>中。地图有四条边，这里定义<code>SpawnEdge</code>枚举用以标识敌人出生的边界，使用<strong>随机数%4</strong>后便可实现随机地图边界的效果。接下来是地图的坐标值，分类讨论，对于上边界它的x位置坐标应该是随机的，其他同理推出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敌人生出边界</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">SpawnEdge</span></span><br><span class="line">&#123;</span><br><span class="line">	Up = <span class="number">0</span>,</span><br><span class="line">	Down,</span><br><span class="line">	Left,</span><br><span class="line">	Right</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将敌人放置在地图边界外的随机处</span></span><br><span class="line">SpawnEdge edge = (SpawnEdge)(<span class="built_in">rand</span>() % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">switch</span> (edge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Up:</span><br><span class="line">	position.x = <span class="built_in">rand</span>() % WINDOW_WIDTH;</span><br><span class="line">	position.y = -FRAME_HEIGHT;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Down:</span><br><span class="line">	position.x = <span class="built_in">rand</span>() % WINDOW_WIDTH;</span><br><span class="line">	position.y = WINDOW_HEIGHT;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Left:</span><br><span class="line">	position.x = -FRAME_WIDTH;</span><br><span class="line">	position.y = <span class="built_in">rand</span>() % WINDOW_HEIGHT;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Right:</span><br><span class="line">	position.x = WINDOW_WIDTH;</span><br><span class="line">	position.y = <span class="built_in">rand</span>() % WINDOW_HEIGHT;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后是碰撞向相关函数</strong>，检测与子弹发生的碰撞传入<code>Bullet</code>参数，检测与玩家发生的碰撞传入<code>Player</code>参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBulletCollision</span><span class="params">(<span class="type">const</span> Bullet&amp; bullet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckPlayerCollision</span><span class="params">(<span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Move</code>函数需要始终追寻玩家移动，所以传入<code>Player</code>参数。</p>
<p><strong>值得注意的是</strong>，<u>我们传入的参数都应添加引用这与使用指针进行参数传递类似，都是为了避免在传入参数过程中对传入的对象进行了不必要的拷贝构造；同时，又添加<code>const</code>限定符来避免在函数内部不小心对参数进行了修改，这是一个好习惯。</u></p>
<p><strong><code>Move</code>函数实现逻辑与玩家类十分相似</strong>，我们只需要将玩家的位置与敌人的位置进行作差，即可得到敌人需要移动的向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> POINT&amp; player_position = player.<span class="built_in">GetPosition</span>();</span><br><span class="line">	<span class="type">int</span> dir_x = player_position.x - position.x;</span><br><span class="line">	<span class="type">int</span> dir_y = player_position.y - position.y;</span><br><span class="line">	</span><br><span class="line">	<span class="type">double</span> len_dir = <span class="built_in">sqrt</span>(dir_x * dir_x + dir_y * dir_y);</span><br><span class="line">	<span class="keyword">if</span> (len_dir != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> nomalized_x = dir_x / len_dir;</span><br><span class="line">		<span class="type">double</span> nomalized_y = dir_y / len_dir;</span><br><span class="line">		position.x += (<span class="type">int</span>)(SPEED * nomalized_x);</span><br><span class="line">		position.y += (<span class="type">int</span>)(SPEED * nomalized_y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dir_x &lt; <span class="number">0</span>) facing_left = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随后是绘制敌人的<code>Draw</code>函数</strong>，也与玩家类中的实现十分相似。由于敌人始终处于移动状态，所以我们不需要使用<code>static</code>变量静态保存无移动时的动画翻转状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> pos_shadow_x = position.x + (FRAME_WIDTH / <span class="number">2</span> - SHADOW_WIDTH / <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> pos_shadow_y = position.y + FRAME_HEIGHT - <span class="number">35</span>;</span><br><span class="line">	<span class="built_in">putimage_alpha</span>(pos_shadow_x, pos_shadow_y, &amp;img_shadow);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (facing_left)</span><br><span class="line">		anim_left-&gt;<span class="built_in">Play</span>(position.x, position.y, delta);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		anim_right-&gt;<span class="built_in">Play</span>(position.x, position.y, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>游戏中的面向对象的设计已初具雏形，现在我们要考虑的是：如何在主循环<strong>实例化</strong>这些对象。</p>
<p>玩家对象全局只有一个，所以我们定义在<strong>主循环外部</strong>；在<strong>消息处理</strong>部分，调用<code>Player</code>类的<code>ProcessEvent</code>方法处理玩家在操作事件；在数据处理部分调用<code>Move</code>进行移动；在渲染部分调用<code>Draw</code>来绘制画面。</p>
<p>由于游戏中敌人数量也是<strong>动态</strong>的，所以我们这里同样使用<code>vector</code>来存储<code>Enemy</code>的对象指针。在主循环中，我们使用一个定义<code>TryGenerateEnemy</code>函数来生成敌人，为了简单起见，函数内置了一个计数器，当到达指定时间间隔便向容器中添加新的敌人。在数据如理部分，我们遍历<code>vector</code>中的每一个敌人依次调用<code>Move</code>方法，在渲染部分也依次调用<code>Draw</code>方法。</p>
<p><del>（PS ：最后，我们会发现<code>Move()</code>函数中，角色位置改变运用了浮点型强转为整形所造成精度丢失，是玩家和敌人的SPEED范围有限，这是一个问题。）</del></p>
<h3 id="3-3-2D碰撞检测和音效播控"><a href="#3-3-2D碰撞检测和音效播控" class="headerlink" title="3.3 2D碰撞检测和音效播控"></a>3.3 2D碰撞检测和音效播控</h3><h4 id="3-3-1-子弹碰撞逻辑"><a href="#3-3-1-子弹碰撞逻辑" class="headerlink" title="3.3.1 子弹碰撞逻辑"></a>3.3.1 子弹碰撞逻辑</h4><p>在前面的代码中，我们已经定义了子弹类，也定义了敌人与子弹和玩家的碰撞方法。但实际的<strong>碰撞逻辑仍未实现</strong>。</p>
<p><strong>首先是敌人和子弹的碰撞</strong>。在<code>CheckBulletCollision</code>方法中，我们将子弹等效为一个点。如果想要检定这两者的碰撞，那么只要检测这个<strong>点是否在敌人所处矩形内</strong>。而判断二维平面内点在矩形内十分简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBulletCollision</span><span class="params">(<span class="type">const</span> Bullet&amp; bullet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 将子弹等效为点</span></span><br><span class="line">	<span class="type">bool</span> is_overlap_x = bullet.position.x &gt;= position.x &amp;&amp; bullet.position.x &lt;= position.x + FRAME_WIDTH;</span><br><span class="line">	<span class="type">bool</span> is_overlap_y = bullet.position.y &gt;= position.y &amp;&amp; bullet.position.y &lt;= position.y + FRAME_HEIGHT;</span><br><span class="line">	<span class="keyword">return</span> is_overlap_x &amp;&amp; is_overlap_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后是敌人和玩家的碰撞检测</strong>，这就涉及到<strong>两个矩形之间的相交检测</strong>。但是，如果我们将二者的碰撞模型抽象成两个矩形的相交，我们考虑这样一种极端情景：敌人的位置处于玩家的对角线方向处，此时二者并未重合，但是数据逻辑上却判定为碰撞，这会让玩家非常困惑。所以，<u>在大部分2D游戏作品中的程序设计中，对于这类受击碰撞箱，其实是要小于玩家所在的碰撞箱</u>。考虑到我们的游戏敌人的尺寸并不大，以及这类割草游戏中对于碰撞的检定不应过于严格，所以我们<strong>以敌人的中心点位置作为其碰撞坐标</strong>，只有当敌人的中心点在玩家矩形箱内，二者才发生碰撞，敌人才能对玩家造成伤害。所以在<code>CheckPlayerCollision</code>方法中，我们<strong>首先</strong>应该计算出敌人的判定点位置，<strong>随后</strong>再判断这个点是否在玩家当前所在矩形内。注意，由于我们这里需要获取玩家的实时位置，所以我们扩展了玩家类的方法，为它提供了一个<code>GetPosition</code>方法来返回玩家当前坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> POINT&amp; <span class="title">GetPosition</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，我们还需要在<strong>主循环</strong>中遍历敌人列表，依次检测他们是否与玩家发生了碰撞，当二者发生碰撞时，我们弹出提示信息，结束游戏。</p>
<p><strong>接下来</strong>，我们要让<strong>子弹</strong>显示在画面中了。</p>
<p>首先定义子弹<code>vector</code>并初始化它的长度为3。随后，我们定义<code>UpdateBullets</code>函数用以在主循环实现子弹实时跟随玩家的逻辑。</p>
<p>三颗子弹只是均匀做圆周运动太过死板，所以我们让子弹有除去圆周运动的切向速度外，还有一个不断波动的径向速度；在视觉效果上，这些子弹会围绕着玩家进行时近时远的圆周运动。</p>
<p>我们<strong>首先定义子弹的径向速度和切向速度</strong>。切向速度决定了圆周运动的快慢，而径向速度决定了子弹距离玩家时近时远波动速度。计算子弹之间的角度间隔也十分简单。最后我们遍历子弹列表中的每一个子弹，根据玩家当前的位置依次修改它们的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateBullets</span><span class="params">(std::vector&lt;Bullet&gt;&amp; bullet_list, <span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> RADIAL_SPEED = <span class="number">0.0045</span>; <span class="comment">// 径向</span></span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> TANGENT_SPEED = <span class="number">0.0055</span>; <span class="comment">// 切向</span></span><br><span class="line">	<span class="type">double</span> radian_interval = <span class="number">2</span> * <span class="number">3.14159</span> / bullet_list.<span class="built_in">size</span>(); <span class="comment">// 子弹之间的弧度间隔</span></span><br><span class="line">	POINT player_position = player.<span class="built_in">GetPosition</span>();</span><br><span class="line">	<span class="type">double</span> radius = <span class="number">100</span> + <span class="number">25</span> * <span class="built_in">sin</span>(<span class="built_in">GetTickCount</span>() * RADIAL_SPEED);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bullet_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> radian = <span class="built_in">GetTickCount</span>() * TANGENT_SPEED + radian_interval * i;</span><br><span class="line">		bullet_list[i].position.x = player_position.x + player.FRAME_WIDTH / <span class="number">2</span> + (<span class="type">int</span>)(radius * <span class="built_in">sin</span>(radian));</span><br><span class="line">		bullet_list[i].position.y = player_position.y + player.FRAME_HEIGHT / <span class="number">2</span> + (<span class="type">int</span>)(radius * <span class="built_in">cos</span>(radian));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，我们要编写<strong>敌人受击消失</strong>的逻辑了。</p>
<p>为了更通用的设计，我们给<code>Enemy</code>类中新增了两个方法<code>Hurt</code>和<code>CheckAlive</code>，同时，新增<code>alive</code>布尔变量标识敌人当前是否是存活状态。</p>
<p><code>Hurt</code>方法为受击方法，当敌人收到攻击时便会调用；<code>CheckAlive</code>方法为敌人存活检测方法，函数直接返回<code>alive</code>成员的值，用来在类外获取当前敌人存活状态。</p>
<p>在<code>Hurt</code>方法中，常见的思路是递减敌人血量，这里我们使用最简单的方法，让敌人一被击必杀。</p>
<p>那么在主循环中，当<code>CheckBulletCollision</code>成功时，便要调用敌人类的<code>Hurt</code>方法，而在碰撞检测结束后，我们还需要遍历现存的敌人列表，依次检查已经被击杀的敌人，并将它们从游戏中删掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Enemy* enemy : enemy_list)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> Bullet&amp; bullet : bullet_list)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (enemy-&gt;<span class="built_in">CheckBulletCollision</span>(bullet))</span><br><span class="line">		&#123;</span><br><span class="line">			enemy-&gt;<span class="built_in">Hurt</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们使用<code>swap</code>和<code>pop_back</code>组合技来实现从<code>vector</code>中删除元素，这是一种<strong>在元素次序无关时性能较好的删除方法</strong>，原理十分简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; enemy_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	Enemy* enemy = enemy_list[i];</span><br><span class="line">	<span class="keyword">if</span> (!enemy-&gt;<span class="built_in">CheckAlive</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		std::<span class="built_in">swap</span>(enemy_list[i], enemy_list.<span class="built_in">back</span>());</span><br><span class="line">		enemy_list.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">delete</span> enemy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仿照其他游戏，<strong>得分机制</strong>是必不可少的。</p>
<p>所以，我们定义<code>score</code>变量记录玩家得分，并定义<code>DrawPlayerScore()</code>绘制得分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制玩家得分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayerScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> TCHAR text[<span class="number">64</span>];</span><br><span class="line">	_stprintf_s(text, _T(<span class="string">&quot;当前玩家得分：%d&quot;</span>), score);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">85</span>, <span class="number">185</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">10</span>, <span class="number">10</span>, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们的游戏基本上已经完成，但总感觉不得劲，哎？没错，音效和音乐。</p>
<h4 id="3-3-2-音效音乐播控"><a href="#3-3-2-音效音乐播控" class="headerlink" title="3.3.2 音效音乐播控"></a>3.3.2 音效音乐播控</h4><p>这里提供一种较为简单轻巧的<strong>音乐播放实现</strong>方式：<code>mciSendString</code>。</p>
<p>我们首先需要将<code>mus</code>文件素材放置对应目录下，随后在代码种来链接对应的库<code>#pragma comment(lib,&quot;Winnm.lib&quot;)</code>。</p>
<p>这个函数的前三个字母<code>mci</code>代表了<code>Media Control Interface</code>即：媒体控制接口。它的作用更像是我们对<code>Windows</code>系统发号施令，我们把字符串形式的命令告诉系统，让它们来帮我们播放声音。</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/previous-versions/dd757161(v=vs.85)">使用文档</a></p>
<p>我们只需要关注第一个参数，也就是我们要对<code>Windows</code>系统发出的“命令”，当我们<strong>加载背景音乐</strong>的时候，我们可以编写这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;open mus/bgm.mp3 alias bgm&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>这样便是告诉系统：你要把<code>mus</code>目录下<code>bgm.mp3</code>文件加载到程序中，并且在后续的命令中，我们给这个音乐取名为”<code>bgm</code>“。</p>
<p>当我们需要<strong>播放背景音乐</strong>时，我们呢&#x3D;只需要写下这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;play bgm repeat from 0&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>这样就是在和系统说：现在我要播放先前已经追备好的名为<code>bgm</code>的音乐，并让它从头循环播放。于是，背景音乐便添加完成。</p>
<p>那么子弹击中敌人的音效也十分简单，我们编写相似的代码加载<code>hit.wav</code>文件并取名为<code>hit</code>，并在子弹碰撞时播放，注意此时并未添加<code>repeat</code>命令，来确保受击音效不会出发后永无休止的循环播放下去。</p>
<p>至此，游戏内部数据逻辑已全部完成，除去一些卡顿的bug，会在后续课程中优化。</p>
<h3 id="3-4-用户界面实现和设计模式基础"><a href="#3-4-用户界面实现和设计模式基础" class="headerlink" title="3.4 用户界面实现和设计模式基础"></a>3.4 用户界面实现和设计模式基础</h3><h4 id="3-4-1-导言"><a href="#3-4-1-导言" class="headerlink" title="3.4.1 导言"></a>3.4.1 导言</h4><p>假设这样一个场景：在一个游戏中，出现在你的视野中的树木数以千计，虽然我们会惊叹建模师和贴图美术师们逼真的还原水平，但程序并不在乎。它只关心如何从磁盘中加载这些数据，并将其高效地渲染在游戏窗口。</p>
<p>我们随意挑出一棵树，若这棵树是绘制在3D场景中，构成它的资源可以笼统的分为模型和贴图两类。在许多3A大作的游戏资源包中，模型和贴图相关的资源所占的比例是极高的。它们不仅占据了大量的硬盘空间，也占据了游戏启动时加载的大部分时间。如果我们把一棵树在内存中所占用的资源为10MB计算，场景中1000棵树就需要10000MB，也就是说，只是为了把屏幕上把这些树绘制出来就需要占用电脑9.8GB左右的内存。这对于玩家显然是不合理的，况且想要从磁盘上加载1000个模型，也需要十分恐怖的加载时间。</p>
<p>那么我们可能会问，我<strong>只需要加载一棵树</strong>的模型，然后再游戏里把他绘制1000次不就好了？确实如次，虽然在现代的游戏技术中，对于树木这种大批量出现的渲染任务已有许多成熟的解决方案，但他们都离不开一个设计模式——<strong>“享元模式”</strong>。</p>
<h4 id="3-4-2-享元模式"><a href="#3-4-2-享元模式" class="headerlink" title="3.4.2 享元模式"></a>3.4.2 享元模式</h4><p>“<strong>享元</strong>”即“共享元素”的意思。”<strong>享元模式</strong>“是设计模式中使用热度极高的模式之一。（<strong>设计模式</strong>是一套被反复使用 多数人知晓的 经过分类编码的 代码设计经验的总结），他不像<code>C++</code>等编程语言的语法那样白纸黑字，但也是一套自成体系的<strong>方法论</strong>。</p>
<p>若我们把算法比作功夫中的内功，那么设计模式就是外功招式。</p>
<p>就像在引言所讲述的树林场景，我们在设计对应代码结构时，直截了当的思路是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    Model model; <span class="comment">// 树的模型</span></span><br><span class="line">    Texture texture; <span class="comment">// 树的贴图</span></span><br><span class="line">    <span class="type">int</span> x,y,z; <span class="comment">// 树的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在使用享元模式进行重新设计后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的资产结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    Model model; <span class="comment">// 树的模型</span></span><br><span class="line">    Texture texture; <span class="comment">// 树的贴图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 树结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeAsset* asset; <span class="comment">// 资产指针</span></span><br><span class="line">    <span class="type">int</span> x,y,x; <span class="comment">// 树的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再重新设计的代码中，我们把绘制一棵树所需的数据里面最庞大的部分挑出来。1000个Tree对象中模型和贴图均使用<strong>同一个</strong><code>TreeAsset</code>对象中的数据，这样就可以节省大量的内存空间。</p>
<p>回看我们的代码，这时我们可以看到：在<code>Animation</code>的设计中，每一个<code>Animation</code>对象都拥有自己的动画帧列表；而在<code>Enemy</code>类中，每一个敌人，都拥有两个<code>Animation</code>对象，这就意味着我们在游戏中每次随机刷新一个野猪，都会从磁盘中加载两套动画的图片到内存中，虽然我们所使用的图片不如3D模型那般恐怖，并不会导致严重的内存爆满问题，但是从磁盘上读取数据的这个I&#x2F;O操作本身就是十分耗时的工作，尤其是在一些机械硬盘上磁盘速度较慢的情况时，刷新敌人的时候便会有明显的卡顿感。在主循环中动态的从磁盘中加载数据，这本身也违背了我们之前认识到的：“主循环中应尽量避免耗时过长的任务”这一设计准则。<strong>加载数据</strong>的工作应该放置到我们游戏框架中<strong>初始化</strong>的部分去做。毕竟从游戏体验角度，对玩家来说，比起在游戏过程中出现卡帧和掉帧等情况，更愿接受在加载时稍微多等一会儿。</p>
<p>所以这里我们要对<code>Animation</code>类进行重新的拆分和设计。我们思考一下：游戏画面中的野猪们在动画方面可以共享的元素有哪些呢？</p>
<p>那当然是<code>IMAGE</code>对象构成的<code>vector</code>了；而动画当前正在播放第几帧等状态信息就各异了，所以就不能放在共享的数据里面。</p>
<p>因此，我们重新定义<code>Atlas</code>类来表示动画所使用的“图集”，其所需的成员变量，构造和析构函数都是从<code>Animation</code>中“拆分”下来的。而在整个游戏中，我们只需要用四个共用的<code>Atlas</code>对象，也就是玩家和敌人分别向左和向右的动画。我们将它们的指针定义为全局变量，稍后进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Atlas</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Atlas</span>(LPCTSTR path, <span class="type">int</span> num)</span><br><span class="line">	&#123;</span><br><span class="line">		TCHAR path_file[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			_stprintf_s(path_file, path, i);</span><br><span class="line"></span><br><span class="line">			IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">			<span class="built_in">loadimage</span>(frame, path_file);</span><br><span class="line">			frame_list.<span class="built_in">push_back</span>(frame);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Atlas</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; frame_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">			<span class="keyword">delete</span> frame_list[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	std::vector&lt;IMAGE*&gt; frame_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而将图片序列拆分出去的<code>Animation</code>类，就需要持有<code>ATlas</code>类对象的指针了，在初始化时，将它保存在成员变量中。</p>
<p>这里需要<strong>注意</strong>：由于<code>Atlas</code>是<code>Animation</code>之间共享的<strong>公共资产</strong>，所以千万不能在<code>Animation</code>的析构函数中使用<code>delete</code>将<code>Atlas</code>指针释放掉，<code>Atlas</code>的生命周期应由更上一层的代码进行控制。</p>
<p>这样敌人刷新时可能的卡顿就一去不复返了。这里蒟蒻注意到在每个对象中阴影图片的绘制也是都要读取、再加载渲染。可以试着用类似的思想实现一下。</p>
<h4 id="3-4-3-用户界面"><a href="#3-4-3-用户界面" class="headerlink" title="3.4.3 用户界面"></a>3.4.3 用户界面</h4><p>众所周知，<code>EasyX</code>作为2D图形库，它与GUI库是有区别的。我们可以十分便利的调用函数绘制点线面各种图形。但是想要在窗口中实现一个带有交互效果的按钮，这就需要我们自己实现了。</p>
<p>Qt作为GUI程序开发框架的定位，决定了它必然会屏蔽太多底层设计。例如我们在目前程序中所使用的“主循环”，这些封装和屏蔽从工程角度讲是再合适不过的，但是我们在探索游戏开发的初期也就是以学习为目的进行实践的过程中，我们更希望有一个功能简单直接容易上手的图形库来让我们选取，而不是直接使用GUI库。当然，在游戏开发中，Qt这些有着明确定位的GUI框架一般也不会直接参与到游戏程序本身的制作中，而是作为游戏开发工具链上的一环。想要在游戏这种即时渲染的框架中渲染更具有通用性的GUI，<code>imGUI</code>等技术是在合适不过的了。那么想要实现GUI组件，在现有程序中该如何编写呢？</p>
<p>这里，有一句<strong>GUI设计哲学</strong>“<u>一个按钮之所以是一个按钮，不是因为它长得像一个按钮，而是因为它能够对交互事件做出响应</u>”。无论是文本还是图片，如果能够对玩家的点击事件进行捕获，并修改对应的数据进行响应，那么它就是一个按钮。</p>
<p>这里我们每个按钮提供了3张图片，分别对应了按钮的<code>iale</code>、<code>hovered</code>、<code>push</code>形态。</p>
<p>现在回到代码，来考虑<strong>按钮类</strong>该如何设计。</p>
<p>按钮必然需要一个RECT变量来描述自己的位置和大小，这在判断鼠标响应时是必须的。然后是3张<code>IMAGE</code>图片变量。最后我们还应定义按钮当前的状态枚举变量。，这是因为按钮的悬停、按下等状态实在消息处理时进行判断的 ，而在主循环的每一帧画面渲染时，我们都需要根据现有状态选择对应图片进行绘制。</p>
<p>然后就是内部成员函数的编写，绘制函数、事件处理函数。注意在开始编写之前一定要理清代码逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Button</span>(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_hovered, LPCTSTR path_img_pushed)</span><br><span class="line">	&#123;</span><br><span class="line">		region = rect;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_idle, path_img_idle);</span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_hovered, path_img_hovered);</span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_pushed, path_img_pushed);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ProccessEvent</span><span class="params">(<span class="type">const</span> ExMessage&amp; msg)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (msg.message)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line">			<span class="keyword">if</span> (status == Status::Idle &amp;&amp; <span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">				status = Status::Hovered;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (status == Status::Hovered &amp;&amp; !<span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">				status = Status::Idle;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">				status = Status::Pushed;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line">			<span class="keyword">if</span> (status == Status::Pushed)</span><br><span class="line">				<span class="built_in">OnClick</span>();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (status)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> Status::Idle:</span><br><span class="line">			<span class="built_in">putimage</span>(region.left, region.top, &amp;img_idle);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Status::Hovered:</span><br><span class="line">			<span class="built_in">putimage</span>(region.left, region.top, &amp;img_hovered);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Status::Pushed:</span><br><span class="line">			<span class="built_in">putimage</span>(region.left, region.top, &amp;img_pushed);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">Status</span></span><br><span class="line">	&#123;</span><br><span class="line">		Idle = <span class="number">0</span>,</span><br><span class="line">		Hovered,</span><br><span class="line">		Pushed</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	RECT region;</span><br><span class="line">	IMAGE img_idle;</span><br><span class="line">	IMAGE img_hovered;</span><br><span class="line">	IMAGE img_pushed;</span><br><span class="line">	Status status = Status::Idle;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 检测鼠标点击</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">CheckCursoHit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &gt;= region.left &amp;&amp; x &lt;= region.right &amp;&amp; y &gt;= region.top &amp;&amp; y &lt;= region.bottom;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来，便可以此为基类编写特殊按钮类了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuitGameButton</span> :<span class="keyword">public</span> Button</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">QuitGameButton</span>(RECT rect,LPCTSTR path_img_idle, LPCTSTR path_img_howered, LPCTSTR path_img_pushed)</span><br><span class="line">		:<span class="built_in">Button</span>(rect,path_img_idle,path_img_howered,path_img_pushed)&#123;&#125;</span><br><span class="line">	~<span class="built_in">QuitGameButton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		running = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StartGameButton</span> :<span class="keyword">public</span> Button</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StartGameButton</span>(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_howered, LPCTSTR path_img_pushed)</span><br><span class="line">		:<span class="built_in">Button</span>(rect, path_img_idle, path_img_howered, path_img_pushed) &#123;&#125;</span><br><span class="line">	~<span class="built_in">StartGameButton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		is_game_started = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">mciSendString</span>(_T(<span class="string">&quot;play bgm repeat from 0&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意我们在这里，将主循环的播放音乐移了过来。</p>
<p>另外还设置了2个全局变量<code>running</code>和<code>is_game_start</code>。</p>
<p>再对主函数内代码稍加修改，此次的项目就竣工了。</p>
<p>当然，这只是游戏基本操作的实现，还可以加入其他东西。</p>
<p>请前往B站up**<a target="_blank" rel="noopener" href="https://space.bilibili.com/25864506">Voidmatrix</a>**那里进一步学习。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Re0:提瓦特幸存者</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.chaos-ljc.top/2024/10/22/Rouguelike-%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/">https://www.chaos-ljc.top/2024/10/22/Rouguelike-提瓦特幸存者/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Chaos</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-10-22</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-10-22</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">c++游戏开发</a></div><div class="post-share"><div class="social-share" data-image="/assets/images/cover_18.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/10/22/%E5%B9%BF%E4%B9%89%E7%99%BE%E5%90%88%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/" title="广义百合定义的一次尝试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">广义百合定义的一次尝试</div></div><div class="info-2"><div class="info-item-1">【翻译】广义百合定义的一次尝试当前，“百合”这一概念被广泛用于描述女性之间的多种关系，常引发“什么算是百合？”或“这部作品算不算百合？”的争论。本文试图通过分类，促使人们从“这是否是百合？”的讨论转向“我喜欢哪种百合？”的探索。 百合的模糊性使其涵盖了不同风格的作品，推动了这一类型的广泛流行。然而，过于细化的分类可能会导致创作和市场的分散，影响百合文化的传播。对于新粉丝或未深入了解的人，百合的模糊定义容易引发困惑，并可能被“○○不是百合”的声音所影响。因此，建立一个涵盖性的定义和分类是有意义的。 我们尝试将“百合”定义为“女性之间某种特殊关系以及描写这种关系的作品或类型”。通过分析这些关系的情感和行为，我们可以将百合分为三大类：“浪漫与性吸引”、“情感依附或情感超越”、“情感纽带或亲情”。以下是这三类的详细说明：  1. 浪漫与性吸引这一类描绘女性之间的恋爱或性关系。无论是明确表达的恋情，还是虽未明说但明显可解读为恋爱的作品，都属于此类。 1-1. 逃避与代偿描绘在社会压力下（如被迫订婚或相亲）女性为逃避异性恋期待而选择同性恋爱，暂时或永久地沉浸其中。 1-2....</div></div></div></a><a class="pagination-related" href="/2024/10/22/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%80%83%E8%AF%95/" title="学习与考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_07.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">学习与考试</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Chaos</div><div class="author-info-description">人世几回伤往事,山形依旧枕寒流</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lvjianchaos"><i class="fab fa-github"></i><span>🛴前往小屋...</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lvjianchaos" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:chaosljc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Chaos的博客!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Re0-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84C-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91"><span class="toc-text">Re0:从零开始的C++游戏开发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E6%9C%AC%E7%AC%94%E8%AE%B0%E6%98%AFChaos%E8%A7%82%E7%9C%8BB%E7%AB%99upVoidmatrix%E7%9A%84%E8%AF%BE%E7%A8%8B%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%EF%BC%9B%E6%89%80%E7%94%A8%E4%B8%BA%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E7%9A%84easyx%E5%9B%BE%E5%BD%A2%E5%BA%93%E3%80%82"><span class="toc-text">前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%9B%86-%E8%BF%BD%E9%BC%A0%E6%A0%87%E3%81%AE%E5%B0%8F%E7%90%83"><span class="toc-text">第一集 追鼠标の小球</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-text">绘图坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">渲染缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6"><span class="toc-text">游戏框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">*主循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%9B%86-%E8%BF%9B%E5%87%BB%E3%81%AE%E4%BA%95%E5%AD%97%E6%A3%8B"><span class="toc-text">第二集 进击の井字棋</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-text">三大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">读取操作：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-text">数据处理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%94%BB%E9%9D%A2"><span class="toc-text">绘制画面</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%8B%E7%9B%98%EF%BC%9A"><span class="toc-text">棋盘：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">游戏结束条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-text">代码编写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%9B%86-%E6%8F%90%E7%93%A6%E7%89%B9%E3%81%AE%E5%B9%B8%E5%AD%98%E8%80%85"><span class="toc-text">第三集 提瓦特の幸存者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%A8%8B%E5%BA%8F%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8"><span class="toc-text">3.1 程序动画实现及角色移动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.1.1 动画实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8"><span class="toc-text">3.1.2 角色移动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%8C%E4%BA%BA%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%92%8C%E7%B4%A2%E6%95%8C%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 敌人随机生成和索敌逻辑实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%8A%A8%E7%94%BB%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2.1 动画类实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="toc-text">3.2.2 角色移动优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E7%8E%A9%E5%AE%B6%E7%B1%BB%E5%92%8C%E6%95%8C%E4%BA%BA%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2.3 玩家类和敌人类实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2D%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E5%92%8C%E9%9F%B3%E6%95%88%E6%92%AD%E6%8E%A7"><span class="toc-text">3.3 2D碰撞检测和音效播控</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%AD%90%E5%BC%B9%E7%A2%B0%E6%92%9E%E9%80%BB%E8%BE%91"><span class="toc-text">3.3.1 子弹碰撞逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%9F%B3%E6%95%88%E9%9F%B3%E4%B9%90%E6%92%AD%E6%8E%A7"><span class="toc-text">3.3.2 音效音乐播控</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="toc-text">3.4 用户界面实现和设计模式基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%AF%BC%E8%A8%80"><span class="toc-text">3.4.1 导言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.4.2 享元模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-text">3.4.3 用户界面</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E5%AD%90%E9%9D%9E%E9%B1%BC%EF%BC%8C%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B9%8B%E4%B9%90/" title="子非鱼，安知鱼之乐"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="子非鱼，安知鱼之乐"/></a><div class="content"><a class="title" href="/2024/10/22/%E5%AD%90%E9%9D%9E%E9%B1%BC%EF%BC%8C%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B9%8B%E4%B9%90/" title="子非鱼，安知鱼之乐">子非鱼，安知鱼之乐</a><time datetime="2024-10-22T10:06:49.387Z" title="发表于 2024-10-22 18:06:49">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E8%AE%B0/" title="C语言学习随记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言学习随记"/></a><div class="content"><a class="title" href="/2024/10/22/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E8%AE%B0/" title="C语言学习随记">C语言学习随记</a><time datetime="2024-10-22T10:05:44.756Z" title="发表于 2024-10-22 18:05:44">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="关于刷题日志的说明"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_14.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于刷题日志的说明"/></a><div class="content"><a class="title" href="/2024/10/22/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="关于刷题日志的说明">关于刷题日志的说明</a><time datetime="2024-10-22T10:04:20.808Z" title="发表于 2024-10-22 18:04:20">2024-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Chaos</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/music/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.2.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/笔记/&quot;);" href="javascript:void(0);">笔记</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">芜杂的心绪</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题日志/&quot;);" href="javascript:void(0);">刷题日志</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">回望与长眠</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文字/&quot;);" href="javascript:void(0);">文字</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">那些忧伤</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/22/刷题日志/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/images/cover_14.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/22/刷题日志/&quot;);" href="javascript:void(0);" alt="">关于刷题日志的说明</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/22/刷题日志/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/22/变量名命名的艺术/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/images/cover_17.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/22/变量名命名的艺术/&quot;);" href="javascript:void(0);" alt="">变量名命名的艺术</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/22/变量名命名的艺术/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/22/盛夏、死蝉与逝去的朋友/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/assets/images/cover_10.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/22/盛夏、死蝉与逝去的朋友/&quot;);" href="javascript:void(0);" alt="">盛夏，死蝉与逝去的朋友</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/22/盛夏、死蝉与逝去的朋友/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1000ms');
    arr[i].setAttribute('data-wow-delay', '100ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>