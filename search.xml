<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>盛夏，死蝉与逝去的朋友</title>
      <link href="/2025/02/19/%E7%9B%9B%E5%A4%8F%E3%80%81%E6%AD%BB%E8%9D%89%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E6%9C%8B%E5%8F%8B%20(%E6%94%B9)/"/>
      <url>/2025/02/19/%E7%9B%9B%E5%A4%8F%E3%80%81%E6%AD%BB%E8%9D%89%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E6%9C%8B%E5%8F%8B%20(%E6%94%B9)/</url>
      
        <content type="html"><![CDATA[<h2 id="盛夏的死蝉"><a href="#盛夏的死蝉" class="headerlink" title="盛夏的死蝉"></a>盛夏的死蝉</h2><h2 id="盛夏、死蝉与逝去的朋友"><a href="#盛夏、死蝉与逝去的朋友" class="headerlink" title="盛夏、死蝉与逝去的朋友"></a><strong>盛夏、死蝉与逝去的朋友</strong></h2><h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><p>​蝉鸣划破玻璃窗，声音如切割的裂纹，既不属于固体，也不属于流体。它是一种介于树脂与电波之间的存在，粘稠地裹挟着破碎的回忆。搬家工人第八次撞击门框时，某根被空调冷气冻僵的神经突然震颤——墙角，埋藏着已蒙尘的笔记本，封皮上，2008年梅雨季的霉斑依稀可见。</p><p>​指尖轻掠泛黄的纸页，家乡学校后的新代桥却忽然在视网膜上显现。不再是此刻深圳的廉价公寓，而是十六岁那年生物教室里，满溢的福尔马林气味。吕游的白衬衫总带着水族箱藻类的腥甜味，他把解剖剪刺入蝉的腹节时，睫毛在夏末的光晕中抖落了细碎的金粉。</p><p>​“节间膜，要完整剥离。”他的声音，透着昆虫标本般的透明感。我们并排跪在社团活动室的地板上，拾起那些被同学踩碎的蝉尸。窗外的合欢树，散发着最后的绒花，粉色的雪片在他肩胛骨上停驻，像是永远飞不起来的残翅。</p><h3 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h3><p>​空调压缩机发出垂死的嗡鸣。此刻，凝结在2023年的尘埃，与十五年前解剖刀上微弱的光反射产生了量子纠缠。读到“吕游死了”那行稚嫩的笔迹时，鼻腔内竟涌上一股腥腥的凉意——这不是文字，而是2008年九月十七日黄昏，警用探照灯在河面上划出的那道惨白伤痕。</p><p>​记忆的菌丝开始蔓延：他的橡皮擦总被削成十二面体，生物课本第三十七页夹着风干的蜉蝣翅脉，还有葬礼那天停在他母亲发髻上的蓝蜻蜓（那抹幽蓝，至今仍在视网膜背面闪烁）。穿黑袈裟的僧侣摇动法铃时，蝉群突然噤声，仿佛整个宇宙的振动都坍缩进桐木骨灰盒的缝隙。</p><h3 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h3><p>​搬运工踩过地板的吱呀声，撕开了记忆的茧房。我发现自己正用拇指反复摩挲日记本上某处皱褶——那是被泪水浸泡过的地形图，标记着某个已不复存在的坐标。吕游消失前夜，他留给我的玻璃标本瓶，此刻与纸箱深处的颠簸共振。七百二十只蝉的复眼在黑暗中睁开，折射出我们在时光褶皱里遗落的对话：</p><p>​“知道吗？蝉若虫要在土里蛰伏十七年。” </p><p>​“比我们的年纪还大呢。” </p><p>​“可破土后的成虫，只有七天。” </p><p>​我们笑得像两个偷饮了时光酒的僭越者。</p><h3 id="（四）"><a href="#（四）" class="headerlink" title="（四）"></a>（四）</h3><p>​电梯下降的失重感中，某只垂死的蝉突然在耳膜内振翅。它的鸣叫穿透十五年光阴，与卡车引擎的轰鸣编织成赋格曲。后视镜中，渐远的公寓楼褪色，像浸泡在显影液中的旧相片。当高速公路的风撕开记忆的结痂，我突然听见吕游的声音在时空间隙里低语：</p><p>​“不是十七年，也不是七天。” </p><p>​“我们都在各自的甬道里，等待破土的那一刻。” </p><p>​挡风玻璃上爆开的虫尸，绽放成星云，盛夏正以光年速度向我们袭来。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试探HTTP协议</title>
      <link href="/2024/11/18/HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/11/18/HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="初识HTTP"><a href="#初识HTTP" class="headerlink" title="初识HTTP"></a>初识HTTP</h2><p><strong>Before Reading</strong>  :  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">An overview of HTTP</a>  </p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Q: 从浏览器的地址栏输入URL()按下回车到页面展示出来,发生了什么?<br>A: 简而言之,包括 &#x3D;&#x3D;URL 解析、DNS 解析、TCP 连接建立、HTTP 请求发送、服务器处理请求、<strong>HTTP 响应发送</strong>、浏览器接收响应、浏览器渲染页面、加载资源和 JavaScript 执行&#x3D;&#x3D;。其中每个步骤又包含多个子步骤和复杂的处理逻辑.</p><p>先回想一下<strong>TCP&#x2F;IP 协议栈</strong>(<strong>应用层</strong>;<strong>传输层</strong>;<strong>网络层</strong>;<strong>网络接口层</strong>),在这里,我们呢主要关注最上层的应用层中HTTP相关内容.</p><h3 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网上应用最广泛的一种网络协议。它是客户端和服务器之间进行通信的基础协议，用于传输超文本（如 HTML 文档）和其他资源（如图像、视频、JSON 数据等）。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p><strong>超文本传输协议</strong>：HTTP 是一种应用层协议，用于在客户端和服务器之间传输超文本（如 HTML 文档）和其他资源。</p></li><li><p><strong>基于 TCP 协议</strong>：HTTP 建立在 TCP&#x2F;IP 协议栈之上，使用 TCP 协议进行数据传输。默认情况下，HTTP 使用 80 端口，HTTPS 使用 443 端口。</p></li><li><p><strong>请求-响应模型</strong>：HTTP 采用请求-响应模型，客户端发送 HTTP 请求，服务器返回 HTTP 响应。</p></li><li><p><strong>简单可扩展</strong>：HTTP 协议设计简单，易于实现和扩展。它支持多种请求方法（如 GET、POST、PUT、DELETE 等）和头部字段，可以根据需要进行扩展。</p></li><li><p><strong>无状态</strong>：HTTP 协议是无状态的，即服务器不会保存客户端的请求状态。每个请求都是独立的，服务器不会记住之前的请求。</p></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><h5 id="1-请求-响应模型"><a href="#1-请求-响应模型" class="headerlink" title="1. 请求-响应模型"></a>1. 请求-响应模型</h5><p>HTTP 采用请求-响应模型，客户端发送 HTTP 请求，服务器返回 HTTP 响应。请求和响应都包含以下几个部分：</p><ul><li><p><strong>请求行&#x2F;状态行</strong>：包含请求方法（如 GET、POST）、请求路径（如 <code>/index.html</code>）和 HTTP 协议版本（如 HTTP&#x2F;1.1）。</p></li><li><p><strong>请求头&#x2F;响应头</strong>：包含各种头部字段，如 <code>User-Agent</code>、<code>Accept</code>、<code>Content-Type</code>、<code>Content-Length</code> 等。</p></li><li><p><strong>请求体&#x2F;响应体</strong>：包含请求或响应的数据，通常是 HTML、JSON、XML 等格式的数据。</p></li></ul><h5 id="2-简单可扩展"><a href="#2-简单可扩展" class="headerlink" title="2. 简单可扩展"></a>2. 简单可扩展</h5><p>HTTP 协议设计简单，易于实现和扩展。它支持多种请求方法（如 GET、POST、PUT、DELETE 等）和头部字段，可以根据需要进行扩展。例如：</p><ul><li><p><strong>请求方法</strong>：HTTP 定义了多种请求方法，如 GET（获取资源）、POST（提交数据）、PUT（更新资源）、DELETE（删除资源）等。</p></li><li><p><strong>头部字段</strong>：HTTP 支持多种头部字段，如 <code>User-Agent</code>（客户端标识）、<code>Accept</code>（客户端接受的媒体类型）、<code>Content-Type</code>（请求或响应的数据类型）等。</p></li></ul><h5 id="3-无状态"><a href="#3-无状态" class="headerlink" title="3. 无状态"></a>3. 无状态</h5><p>HTTP 协议是无状态的，即服务器不会保存客户端的请求状态。<strong>每个请求都是独立的，服务器不会记住之前的请求</strong>。这种设计简化了服务器的设计和实现，但也带来了一些问题，如需要通过其他方式（如 Cookie、Session）来维护客户端状态。</p><h5 id="4-基于-TCP-协议"><a href="#4-基于-TCP-协议" class="headerlink" title="4. 基于 TCP 协议"></a>4. 基于 TCP 协议</h5><p>HTTP 建立在 TCP&#x2F;IP 协议栈之上，使用 TCP 协议进行数据传输。TCP 协议提供了可靠的、面向连接的通信服务，确保数据在网络中的可靠传输。</p><h5 id="5-支持多种资源类型"><a href="#5-支持多种资源类型" class="headerlink" title="5. 支持多种资源类型"></a>5. 支持多种资源类型</h5><p>HTTP 不仅用于传输超文本（如 HTML 文档），还支持传输多种资源类型，如图像、视频、音频、JSON 数据、XML 数据等。通过 <code>Content-Type</code> 头部字段，服务器可以指定响应数据的类型，客户端可以根据类型进行处理。</p><h3 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h3><h4 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h4><h5 id="HTTP-0-9-1991-The-One-Liner"><a href="#HTTP-0-9-1991-The-One-Liner" class="headerlink" title="HTTP&#x2F;0.9 (1991) - The One Liner"></a>HTTP&#x2F;0.9 (1991) - The One Liner</h5><ul><li><p><strong>特点</strong>：</p><ul><li><p>最早的 HTTP 版本，非常简单。</p></li><li><p>只支持 GET 请求方法。</p></li><li><p>没有请求头和响应头，只有请求行和响应体。</p></li><li><p>响应体只能是 HTML 文档。</p></li></ul></li></ul><ul><li><strong>示例</strong>:</li></ul><ul><li>请求</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html</span><br></pre></td></tr></table></figure><ul><li>响应</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(response body)</span><br><span class="line">(connection closed)</span><br></pre></td></tr></table></figure><h5 id="HTTP-1-0（1996）"><a href="#HTTP-1-0（1996）" class="headerlink" title="HTTP&#x2F;1.0（1996）"></a>HTTP&#x2F;1.0（1996）</h5><ul><li><p><strong>特点</strong>：</p><ul><li><p>引入了请求头和响应头，支持多种请求方法（如 GET、<strong>POST、HEAD</strong>）</p></li><li><p>添加了<strong>状态码(Status code)</strong> 以标识响应</p></li><li><p>支持多种资源类型（如 HTML、<strong>图像、视频、纯文本等</strong>）。</p></li><li><p>每个请求都需要建立一个新的 TCP 连接，请求完成后立即关闭连接。</p></li><li><p>引入了字符集支持, 包括多部分类型、授权、缓存、内容编码等</p></li></ul></li><li><p><strong>示例</strong>:</p></li><li><p>请求<br>  如下所示: </p><ul><li>除了请求,</li><li>客户端还发送了它的个人信息, </li><li>要求的响应类型</li><li>等等等等<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>cs.fyi</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure></li></ul></li><li><p>响应<br>  如下所示: </p><ul><li>响应的开头是吧友版本号的HTTP,接着一个状态码和一个描述它的词或原因<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="language-clojure">(<span class="name">response</span> body)</span></span><br><span class="line"><span class="language-clojure">(<span class="name">connection</span> closed)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>在这一版本,请求和响应仍然保持着ASCII编码, 但是响应体课包含图片,视频,纯文本和其他内容类型, 比起”Hyper Text”, HMTP(Hypermedia transfer protocol)或许是更恰切的描述,不过…</p><p>HTTP&#x2F;1.0的一个<strong>主要缺点</strong>是不能为每此连接提供多个请求。也就是说，无论何时客户机需要从服务器获得什么东西，它都必须打开一个新的 TCP 连接，在这个单个请求完成之后，连接将被关闭。对于任何下一个需求，它必须在一个新的连接上。<br>So,Why is it <strong>BAD</strong>?<br>让我们假设您访问了一个包含10个图像、5个样式表和5个 javascript 文件的网页，当请求该网页时，总共需要获取20个项目。由于服务器在请求完成后立即关闭连接，因此将有一系列20个独立的连接，其中每个项目将在其各自的连接上逐个提供服务。这种大量的连接会导致严重的性能损失，因为需要一个新的 TCP 连接会造成严重的性能损失，这是由于<strong>三路握手</strong>后缓慢启动造成的</p><h6 id="Three-way-Handshake"><a href="#Three-way-Handshake" class="headerlink" title="Three-way Handshake"></a>Three-way Handshake</h6><ol><li><p><strong>客户端发送 SYN 包</strong>：客户端向服务器发送一个 SYN（同步）包(由 客户机拾取一个随机数假设为<code>x</code> 组成)，请求建立连接。</p></li><li><p><strong>服务器发送 SYN-ACK 包</strong>：服务器收到 SYN 包后，向客户端发送一个 SYN-ACK（同步-确认）包(由 服务器拾取的 <code>y</code> 和数字 <code>x+1</code>，其中 <code>x</code> 是客户端发送的数字 组成)，表示同意建立连接。</p></li><li><p><strong>客户端发送 ACK 包</strong>：客户端收到 SYN-ACK 包后，向服务器发送一个 ACK（确认）包(由 <code>y+1</code> 组成)，表示连接已建立。</p></li></ol><p>三次握手完成后，客户端和服务器之间的数据共享就可以开始了。值得注意的是，客户端可以在调度最后一个 ACK 数据包后立即开始发送应用程序数据，但服务器仍然必须等待收到 ACK 数据包才能完成请求。</p><p>当然, 严重的性能损耗, 不仅仅是由于 TCP 连接的建立过程（三次握手）造成的，还包括 TCP 连接的关闭、连接的重复建立和关闭、并发请求的限制以及缺乏缓存机制等因素。</p><h5 id="HTTP-1-1（1997）"><a href="#HTTP-1-1（1997）" class="headerlink" title="HTTP&#x2F;1.1（1997）"></a>HTTP&#x2F;1.1（1997）</h5><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>引入了持久连接（Keep-Alive）</strong>，允许多个请求和响应复用同一个 TCP 连接，减少了连接建立和关闭的开销。要关闭连接，请求上必须有标题 Connection: close。客户端通常在最后一个请求中发送此标头以安全地关闭连接。</p></li><li><p><strong>支持管道化（Pipelining）</strong>，允许客户端在一个 TCP 连接上发送多个请求，服务器按顺序返回响应。那么,客户机如何知道这是第一个响应下载完成和下一个响应的内容开始的地方? 要解决这个问题，必须有 Content-Length 头，客户端可以使用它来确定响应的结束位置，并且可以开始等待下一个响应。</p><blockquote><p>It should be noted that in order to benefit from persistent connections or pipelining, Content-Length header must be available on the response, because this would let the client know when the transmission completes and it can send the next request (in normal sequential way of sending requests) or start waiting for the the next response (when pipelining is enabled).</p><p>But there was still an issue with this approach. And that is, what if the data is dynamic and server cannot find the content length before hand? Well in that case, you really can’t benefit from persistent connections, could you?! In order to solve this HTTP&#x2F;1.1 introduced chunked encoding. In such cases server may omit content-Length in favor of chunked encoding (more to it in a moment). However, if none of them are available, then the connection must be closed at the end of request.</p></blockquote></li></ul><ul><li><strong>分块传输(Chunked Transfers)</strong> ,  在动态内容的情况下，当服务器在传输开始时无法真正找到 Content-Length 时，它可能会开始分块发送内容（逐块），并在发送时为每个块添加 Content-Length。当所有 chunk 都发送完毕时，即整个传输已完成，它会发送一个空 chunk，即 Content-Length 设置为零的 chunk，以识别传输已完成的客户端。为了通知客户端有关分块传输的信息，服务器包含标头 Transfer-Encoding： chunked</li></ul><ul><li><p>引入了缓存机制（如 <code>Cache-Control</code>、<code>ETag</code>），提高了性能。</p></li><li><p>支持虚拟主机（Virtual Hosts），允许多个域名共享同一个 IP 地址。</p></li><li><p>引入了更多的请求方法（如 PUT、DELETE、OPTIONS、PATCH）和状态码。</p></li><li><p>客户端 Cookie</p></li><li><p>增强的压缩支持</p></li><li><p>……</p></li></ul></li></ul><h5 id="HTTP-2（2015）"><a href="#HTTP-2（2015）" class="headerlink" title="HTTP&#x2F;2（2015）"></a>HTTP&#x2F;2（2015）</h5><ul><li><p><strong>特点</strong>：</p><ul><li><p>基于 Google 的 SPDY 协议，改进了性能和安全性。</p></li><li><p>引入了<strong>多路复用（Multiplexing）</strong>，允许多个请求和响应在同一个 TCP 连接上并行传输，解决了 HTTP&#x2F;1.1 的队头阻塞问题, 即客户端不必等待需要时间的请求，而其他请求仍将得到处理。</p></li><li><p>引入了<strong>头部压缩（Header Compression）</strong>，减少了传输的数据量。<br>  它的本质是，当我们不断从同一个客户端访问服务器时，我们会一遍又一遍地在标头中发送大量冗余数据，有时可能会有 cookie 增加标头大小，从而导致带宽使用和延迟增加</p><p>  与请求和响应不同，标头不是以 gzip 或 compress 等格式压缩的，但有一种不同的标头压缩机制，即使用霍夫曼代码对文本值进行编码，并且标头表由客户端和服务器维护，客户端和服务器在后续请求中省略任何重复的标头（例如用户代理等），并使用由两者维护的标头表引用它们。</p><p>  补充: 当我们谈论 Headers 时，Headers 仍然与 HTTP&#x2F;1.1 中相同，除了添加了一些伪 Headers，即 <code>：method</code>、<code>：scheme</code>、<code>：host</code> 和 <code>:p ath</code></p></li><li><p>支持<strong>服务器推送（Server Push）</strong>，服务器可以在客户端请求之前主动推送资源，减少了客户端的等待时间。<br>  例如，假设浏览器加载了一个网页，它会解析整个页面以找出它必须从服务器加载的远程内容，然后向服务器发送后续请求以获取该内容</p><p>  服务器推送允许服务器通过推送它知道客户端将需要的数据来减少往返。它是如何完成的呢? 服务器发送一个名为 PUSH_PROMISE 的特殊帧通知客户端，“嘿，我即将将此资源发送给您！不要向我要。” PUSH_PROMISE 帧与导致推送发生的流相关联，并且它包含承诺的流 ID，即服务器将发送要推送的资源的流。</p></li><li><p>使用<strong>二进制帧（Binary Framing）</strong> 代替了文本格式，提高了解析效率。<br>  作为二进制协议，它更容易解析，但与 HTTP&#x2F;1.x 不同的是，它不再能被人眼读取。HTTP&#x2F;2 的主要构建块是帧和流</p><p>  HTTP 消息现在由一个或多个帧组成。元数据有一个 HEADERS 帧，有效负载有一个  DATA 帧，并且存在几种其他类型的帧（HEADERS、DATA、RST_STREAM、SETTINGS、PRIORITY 等），您可以通过 <a href="https://http2.github.io/http2-spec/#FrameTypes">HTTP&#x2F;2 规范</a>进行检查。</p><p>  每个 HTTP&#x2F;2 请求和响应都有一个唯一的流 ID，并被划分为帧。帧只不过是二进制数据片段。帧的集合称为 Stream。每个帧都有一个 stream id，用于标识它所属的流，并且每个帧都有一个通用的标头。此外，除了 stream ID 唯一之外，值得一提的是，客户端发起的任何请求都使用奇数，而来自服务器的响应具有偶数 stream ID。</p><p>  除了 HEADERS 和 DATA 之外，这里值得一提的另一个帧类型是 RST_STREAM。这是一种特殊的帧类型，用于中止某些流，即客户端可以发送此帧以让服务器知道我不再需要此流。在 HTTP&#x2F;1.1 中，让服务器停止向客户端发送响应的唯一方法是关闭连接，这会导致延迟增加，因为必须为任何连续请求打开新连接。在 HTTP&#x2F;2 中，客户端可以使用 RST_STREAM 并停止接收特定流，而连接仍将打开，而其他流仍将处于活动状态。</p></li><li><p><strong>请求优先级(Request Prioritization)</strong></p><p>  客户端可以通过在打开流的 HEADERS 帧中包含优先级信息来为流分配优先级。在任何其他时间，客户端都可以发送 PRIORITY 帧来更改流的优先级。</p><p>  在没有任何优先级信息的情况下，server 异步处理请求，即没有任何顺序。如果为流分配了优先级，则根据此优先级信息，server 决定需要提供多少资源来处理哪个请求。</p></li></ul></li><li><p><strong>示例</strong>：</p><ul><li>HTTP&#x2F;2 使用二进制帧传输数据，无法直接查看文本格式。</li></ul></li></ul><h5 id="HTTP-3（2020）"><a href="#HTTP-3（2020）" class="headerlink" title="HTTP&#x2F;3（2020）"></a>HTTP&#x2F;3（2020）</h5><ul><li><p><strong>特点</strong>：</p><ul><li><p>基于 Google 的 QUIC 协议，改进了性能和安全性。</p></li><li><p>使用 UDP 协议代替 TCP 协议，减少了连接建立和拥塞控制的开销。</p></li><li><p>引入了多路复用（Multiplexing），允许多个请求和响应在同一个 UDP 连接上并行传输，解决了 TCP 的队头阻塞问题。</p></li><li><p>引入了头部压缩（QPACK），减少了传输的数据量。</p></li><li><p>支持 0-RTT（Zero Round Trip Time）连接建立，减少了连接建立的时间。</p></li><li><p>使用 TLS 1.3 进行加密，提高了安全性。</p></li></ul></li><li><p><strong>示例</strong>：</p><ul><li>HTTP&#x2F;3 使用 QUIC 协议传输数据，无法直接查看文本格式。</li></ul></li></ul><h6 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h6><ul><li><p><strong>HTTP&#x2F;0.9</strong>：最早的版本，非常简单，只支持 GET 请求。</p></li><li><p><strong>HTTP&#x2F;1.0</strong>：引入了请求头和响应头，支持多种请求方法和资源类型。</p></li><li><p><strong>HTTP&#x2F;1.1</strong>：引入了持久连接、管道化、缓存机制、虚拟主机等，提高了性能和功能。</p></li><li><p><strong>HTTP&#x2F;2</strong>：基于 SPDY 协议，引入了多路复用、头部压缩、服务器推送等，进一步提高了性能。</p></li><li><p><strong>HTTP&#x2F;3</strong>：基于 QUIC 协议，使用 UDP 代替 TCP，引入了多路复用、头部压缩、0-RTT 连接建立等，进一步提高了性能和安全性。</p></li></ul><h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><p>以 &#x3D;&#x3D;HTTP&#x2F;1.1&#x3D;&#x3D; 为例<br><img src="/../assets/imgs_of_articles/HTTP/HTTP_1.1.png" alt="HTTP/1.1"></p><h5 id="请求方法-Method"><a href="#请求方法-Method" class="headerlink" title="请求方法 Method"></a>请求方法 Method</h5><h6 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. GET</h6><ul><li><p><strong>用途</strong>：获取资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于获取数据。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>请求体为空。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="2-POST"><a href="#2-POST" class="headerlink" title="2. POST"></a>2. POST</h6><ul><li><p><strong>用途</strong>：提交数据，通常用于创建资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过请求体传递，通常用于提交表单数据或上传文件。</p></li><li><p>请求不是幂等的，即多次请求可能会改变服务器状态。</p></li><li><p>请求体可以包含数据。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line"><span class="language-ini"><span class="attr">name</span>=John&amp;age=<span class="number">30</span></span></span><br></pre></td></tr></table></figure><h6 id="3-PUT"><a href="#3-PUT" class="headerlink" title="3. PUT"></a>3. PUT</h6><ul><li><p><strong>用途</strong>：更新资源，通常用于替换现有资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过请求体传递，通常用于更新资源。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>请求体可以包含数据。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/user/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;age&quot;: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-DELETE"><a href="#4-DELETE" class="headerlink" title="4. DELETE"></a>4. DELETE</h6><ul><li><p><strong>用途</strong>：删除资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于删除资源。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>请求体为空。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/user/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="5-HEAD"><a href="#5-HEAD" class="headerlink" title="5. HEAD"></a>5. HEAD</h6><ul><li><p><strong>用途</strong>：获取资源的元数据，不返回响应体。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于获取资源的元数据（如响应头）。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>响应体为空。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="6-OPTIONS"><a href="#6-OPTIONS" class="headerlink" title="6. OPTIONS"></a>6. OPTIONS</h6><ul><li><p><strong>用途</strong>：获取服务器支持的请求方法和功能。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于获取服务器支持的请求方法和功能。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>响应体通常包含服务器支持的请求方法和功能。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/user</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="7-PATCH"><a href="#7-PATCH" class="headerlink" title="7. PATCH"></a>7. PATCH</h6><ul><li><p><strong>用途</strong>：部分更新资源。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过请求体传递，通常用于部分更新资源。</p></li><li><p>请求不是幂等的，即多次请求可能会改变服务器状态。</p></li><li><p>请求体可以包含数据。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PATCH</span> <span class="string">/user/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;age&quot;: 31</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="8-CONNECT"><a href="#8-CONNECT" class="headerlink" title="8. CONNECT"></a>8. CONNECT</h6><ul><li><p><strong>用途</strong>：建立隧道，通常用于代理服务器。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于建立隧道。</p></li><li><p>请求不是幂等的，即多次请求可能会改变服务器状态。</p></li><li><p>请求体为空。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">www.example.com:443</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="9-TRACE"><a href="#9-TRACE" class="headerlink" title="9. TRACE"></a>9. TRACE</h6><ul><li><p><strong>用途</strong>：回显请求，用于调试。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>请求参数通过 URL 传递，通常用于调试。</p></li><li><p>请求是幂等的，即多次请求不会改变服务器状态。</p></li><li><p>响应体包含请求的原始数据。</p></li></ul></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRACE</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><h6 id="总结-1"><a href="#总结-1" class="headerlink" title="&#x3D;&#x3D;总结&#x3D;&#x3D;"></a>&#x3D;&#x3D;总结&#x3D;&#x3D;</h6><table><thead><tr><th align="center"><strong>方法</strong></th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><strong>GET</strong></td><td align="center">获取资源</td></tr><tr><td align="center"><strong>POST</strong></td><td align="center">提交数据，通常用于创建资源</td></tr><tr><td align="center"><strong>PUT</strong></td><td align="center">更新资源，通常用于替换现有资源</td></tr><tr><td align="center"><strong>DELETE</strong></td><td align="center">删除资源</td></tr><tr><td align="center"><strong>HEAD</strong></td><td align="center">获取资源的元数据，不返回响应体</td></tr><tr><td align="center"><strong>OPTIONS</strong></td><td align="center">获取服务器支持的请求方法和功能</td></tr><tr><td align="center"><strong>PATCH</strong></td><td align="center">部分更新资源</td></tr><tr><td align="center"><strong>CONNECT</strong></td><td align="center">建立隧道，通常用于代理服务器</td></tr><tr><td align="center"><strong>TRACE</strong></td><td align="center">回显请求，用于调试</td></tr></tbody></table><h6 id="补充"><a href="#补充" class="headerlink" title="补充:"></a><strong>补充:</strong></h6><ul><li>Safe(安全的) : 不会修改服务器的数据的方法<br>  GET HEAD OPTIONS</li><li>Idempotent(幂等的) : 同样的请求被执行一次与连续执行多次的效果是&#x3D;&#x3D;一样&#x3D;&#x3D;的, 服务器的状态也是&#x3D;&#x3D;一样&#x3D;&#x3D;的, 所有的safe方法都是Idempotent的<br>  GET HEAD OPTIONS DELETE</li></ul><h5 id="状态码-Status-Code"><a href="#状态码-Status-Code" class="headerlink" title="状态码 Status Code"></a>状态码 Status Code</h5><table><thead><tr><th align="center">Status Code</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><strong>1xx</strong></td><td align="center">信息性状态码，表示请求已被接收，继续处理</td></tr><tr><td align="center"><strong>2xx</strong></td><td align="center">成功状态码，表示请求已成功处理</td></tr><tr><td align="center"><strong>3xx</strong></td><td align="center">重定向状态码，表示需要进一步操作才能完成请求</td></tr><tr><td align="center"><strong>4xx</strong></td><td align="center">客户端错误状态码，表示客户端请求有误</td></tr><tr><td align="center"><strong>5xx</strong></td><td align="center">服务器错误状态码，表示服务器处理请求时出错</td></tr></tbody></table><h6 id="常见的例子"><a href="#常见的例子" class="headerlink" title="常见的例子:"></a>常见的例子:</h6><ul><li><p><strong>100 Continue</strong>：服务器已接收到请求头，客户端应继续发送请求体</p></li><li><p><strong>200 OK</strong>：请求成功，服务器返回请求的资源</p></li><li><p><strong>301 Moved Permanently</strong>：请求的资源已永久移动到新位置，客户端应使用新的 URL</p></li><li><p><strong>302 Found</strong>：请求的资源临时移动到新位置，客户端应继续使用原 URL</p></li><li><p><strong>401 Unauthorized</strong>：请求需要身份验证，客户端未提供有效的身份验证信息</p></li><li><p><strong>404 Not Found</strong>：请求的资源不存在</p></li><li><p><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求</p></li><li><p><strong>502 Bad Gateway</strong>：服务器作为网关或代理时，从上游服务器收到无效响应</p></li><li><p><strong>504 Gateway Timeout</strong>：服务器作为网关或代理时，等待上游服务器的响应超时</p></li></ul><h5 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h5><p>RESTful API（Representational State Transfer,表现层状态转化 API）是一种基于 HTTP 协议的 Web 服务设计风格它通过标准的 HTTP 方法（如 GET、POST、PUT、DELETE）来操作资源，并使用统一的接口来访问和操作这些资源。RESTful API 的设计理念是简单、轻量、易于扩展和维护。</p><h6 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h6><ol><li><p>资源（Resource）</p><ul><li><p><strong>资源</strong>是 RESTful API 的核心概念，表示系统中的任何对象或数据。资源可以是用户、订单、产品、文章等。</p></li><li><p>每个资源都有一个<strong>唯一的标识符（URI）</strong>，用于在系统中唯一标识该资源。</p></li></ul></li><li><p>统一接口（Uniform Interface）</p><ul><li><p><strong>统一接口</strong>是指 RESTful API 使用标准的 HTTP 方法来操作资源。常见的 HTTP 方法包括：</p><ul><li><p><strong>GET</strong>：获取资源。</p></li><li><p><strong>POST</strong>：创建资源。</p></li><li><p><strong>PUT</strong>：更新资源。</p></li><li><p><strong>DELETE</strong>：删除资源。</p></li></ul></li><li><p>通过统一接口，客户端可以使用相同的接口来访问和操作不同的资源，简化了 API 的设计和使用。</p></li></ul></li><li><p>状态转移（State Transfer）</p><ul><li><p><strong>状态转移</strong>是指客户端和服务器之间的交互过程中，资源的状态会发生变化。RESTful API <u>通过 HTTP 方法来实现状态转移</u>。</p></li><li><p>例如，客户端发送一个 POST 请求来创建一个新资源，服务器接收到请求后，资源的状态从“不存在”变为“存在”。</p></li></ul></li><li><p>无状态（Stateless）</p><ul><li><p><strong>无状态</strong>是指服务器不会保存客户端的请求状态。每个请求都是独立的，服务器不会记住之前的请求。</p></li><li><p>这种设计简化了服务器的设计和实现，但也带来了一些问题，如需要通过其他方式（如 Cookie、Session）来维护客户端状态。</p></li></ul></li></ol><h6 id="RESTful-API-的设计原则"><a href="#RESTful-API-的设计原则" class="headerlink" title="RESTful API 的设计原则"></a>RESTful API 的设计原则</h6><ol><li><p><strong>使用名词表示资源</strong></p><ul><li>资源应该使用名词来表示，而不是动词。例如，使用 <code>/users</code> 表示用户资源，而不是 <code>/getUsers</code>。</li></ul></li><li><p>使用 HTTP 方法操作资源</p><ul><li>使用标准的 HTTP 方法来操作资源：<ul><li><p><strong>GET</strong>：获取资源。</p></li><li><p><strong>POST</strong>：创建资源。</p></li><li><p><strong>PUT</strong>：更新资源。</p></li><li><p><strong>DELETE</strong>：删除资源。</p></li></ul></li></ul></li><li><p>使用 URI 标识资源</p><ul><li>每个资源都有一个唯一的 URI，用于在系统中唯一标识该资源。例如，<code>/users/123</code> 表示 ID 为 123 的用户资源。</li></ul></li><li><p>使用 JSON 或 XML 表示资源</p><ul><li>资源通常使用 JSON 或 XML 格式表示，便于客户端和服务器之间的数据交换。</li></ul></li><li><p>使用状态码表示请求结果</p><ul><li>使用标准的 HTTP 状态码表示请求的结果，如 200 OK、404 Not Found、500 Internal Server Error 等。</li></ul></li></ol><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>&#x3D;&#x3D;用户管理&#x3D;&#x3D;</p><ol><li>获取所有用户</li></ol><ul><li><p><strong>请求方法</strong>：GET</p></li><li><p><strong>URI</strong>：<code>/users</code></p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>响应</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>获取单个用户</li></ol><ul><li><p><strong>请求方法</strong>：GET</p></li><li><p><strong>URI</strong>：<code>/users/&#123;id&#125;</code></p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/users/1</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure><ul><li><strong>响应</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>    </span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>创建用户</li></ol><ul><li><p><strong>请求方法</strong>：POST</p></li><li><p><strong>URI</strong>：<code>/users</code></p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Charlie&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;charlie@example.com&quot;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p><strong>响应</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Charlie&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;charlie@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span>    </span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>更新用户</li></ol><ul><li><p><strong>请求方法</strong>：PUT</p></li><li><p><strong>URI</strong>：<code>/users/&#123;id&#125;</code></p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/users/1</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Alice Smith&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;alice.smith@example.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>响应</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alice.smith@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li>删除用户</li></ol><ul><li><p><strong>请求方法</strong>：DELETE</p></li><li><p><strong>URI</strong>：<code>/users/&#123;id&#125;</code></p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/users/1</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>响应</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;User deleted successfully&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h5><h6 id="1-Host"><a href="#1-Host" class="headerlink" title="1. Host"></a>1. Host</h6><ul><li><p><strong>用途</strong>：指定请求的目标主机和端口。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-User-Agent"><a href="#2-User-Agent" class="headerlink" title="2. User-Agent"></a>2. User-Agent</h6><ul><li><p><strong>用途</strong>：标识客户端的类型和版本。如:UA头部等</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36</span><br></pre></td></tr></table></figure></li></ul><h6 id="3-Accept"><a href="#3-Accept" class="headerlink" title="3. Accept"></a>3. Accept</h6><ul><li><p><strong>用途</strong>：指定客户端可以接受的响应内容类型。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-Accept-Language"><a href="#4-Accept-Language" class="headerlink" title="4. Accept-Language"></a>4. Accept-Language</h6><ul><li><p><strong>用途</strong>：指定客户端可以接受的自然语言。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7</span><br></pre></td></tr></table></figure></li></ul><h6 id="5-Accept-Encoding"><a href="#5-Accept-Encoding" class="headerlink" title="5. Accept-Encoding"></a>5. Accept-Encoding</h6><ul><li><p><strong>用途</strong>：指定客户端可以接受的编码方式（如 gzip、deflate）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br></pre></td></tr></table></figure></li></ul><h6 id="6-Content-Type"><a href="#6-Content-Type" class="headerlink" title="6. Content-Type"></a>6. Content-Type</h6><ul><li><strong>用途</strong>：指定请求体的 MIME 类型。<br>  MIME 类型（Multipurpose Internet Mail Extensions Type）是一种标准，用于表示文档、文件或字节流的性质和格式。MIME 类型由两部分组成：<strong>类型</strong>（Type）和<strong>子类型</strong>（Subtype），中间用斜杠（<code>/</code>）分隔。例如：<br><br>  - <code>text/plain</code>：表示纯文本文件。<br><br>  - <code>text/html</code>：表示 HTML 文件。<br><br>  - <code>application/json</code>：表示 JSON 数据。<br><br>  - <code>image/jpeg</code>：表示 JPEG 图像文件。<br><br>  - <code>audio/mpeg</code>：表示 MP3 音频文件。<br><br>  - <code>video/mp4</code>：表示 MP4 视频文件。</li><li><strong>示例</strong>：<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br></pre></td></tr></table></figure></li></ul><h6 id="7-Content-Length"><a href="#7-Content-Length" class="headerlink" title="7. Content-Length"></a>7. Content-Length</h6><ul><li><p><strong>用途</strong>：指定请求体的长度（以字节为单位）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br></pre></td></tr></table></figure></li></ul><h6 id="8-Authorization"><a href="#8-Authorization" class="headerlink" title="8. Authorization"></a>8. Authorization</h6><ul><li><p><strong>用途</strong>：指定客户端的身份验证信息。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</span><br></pre></td></tr></table></figure></li></ul><h6 id="9-Cookie"><a href="#9-Cookie" class="headerlink" title="9. Cookie"></a>9. Cookie</h6><ul><li><p><strong>用途</strong>：指定客户端发送的 Cookie 信息。有Cookie并且同域访问时会自动带上</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session_id=abc123; user_id=456</span><br></pre></td></tr></table></figure></li></ul><h6 id="10-Referer"><a href="#10-Referer" class="headerlink" title="10. Referer"></a>10. Referer</h6><ul><li><p><strong>用途</strong>：指定请求的来源 URL(适用于所有类型的请求, 会精确到详细页面地址, csrf拦截长常到这个字段)。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://www.example.com/previous-page</span><br></pre></td></tr></table></figure></li></ul><h6 id="11-Origin"><a href="#11-Origin" class="headerlink" title="11. Origin"></a>11. Origin</h6><ul><li><p><strong>用途</strong>：指定请求的来源域名，通常用于跨域请求。Origin比Refer更尊重隐私</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://www.example.com</span><br></pre></td></tr></table></figure></li></ul><h6 id="12-Cache-Control"><a href="#12-Cache-Control" class="headerlink" title="12. Cache-Control"></a>12. Cache-Control</h6><ul><li><p><strong>用途</strong>：指定缓存策略。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure></li></ul><h6 id="13-If-Modified-Since"><a href="#13-If-Modified-Since" class="headerlink" title="13. If-Modified-Since"></a>13. If-Modified-Since</h6><ul><li><p><strong>用途</strong>：指定请求资源的最后修改时间，用于条件请求。对应服务器的Last-Modified, 用来匹配看文件是否变动,只能精确到1s之内</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Sat, 29 Oct 2022 19:43:31 GMT</span><br></pre></td></tr></table></figure></li></ul><h6 id="14-If-None-Match"><a href="#14-If-None-Match" class="headerlink" title="14. If-None-Match"></a>14. If-None-Match</h6><ul><li><p><strong>用途</strong>：指定请求资源的 ETag，用于条件请求。对应服务器的ETag, 用来匹配文件内容是否改变(非常精确)</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;abc123456789&quot;</span><br></pre></td></tr></table></figure></li></ul><h6 id="15-Connection"><a href="#15-Connection" class="headerlink" title="15. Connection"></a>15. Connection</h6><ul><li><p><strong>用途</strong>：指定连接的管理方式，如保持连接（Keep-Alive）或关闭连接（Close）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure></li></ul><h6 id="16-Upgrade"><a href="#16-Upgrade" class="headerlink" title="16. Upgrade"></a>16. Upgrade</h6><ul><li><p><strong>用途</strong>：指定客户端希望升级的协议，如 WebSocket。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br></pre></td></tr></table></figure></li></ul><h6 id="17-X-Requested-With"><a href="#17-X-Requested-With" class="headerlink" title="17. X-Requested-With"></a>17. X-Requested-With</h6><ul><li><p><strong>用途</strong>：标识请求是否为 AJAX 请求。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Requested-With</span><span class="punctuation">: </span>XMLHttpRequest</span><br></pre></td></tr></table></figure></li></ul><h6 id="18-X-Forwarded-For"><a href="#18-X-Forwarded-For" class="headerlink" title="18. X-Forwarded-For"></a>18. X-Forwarded-For</h6><ul><li><p><strong>用途</strong>：指定客户端的真实 IP 地址，通常用于代理服务器。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Forwarded-For</span><span class="punctuation">: </span>192.0.2.1</span><br></pre></td></tr></table></figure></li></ul><h6 id="19-X-Forwarded-Proto"><a href="#19-X-Forwarded-Proto" class="headerlink" title="19. X-Forwarded-Proto"></a>19. X-Forwarded-Proto</h6><ul><li><p><strong>用途</strong>：指定客户端请求的协议（如 HTTP 或 HTTPS），通常用于代理服务器。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Forwarded-Proto</span><span class="punctuation">: </span>https</span><br></pre></td></tr></table></figure></li></ul><h6 id="20-X-CSRF-Token"><a href="#20-X-CSRF-Token" class="headerlink" title="20. X-CSRF-Token"></a>20. X-CSRF-Token</h6><ul><li><p><strong>用途</strong>：指定 CSRF（跨站请求伪造）令牌，用于防止 CSRF 攻击。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-CSRF-Token</span><span class="punctuation">: </span>abc123456789</span><br></pre></td></tr></table></figure></li></ul><h5 id="常见响应头"><a href="#常见响应头" class="headerlink" title="常见响应头"></a>常见响应头</h5><h6 id="1-Content-Type"><a href="#1-Content-Type" class="headerlink" title="1. Content-Type"></a>1. Content-Type</h6><ul><li><p><strong>用途</strong>：指定响应体的 MIME 类型。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Content-Type</code> 响应头用于指定响应体的 MIME 类型，如 <code>text/html</code> 表示 HTML 文档，<code>application/json</code> 表示 JSON 数据。<code>charset</code> 参数用于指定字符编码，如 <code>UTF-8</code>。</p></li></ul><h6 id="2-Cache-Control"><a href="#2-Cache-Control" class="headerlink" title="2. Cache-Control"></a>2. Cache-Control</h6><ul><li><p><strong>用途</strong>：指定缓存策略。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=3600, public</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Cache-Control</code> 响应头用于指定缓存策略，如 <code>max-age=3600</code> 表示资源可以在 3600 秒（1 小时）内使用缓存，<code>public</code> 表示资源可以被任何缓存存储。</p></li></ul><h6 id="3-Last-Modofied"><a href="#3-Last-Modofied" class="headerlink" title="3. Last-Modofied"></a>3. Last-Modofied</h6><ul><li><p><strong>用途</strong>：指定资源的最后修改时间。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 21 Oct 2025 07:28:00 GMT</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Last-Modified</code> 响应头用于指定资源的最后修改时间，客户端在后续请求中可以通过 <code>If-Modified-Since</code> 请求头来判断资源是否已修改。</p></li></ul><h6 id="4-Expires"><a href="#4-Expires" class="headerlink" title="4. Expires"></a>4. Expires</h6><ul><li><p><strong>用途</strong>：指定资源的过期时间。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 21 Oct 2025 07:28:00 GMT</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Expires</code> 响应头用于指定资源的过期时间，表示资源在指定时间之前可以使用缓存，而不需要重新请求服务器。</p></li></ul><h6 id="5-Max-age"><a href="#5-Max-age" class="headerlink" title="5. Max-age"></a>5. Max-age</h6><ul><li><p><strong>用途</strong>：指定资源的缓存时间（以秒为单位）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">Cache-Control: max-age=3600</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Max-Age</code> 是 <code>Cache-Control</code> 响应头的一个指令，用于指定资源的缓存时间（以秒为单位）。它告诉客户端在指定时间内可以使用缓存的资源，而不需要重新请求服务器。</p></li></ul><h6 id="6-Set-Cookie"><a href="#6-Set-Cookie" class="headerlink" title="6. Set-Cookie"></a>6. Set-Cookie</h6><ul><li><p><strong>用途</strong>：设置 Cookie。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">Set-Cookie: session_id=abc123; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Path=/; Secure; HttpOnly</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Set-Cookie</code> 响应头用于设置 Cookie，客户端在后续的请求中会将该 Cookie 发送回服务器。<code>Expires</code> 参数用于指定 Cookie 的过期时间，<code>Path</code> 参数用于指定 Cookie 的路径，<code>Secure</code> 参数表示 Cookie 只能通过 HTTPS 协议发送，<code>HttpOnly</code> 参数表示 Cookie 不能通过 JavaScript 访问。</p></li></ul><h6 id="7-Server"><a href="#7-Server" class="headerlink" title="7. Server"></a>7. Server</h6><ul><li><p><strong>用途</strong>：指定服务器软件的名称和版本。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">Server: Apache/2.4.46 (Unix)</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Server</code> 响应头用于指定服务器软件的名称和版本，如 <code>Apache/2.4.46</code> 表示服务器使用的是 Apache 2.4.46 版本。</p></li></ul><h6 id="8-Access-Control-Allow-Origin"><a href="#8-Access-Control-Allow-Origin" class="headerlink" title="8.Access-Control-Allow-Origin"></a>8.Access-Control-Allow-Origin</h6><ul><li><p><strong>用途</strong>：指定允许访问资源的源（域名）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br></pre></td></tr></table></figure></li><li><p><strong>解释</strong>：<code>Access-Control-Allow-Origin</code> 响应头用于指定允许访问资源的源（域名）。<code>*</code> 表示允许所有域名访问资源，也可以指定具体的域名，如 <code>https://www.example.com</code>。</p></li></ul><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>HTTP 缓存（HTTP Caching）是一种用于减少网络请求和提高网站性能的技术。通过缓存，客户端（通常是浏览器）可以在本地存储资源的副本，并在后续请求中使用这些缓存的资源，而不需要重新请求服务器。HTTP 缓存可以显著减少网络延迟和带宽消耗，提高网站的响应速度和用户体验。</p><h6 id="HTTP-缓存的类型"><a href="#HTTP-缓存的类型" class="headerlink" title="HTTP 缓存的类型"></a>HTTP 缓存的类型</h6><ol><li>强缓存</li></ol><p>  <strong>强缓存</strong>是指客户端在缓存有效期内直接使用本地缓存的资源，而不需要向服务器发送请求。强缓存通过以下响应头来控制：</p><ul><li><p>**<code>Cache-Control</code>**：指定缓存策略，如 <code>max-age</code>、<code>public</code>、<code>private</code>、<code>no-cache</code>、<code>no-store</code> 等。</p></li><li><p>**<code>Expires</code>**：指定资源的过期时间，表示资源在指定时间之前可以使用缓存。</p></li></ul><p>   <code>Cache-Control</code> 指令<br>  到期</p><ul><li><p>**<code>max-age</code>**：指定资源的缓存时间（以秒为单位）。例如，<code>Cache-Control: max-age=3600</code> 表示资源可以在 3600 秒（1 小时）内使用缓存。<br>可缓存性</p></li><li><p>**<code>public</code>**：表示资源可以被任何缓存存储，包括代理服务器。</p></li><li><p>**<code>private</code>**：表示资源只能被客户端缓存，不能被代理服务器缓存。</p></li><li><p>**<code>no-cache</code>**：表示资源在使用缓存之前必须向服务器验证，即使缓存未过期。</p></li><li><p>**<code>no-store</code>**：表示资源不能被缓存，每次请求都必须从服务器获取最新的资源。<br>重新验证&#x2F;重新加载</p></li><li><p><strong><code>must-revaliable</code></strong>:  一旦资源过期，在成功向原始服务器验证之前，不能使用</p></li></ul><p>  <code>Expires</code> 响应头</p><p>  <code>Expires</code> 响应头的值是一个具体的日期和时间，表示资源的过期时间。例如，<code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code> 表示资源在 2025 年 10 月 21 日 07:28:00 之前可以使用缓存。</p><ol start="2"><li><p>协商缓存</p><p> <strong>协商缓存</strong>是指客户端在缓存过期后，向服务器发送请求，询问资源是否有更新。服务器通过比较资源的最后修改时间和客户端的缓存时间，决定是否返回新的资源。协商缓存通过以下响应头和请求头来控制：</p><ul><li><p><strong><code>Last-Modified</code></strong> 和 **<code>If-Modified-Since</code>**：通过资源的最后修改时间来判断资源是否有更新。</p></li><li><p><strong><code>ETag</code></strong> 和 **<code>If-None-Match</code>**：通过资源的唯一标识符（ETag）来判断资源是否有更新。</p></li></ul><p> <code>Last-Modified</code> 和 <code>If-Modified-Since</code></p><ul><li><p>**<code>Last-Modified</code>**：服务器在响应头中返回资源的最后修改时间。例如，<code>Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT</code>。</p></li><li><p>**<code>If-Modified-Since</code>**：客户端在请求头中发送资源的最后修改时间，服务器通过比较这个时间和资源的实际修改时间，决定是否返回新的资源。</p></li></ul><p> <code>ETag</code> 和 <code>If-None-Match</code></p><ul><li><p>**<code>ETag</code>**：服务器在响应头中返回资源的唯一标识符（ETag）。例如，<code>ETag: &quot;abc123456789&quot;</code>。</p></li><li><p>**<code>If-None-Match</code>**：客户端在请求头中发送资源的 ETag，服务器通过比较这个 ETag 和资源的实际 ETag，决定是否返回新的资源。</p></li></ul></li></ol><h6 id="HTTP-缓存的工作流程"><a href="#HTTP-缓存的工作流程" class="headerlink" title="HTTP 缓存的工作流程"></a>HTTP 缓存的工作流程</h6><p><img src="/../assets/imgs_of_articles/HTTP/%E7%BC%93%E5%AD%98_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="缓存工作流程"></p><ol><li><p>强缓存的工作流程</p><ol><li><p><strong>客户端请求资源</strong>：客户端向服务器发送请求，请求某个资源。</p></li><li><p><strong>服务器返回资源和缓存策略</strong>：服务器返回资源，并在响应头中设置 <code>Cache-Control</code> 和 <code>Expires</code> 等缓存策略。</p></li><li><p><strong>客户端缓存资源</strong>：客户端根据缓存策略缓存资源。</p></li><li><p><strong>客户端使用缓存资源</strong>：在缓存有效期内，客户端直接使用本地缓存的资源，而不需要重新请求服务器。</p></li></ol></li><li><p>协商缓存的工作流程</p><ol><li><p><strong>客户端请求资源</strong>：客户端向服务器发送请求，请求某个资源。</p></li><li><p><strong>服务器返回资源和缓存策略</strong>：服务器返回资源，并在响应头中设置 <code>Last-Modified</code> 和 <code>ETag</code> 等缓存策略。</p></li><li><p><strong>客户端缓存资源</strong>：客户端根据缓存策略缓存资源。</p></li><li><p><strong>客户端缓存过期</strong>：在缓存过期后，客户端向服务器发送请求，并在请求头中设置 <code>If-Modified-Since</code> 和 <code>If-None-Match</code>。</p></li><li><p><strong>服务器验证资源</strong>：服务器通过比较 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 与资源的实际修改时间和 ETag，决定是否返回新的资源。</p></li><li><p><strong>服务器返回响应</strong>：如果资源未修改，服务器返回 <code>304 Not Modified</code> 响应，客户端继续使用缓存的资源；如果资源已修改，服务器返回新的资源。</p></li></ol></li></ol><h6 id="缓存的最佳实践"><a href="#缓存的最佳实践" class="headerlink" title="缓存的最佳实践"></a>缓存的最佳实践</h6><ol><li><p>使用 <code>Cache-Control</code> 和 <code>Expires</code></p><ul><li><p>对于静态资源（如图片、CSS 文件、JavaScript 文件），可以设置较长的 <code>max-age</code> 和 <code>Expires</code>，以减少客户端对服务器的请求，提高网站的性能。</p></li><li><p>对于动态内容（如 API 响应），可以设置较短的 <code>max-age</code> 和 <code>Expires</code>，以确保客户端能够及时获取最新的内容。</p></li></ul></li><li><p>使用 <code>Last-Modified</code> 和 <code>ETag</code></p><ul><li><p>对于经常更新的资源，可以使用 <code>Last-Modified</code> 和 <code>ETag</code> 进行协商缓存，减少带宽消耗。</p></li><li><p>对于不经常更新的资源，可以使用强缓存策略，减少客户端对服务器的请求。</p></li></ul></li><li><p>避免缓存敏感数据</p><ul><li>对于包含敏感数据的响应（如用户个人信息、支付信息等），应设置 <code>Cache-Control: no-store</code>，确保数据不会被缓存。</li></ul></li><li><p>使用 CDN</p><ul><li>使用内容分发网络（CDN）可以进一步提高缓存的效果，减少服务器的负载和网络延迟。</li></ul></li></ol><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>Cookie 是一种在客户端（通常是浏览器）和服务器之间传递的小型文本数据。服务器可以通过 HTTP 响应头（<code>Set-Cookie</code>）将 Cookie 发送给客户端，客户端在后续的请求中通过 HTTP 请求头（<code>Cookie</code>）将 Cookie 发送回服务器。Cookie 通常用于存储用户会话信息、用户偏好设置、购物车内容等。</p><h6 id="Cookie-的用途"><a href="#Cookie-的用途" class="headerlink" title="Cookie 的用途"></a>Cookie 的用途</h6><ol><li><p>会话管理</p><ul><li><strong>会话管理</strong>是 Cookie 最常见的用途之一。服务器可以通过 Cookie 来识别用户的会话，从而实现用户登录状态的保持。</li><li>例如，当用户登录网站时，服务器会生成一个唯一的会话 ID，并将其存储在 Cookie 中。客户端在后续的请求中会将该 Cookie 发送回服务器，服务器通过会话 ID 识别用户。</li></ul></li><li><p>个性化设置</p><ul><li><strong>个性化设置</strong>是指根据用户的偏好设置，提供个性化的内容和服务。服务器可以通过 Cookie 存储用户的偏好设置，并在后续的请求中根据这些设置提供个性化的内容。</li><li>例如，网站可以根据用户的语言偏好设置，提供不同语言的页面内容。</li></ul></li><li><p>购物车</p><ul><li><strong>购物车</strong>是电子商务网站中常见的功能。服务器可以通过 Cookie 存储用户的购物车内容，并在用户浏览网站时保持购物车的状态。</li><li>例如，当用户将商品添加到购物车时，服务器会将商品信息存储在 Cookie 中。用户在浏览其他页面时，购物车内容会保持不变。</li></ul></li><li><p>跟踪用户行为</p><ul><li><strong>跟踪用户行为</strong>是指通过 Cookie 记录用户的浏览行为，从而进行用户行为分析和广告投放。</li><li>例如，广告平台可以通过 Cookie 记录用户的浏览历史，从而向用户展示相关的广告。</li></ul></li></ol><h6 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h6><p>Cookie 可以通过多个属性来控制其行为和生命周期。以下是一些常见的 Cookie 属性：</p><ol><li><p><code>Name</code> 和 <code>Value</code></p><ul><li>**<code>Name</code>**：Cookie 的名称，用于在客户端和服务器之间唯一标识该 Cookie。</li><li>**<code>Value</code>**：Cookie 的值，存储在 Cookie 中的数据。</li></ul></li><li><p><code>Domain</code></p><ul><li>**<code>Domain</code>**：指定 Cookie 可以发送给哪些域名。默认情况下，Cookie 只能发送给设置它的域名。</li><li>例如，如果 <code>Domain</code> 设置为 <code>example.com</code>，则 Cookie 可以发送给 <code>www.example.com</code> 和 <code>blog.example.com</code>。</li></ul></li><li><p><code>Path</code></p><ul><li>**<code>Path</code>**：指定 Cookie 可以发送给哪些路径。默认情况下，Cookie 只能发送给设置它的路径及其子路径。</li><li>例如，如果 <code>Path</code> 设置为 <code>/blog</code>，则 Cookie 可以发送给 <code>/blog</code> 和 <code>/blog/post</code>。</li></ul></li><li><p><code>Expires</code> 和 <code>Max-Age</code></p><ul><li>**<code>Expires</code>**：指定 Cookie 的过期时间，表示 Cookie 在客户端的存储时间。过期后，Cookie 会被删除。</li><li>**<code>Max-Age</code>**：指定 Cookie 的最大存活时间（以秒为单位）。过期后，Cookie 会被删除。</li><li>例如，<code>Expires=Wed, 21 Oct 2025 07:28:00 GMT</code> 表示 Cookie 在 2025 年 10 月 21 日 07:28:00 过期。</li></ul></li><li><p><code>Secure</code></p><ul><li>**<code>Secure</code>**：指定 Cookie 只能通过 HTTPS 协议发送。如果设置为 <code>Secure</code>，则 Cookie 不会通过 HTTP 协议发送。</li><li>例如，<code>Secure;</code> 表示 Cookie 只能通过 HTTPS 协议发送。</li></ul></li><li><p><code>HttpOnly</code></p><ul><li>**<code>HttpOnly</code>**：指定 Cookie 不能通过 JavaScript 访问。如果设置为 <code>HttpOnly</code>，则 Cookie 只能通过 HTTP 请求发送，不能通过 JavaScript 访问。</li><li>例如，<code>HttpOnly;</code> 表示 Cookie 不能通过 JavaScript 访问。</li></ul></li><li><p><code>SameSite</code></p><ul><li>**<code>SameSite</code>**：指定 Cookie 在跨站请求时的行为。有三个可选值：<ul><li>**<code>Strict</code>**：Cookie 只能发送给同站请求，不能发送给跨站请求。</li><li>**<code>Lax</code>**：Cookie 可以发送给同站请求和部分跨站请求（如 GET 请求）。</li><li>**<code>None</code>**：Cookie 可以发送给同站请求和跨站请求，但必须设置 <code>Secure</code> 属性。</li></ul></li><li>例如，<code>SameSite=Lax;</code> 表示 Cookie 可以发送给同站请求和部分跨站请求。</li></ul></li></ol><h6 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h6><p>服务器可以通过 HTTP 响应头（<code>Set-Cookie</code>）设置 Cookie。以下是一个设置 Cookie 的示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>session_id=abc123; Expires=Wed, 21 Oct 2025 07:28:00 GMT; Domain=example.com; Path=/; Secure; HttpOnly; SameSite=Lax</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h6 id="发送-Cookie"><a href="#发送-Cookie" class="headerlink" title="发送 Cookie"></a>发送 Cookie</h6><p>客户端在后续的请求中会通过 HTTP 请求头（<code>Cookie</code>）将 Cookie 发送回服务器。以下是一个发送 Cookie 的示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>session_id=abc123</span><br></pre></td></tr></table></figure><h6 id="Cookie-的安全性"><a href="#Cookie-的安全性" class="headerlink" title="Cookie 的安全性"></a>Cookie 的安全性</h6><ol><li><p>防止 CSRF 攻击</p><ul><li><strong>CSRF（跨站请求伪造）</strong>攻击是指攻击者通过诱导用户访问恶意网站，利用用户的身份发送恶意请求。</li><li>通过设置 <code>SameSite=Strict</code> 或 <code>SameSite=Lax</code>，可以防止 CSRF 攻击。</li></ul></li><li><p>防止 XSS 攻击</p><ul><li><strong>XSS（跨站脚本）</strong>攻击是指攻击者通过注入恶意脚本，窃取用户的 Cookie 信息。</li><li>通过设置 <code>HttpOnly</code>，可以防止 JavaScript 访问 Cookie，从而防止 XSS 攻击。</li></ul></li><li><p>防止中间人攻击</p><ul><li><strong>中间人攻击</strong>是指攻击者通过拦截网络通信，窃取用户的 Cookie 信息。</li><li>通过设置 <code>Secure</code>，可以确保 Cookie 只能通过 HTTPS 协议发送，从而防止中间人攻击。</li></ul></li></ol><p>Cookie 是一种在客户端和服务器之间传递的小型文本数据，通常用于存储用户会话信息、用户偏好设置、购物车内容等。Cookie 可以通过多个属性来控制其行为和生命周期，如 <code>Domain</code>、<code>Path</code>、<code>Expires</code>、<code>Max-Age</code>、<code>Secure</code>、<code>HttpOnly</code> 和 <code>SameSite</code>。服务器可以通过 HTTP 响应头（<code>Set-Cookie</code>）设置 Cookie，客户端在后续的请求中通过 HTTP 请求头（<code>Cookie</code>）将 Cookie 发送回服务器。通过合理使用 Cookie，可以实现各种网络应用的功能需求，同时确保安全性。</p><h4 id="HTTPS概述"><a href="#HTTPS概述" class="headerlink" title="HTTPS概述"></a>HTTPS概述</h4><p>HTTPS（HyperText Transfer Protocol Secure）是 HTTP 的安全版本，使用 SSL&#x2F;TLS 协议对数据进行加密和认证，确保数据在传输过程中的安全性和完整性。HTTPS 通过加密通信内容，防止数据被窃听和篡改，同时通过数字证书对服务器进行认证，确保客户端连接到的是合法的服务器。</p><h5 id="HTTPS-的工作原理"><a href="#HTTPS-的工作原理" class="headerlink" title="HTTPS 的工作原理"></a>HTTPS 的工作原理</h5><h6 id="1-加密通信"><a href="#1-加密通信" class="headerlink" title="1. 加密通信"></a>1. 加密通信</h6><p>HTTPS 使用 SSL&#x2F;TLS 协议对数据进行加密，确保数据在传输过程中不会被窃听和篡改。SSL&#x2F;TLS 协议使用对称加密和非对称加密相结合的方式，对数据进行加密和解密。</p><ul><li><p><strong>对称加密</strong>：使用相同的密钥对数据进行加密和解密。对称加密速度快，但密钥传输存在安全风险。</p></li><li><p><strong>非对称加密</strong>：使用公钥和私钥对数据进行加密和解密。公钥可以公开，私钥必须保密。非对称加密安全性高，但速度较慢。</p></li></ul><h6 id="2-数字证书"><a href="#2-数字证书" class="headerlink" title="2. 数字证书"></a>2. 数字证书</h6><p>HTTPS 使用数字证书对服务器进行认证，确保客户端连接到的是合法的服务器。数字证书由受信任的第三方机构（CA，Certificate Authority）签发，包含服务器的公钥、服务器信息和 CA 的签名。</p><ul><li><p><strong>公钥</strong>：用于加密数据，客户端使用服务器的公钥对数据进行加密。</p></li><li><p><strong>私钥</strong>：用于解密数据，服务器使用自己的私钥对数据进行解密。</p></li><li><p><strong>CA 签名</strong>：用于验证数字证书的真实性，客户端使用 CA 的公钥验证证书的签名。</p></li></ul><h6 id="3-握手过程"><a href="#3-握手过程" class="headerlink" title="3. 握手过程"></a>3. 握手过程</h6><p>HTTPS 的握手过程包括以下几个步骤：</p><ol><li><p><strong>客户端发送 ClientHello</strong>：客户端向服务器发送 ClientHello 消息，包含支持的 SSL&#x2F;TLS 版本、加密算法列表和随机数。</p></li><li><p><strong>服务器发送 ServerHello</strong>：服务器选择 SSL&#x2F;TLS 版本和加密算法，并生成随机数，发送 ServerHello 消息。</p></li><li><p><strong>服务器发送证书</strong>：服务器将自己的数字证书发送给客户端，包含服务器的公钥和 CA 的签名。</p></li><li><p><strong>客户端验证证书</strong>：客户端使用 CA 的公钥验证证书的签名，确保证书的真实性。</p></li><li><p><strong>客户端生成 Pre-Master Secret</strong>：客户端生成 Pre-Master Secret，并使用服务器的公钥进行加密，发送给服务器。</p></li><li><p><strong>服务器解密 Pre-Master Secret</strong>：服务器使用自己的私钥解密 Pre-Master Secret。</p></li><li><p><strong>客户端和服务器生成 Master Secret</strong>：客户端和服务器使用 Pre-Master Secret 和之前的随机数，生成 Master Secret。</p></li><li><p><strong>客户端和服务器生成会话密钥</strong>：客户端和服务器使用 Master Secret 生成会话密钥，用于对称加密通信内容。</p></li><li><p><strong>客户端发送 Finished</strong>：客户端发送 Finished 消息，使用会话密钥加密，表示握手过程完成。</p></li><li><p><strong>服务器发送 Finished</strong>：服务器发送 Finished 消息，使用会话密钥加密，表示握手过程完成。<br>![[HTTPS.png|600]]</p></li></ol><h5 id="HTTPS-的优点"><a href="#HTTPS-的优点" class="headerlink" title="HTTPS 的优点"></a>HTTPS 的优点</h5><h6 id="1-数据加密"><a href="#1-数据加密" class="headerlink" title="1. 数据加密"></a>1. 数据加密</h6><p>HTTPS 使用 SSL&#x2F;TLS 协议对数据进行加密，确保数据在传输过程中不会被窃听和篡改。</p><h6 id="2-服务器认证"><a href="#2-服务器认证" class="headerlink" title="2. 服务器认证"></a>2. 服务器认证</h6><p>HTTPS 使用数字证书对服务器进行认证，确保客户端连接到的是合法的服务器。</p><h6 id="3-数据完整性"><a href="#3-数据完整性" class="headerlink" title="3. 数据完整性"></a>3. 数据完整性</h6><p>HTTPS 使用消息认证码（MAC）确保数据在传输过程中不会被篡改。</p><h5 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h5><h6 id="1-性能开销"><a href="#1-性能开销" class="headerlink" title="1. 性能开销"></a>1. 性能开销</h6><p>HTTPS 的握手过程和加密解密操作会引入一定的性能开销，尤其是在低带宽和高延迟的网络环境中。</p><h6 id="2-部署成本"><a href="#2-部署成本" class="headerlink" title="2. 部署成本"></a>2. 部署成本</h6><p>HTTPS 需要购买和配置数字证书，部署和维护 HTTPS 服务器的成本较高。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="1-使用-HTTPS-访问网站"><a href="#1-使用-HTTPS-访问网站" class="headerlink" title="1. 使用 HTTPS 访问网站"></a>1. 使用 HTTPS 访问网站</h6><p><strong>客户端请求</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure><p><strong>服务器响应</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，客户端使用 HTTPS 协议访问 <code>www.example.com</code> 网站，服务器返回一个 HTML 文件。HTTPS 协议确保数据在传输过程中被加密，防止数据被窃听和篡改。</p><h6 id="2-使用数字证书认证服务器"><a href="#2-使用数字证书认证服务器" class="headerlink" title="2. 使用数字证书认证服务器"></a>2. 使用数字证书认证服务器</h6><p><strong>服务器证书</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commonName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;www.example.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;organization&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Example Inc.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;US&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;issuer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commonName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DigiCert SHA2 Secure Server CA&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;organization&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DigiCert Inc.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;US&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;publicKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，服务器使用数字证书对自身进行认证。数字证书包含服务器的公钥、服务器信息和 CA 的签名。客户端使用 CA 的公钥验证证书的签名，确保证书的真实性。</p><hr><h2 id="HTTP协议应用场景分析-——-以今日头条为例"><a href="#HTTP协议应用场景分析-——-以今日头条为例" class="headerlink" title="HTTP协议应用场景分析 —— 以今日头条为例"></a>HTTP协议应用场景分析 —— 以<a href="https://www.toutiao.com/">今日头条</a>为例</h2><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>第一次进入页面：<br><img src="../assets/imgs_of_articles/HTTP/今日头条_静态资源_index.css.png" alt="静态资源index.css" style="zoom:80%;" /></p><p>刷新一次后：<br><img src="../assets/imgs_of_articles/HTTP/今日头条_静态资源_index.css2.png" alt="静态资源index.css" style="zoom:80%;" /><br>此时，状态码200一定发起了请求（指 client请求—server响应 的完整过程）吗？<br>（来自磁盘缓存)&#x3D;》这次的请求是从<strong>本地缓存</strong>拿到的<br>观察<strong>缓存策略</strong>：<br><img src="../assets/imgs_of_articles/HTTP/今日头条_静态资源_index.css_缓存策略.png" alt="静态资源缓存策略" style="zoom:80%;" /><br>Cache-Control: max-age&#x3D;2592000</p><ul><li>强缓存 </li><li>Cache-Control: 一月<br>别的信息：</li><li>Access-Control-Allow-Origin: * &#x3D;&gt; <em>允许所有域名访问</em></li><li>Content-Type: text&#x2F;css &#x3D;&gt; <em>资源类型： css</em></li></ul><p>静态资源在部署上有没有什么方案呢？<br>为了性能优化&#x2F;用户体验优化，即：让用户更快地看到页面和做一些可交互的行为。而影响到这些的可能是，整个页面里的静态资源的访问速度。那我们提高静态资源的访问速度也一定程度上加强了用户体验。</p><p>静态资源方案： 缓存 + CDN + 文件名hash</p><ul><li>CDN：Content Delivery NetWork，内容分发网络</li><li>通过用户就近性和服务器负载的判断，CDN确保内容以一种极为高效的方式为用户的请求提供服务。</li></ul><p>除了保证用户拿到的资源更快，我们还要保证用户拿到文件更新！<br>    所以一般我们在文件名上做一些手脚，在我们这里就是<strong>文件名哈希</strong>。可以看到上述图片中的文件名的中间：<em>index.7f8dc804.css</em> 。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul><li><p>业务场景</p><ul><li><strong>表单登录</strong></li><li>扫码登录</li></ul></li><li><p>技术方式</p><ul><li>SSO</li></ul></li><li><p>账号密码登录</p></li><li><p>打开控制台 - network - 勾选 preserve log - 过滤quick_login</p><img src="../assets/imgs_of_articles/HTTP/今日头条_静态资源_登录.png" alt="登录" style="zoom:75%;" />观察请求，这两个有什么区别呢？最大的区别：Method不同第一个请求：<img src="../assets/imgs_of_articles/HTTP/登录请求1.png" alt="登录请求" style="zoom:75%;" />**发起的是：OPTIONS请求，为什么呢？**</li><li><p><strong>跨域， cross-origin</strong><br><strong>什么是跨域？</strong><br>一个域名由：scheme+host name+port 组成，只要是不同的话，我们都认为是跨域。<br><img src="/../assets/imgs_of_articles/HTTP/%E8%B7%A8%E5%9F%9F%E8%BE%A8%E6%9E%90.png" alt="跨域辨析"><br>一般来说，<br><em>- https 默认使用端口号 443</em></p><p><em>- http 默认使用端口号 80</em><br>跨域</p></li><li><p>CORS(Cross-Origin Resource Sharing)</p></li><li><p>预请求：获知服务端是否允许该跨域资源请求（<em>复杂请求</em>） </p><ul><li>简单请求</li><li>复杂请求：只有在复杂请求才会发起跨域请求，生产生活场景中大部分都是复杂请求</li></ul></li><li><p>相关协议头</p><ul><li>Access-Control-Allow-Origin</li><li>Access-Control-Allow-Origin</li><li>Access-Control-Expose-Headers</li><li>Access-Control-Max-Age</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Allow-Methods</li><li>Access-Control-Allow-Headers</li><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li><li>Origin  <img src="../assets/imgs_of_articles/HTTP/跨域示意图.png" alt="跨域" style="zoom:80%;" /></li></ul></li></ul><p><strong>跨域解决方案</strong></p><ul><li>CORS</li><li>代理服务器<ul><li>同源策略是浏览器的安全策略，不是HTTP</li><li><img src="../assets/imgs_of_articles/HTTP/代理服务器.png" alt="代理服务器" style="zoom:80%;" /></li></ul></li><li>Iframe通信<ul><li>限制较多，诸多不便</li></ul></li></ul><p><img src="/../assets/imgs_of_articles/HTTP/%E7%99%BB%E5%BD%95_%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98.png" alt="登录的问题"></p><ol><li>想什么地址做了什么动作？<ul><li>使用POST方法</li><li>目标域名：<a href="https://sso.toutiao.com/">https://sso.toutiao.com</a></li><li>目标：quick_login&#x2F;v2&#x2F;</li></ul></li><li>携带了那些信息？返回了哪些信息？<ul><li>携带：<ul><li>Post body，数据格式为form</li><li>希望获取的数据格式为json</li><li>已有的cookie</li></ul></li><li>返回信息<ul><li>数据格式json</li><li>set-cookie信息</li></ul></li></ul></li></ol><p><strong>刷新一下页面或下次进入页面问什么能够记住登陆状态呢？</strong></p><p>鉴权</p><ul><li>Session + cookie<img src="../assets/imgs_of_articles/HTTP/Session+Cookie.png" alt="Cookie" style="zoom:67%;" /></li><li>JWT(JSON web token)<img src="../assets/imgs_of_articles/HTTP/JWT.png" alt="JWT" style="zoom:60%;" />各自的优劣，和应用场景</li></ul><p><strong>点击右上角发文章，跳转后的网站为什么自动登录？</strong></p><p>SSO：单点登录（Single Sign On）<br><img src="/../assets/imgs_of_articles/HTTP/SSO%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SSO"></p><hr><h2 id="HTTP协议实战分析"><a href="#HTTP协议实战分析" class="headerlink" title="HTTP协议实战分析"></a>HTTP协议实战分析</h2><p>在实际开发中，HTTP协议的应用非常广泛，涵盖了从浏览器到服务器的各个层面。以下是详细的实战分析，包括浏览器中的AJAX请求（XHR和Fetch）、Node.js中的HTTP&#x2F;HTTPS标准库和常用请求库（axios），以及如何通过网络优化和稳定性提升用户体验。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="AJAX之XHR"><a href="#AJAX之XHR" class="headerlink" title="AJAX之XHR"></a>AJAX之XHR</h4><p>XMLHttpRequest（XHR）是浏览器中最早用于进行AJAX请求的技术。虽然现在有更现代的Fetch API，但XHR仍然在一些旧项目中使用。</p><ul><li>readyState</li></ul><table><thead><tr><th align="center">编号</th><th>状态</th><th>含义</th></tr></thead><tbody><tr><td align="center">0</td><td>UNSENT</td><td>代理被创建，但尚未调用open()方法</td></tr><tr><td align="center">1</td><td>OPENED</td><td>open()方法已经被调用</td></tr><tr><td align="center">2</td><td>HEADERS_RECEIVED</td><td>send()方法已经被调用，并且头部和状态已经可获得</td></tr><tr><td align="center">3</td><td>LOADNING</td><td>下载中；responseText属性已经包含部分数据</td></tr><tr><td align="center">4</td><td>DONE</td><td>下载操作已完成</td></tr></tbody></table><h5 id="封装XHR请求方法"><a href="#封装XHR请求方法" class="headerlink" title="封装XHR请求方法"></a>封装XHR请求方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="comment">// 默认配置</span></span><br><span class="line">    <span class="keyword">const</span> defaults = &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="comment">// 默认请求方法为GET</span></span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 请求的URL</span></span><br><span class="line">        <span class="attr">async</span>: <span class="literal">true</span>, <span class="comment">// 默认异步请求</span></span><br><span class="line">        <span class="attr">data</span>: <span class="literal">null</span>, <span class="comment">// 请求数据</span></span><br><span class="line">        <span class="attr">headers</span>: &#123;&#125;, <span class="comment">// 请求头</span></span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, <span class="comment">// 请求成功回调</span></span><br><span class="line">        <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 请求失败回调</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户配置和默认配置</span></span><br><span class="line">    <span class="keyword">const</span> settings = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaults, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(settings.<span class="property">method</span>, settings.<span class="property">url</span>, settings.<span class="property">async</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> header <span class="keyword">in</span> settings.<span class="property">headers</span>) &#123;</span><br><span class="line">        xhr.<span class="title function_">setRequestHeader</span>(header, settings.<span class="property">headers</span>[header]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// 请求成功，调用success回调</span></span><br><span class="line">                settings.<span class="title function_">success</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 请求失败，调用error回调</span></span><br><span class="line">                settings.<span class="title function_">error</span>(xhr.<span class="property">statusText</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(settings.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://api.example.com/data&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET请求成功:&#x27;</span>, response);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;GET请求失败:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="AJAX之Fetch"><a href="#AJAX之Fetch" class="headerlink" title="AJAX之Fetch"></a>AJAX之Fetch</h4><p>Fetch API是现代浏览器中用于进行网络请求的一种更简洁、更强大的方式。它基于Promise，提供了更直观和灵活的API。</p><ul><li>XML的升级版</li><li>使用Promise</li><li>模块化设计，Response，Request，Header对象</li><li>通过数据流处理对象，支持分块读取</li></ul><h5 id="封装Fetch请求方法"><a href="#封装Fetch请求方法" class="headerlink" title="封装Fetch请求方法"></a>封装Fetch请求方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchRequest</span>(<span class="params">url, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 默认配置</span></span><br><span class="line">    <span class="keyword">const</span> defaults = &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="comment">// 默认请求方法为GET</span></span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> <span class="comment">// 默认请求头</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">credentials</span>: <span class="string">&#x27;same-origin&#x27;</span> <span class="comment">// 默认凭据模式</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并用户配置和默认配置</span></span><br><span class="line">    <span class="keyword">const</span> settings = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaults, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url, settings)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response.<span class="title function_">json</span>(); <span class="comment">// 将响应解析为JSON</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Fetch error:&#x27;</span>, error);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">fetchRequest</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET请求成功:&#x27;</span>, data))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;GET请求失败:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><h4 id="标准库：HTTP-HTTPS"><a href="#标准库：HTTP-HTTPS" class="headerlink" title="标准库：HTTP&#x2F;HTTPS"></a>标准库：HTTP&#x2F;HTTPS</h4><p>Node.js提供了内置的<code>http</code>和<code>https</code>模块，用于创建HTTP和HTTPS服务器以及发送HTTP请求。</p><ul><li>默认模块，无需安装其他依赖</li><li>功能有限&#x2F;不是十分友好</li></ul><h5 id="使用HTTP模块发送请求"><a href="#使用HTTP模块发送请求" class="headerlink" title="使用HTTP模块发送请求"></a>使用HTTP模块发送请求</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">httpRequest</span>(<span class="params">options, data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> req = http.<span class="title function_">request</span>(options, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> responseData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">                responseData += chunk;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(responseData);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            req.<span class="title function_">write</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.<span class="title function_">end</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">&#x27;api.example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/data&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">httpRequest</span>(options)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET请求成功:&#x27;</span>, data))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;GET请求失败:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><h4 id="常用请求库：axios"><a href="#常用请求库：axios" class="headerlink" title="常用请求库：axios"></a>常用请求库：axios</h4><p>axios是一个基于Promise的HTTP客户端，适用于浏览器和Node.js。它提供了更简洁的API，并且支持拦截器、取消请求等功能。</p><ul><li>支持浏览器，nodejs环境</li><li>丰富的拦截器</li></ul><h5 id="安装axios"><a href="#安装axios" class="headerlink" title="安装axios"></a>安装axios</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h5 id="使用axios发送请求"><a href="#使用axios发送请求" class="headerlink" title="使用axios发送请求"></a>使用axios发送请求</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">axiosRequest</span>(<span class="params">url, options = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">        url,</span><br><span class="line">        ...options</span><br><span class="line">    &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="property">data</span>)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Axios error:&#x27;</span>, error);</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="title function_">axiosRequest</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET请求成功:&#x27;</span>, data))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;GET请求失败:&#x27;</span>, error));</span><br></pre></td></tr></table></figure><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><h4 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h4><p>网络优化是提升用户体验的关键。以下是一些常见的网络优化策略：</p><ol><li><strong>压缩资源</strong>：使用Gzip或Brotli压缩静态资源（如HTML、CSS、JavaScript），减少传输数据量。</li><li><strong>缓存策略</strong>：通过设置HTTP响应头（如<code>Cache-Control</code>、<code>Expires</code>），利用浏览器缓存减少重复请求。</li><li><strong>CDN加速</strong>：使用内容分发网络（CDN）将静态资源分发到全球多个节点，减少延迟和提高加载速度。</li><li><strong>减少HTTP请求</strong>：合并CSS和JavaScript文件，减少页面加载时的HTTP请求数量。</li><li><strong>使用HTTP&#x2F;2</strong>：HTTP&#x2F;2支持多路复用、头部压缩等特性，可以显著提升页面加载速度。</li></ol><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定性是确保应用可靠运行的关键。以下是一些提升稳定性的策略：</p><ol><li><strong>错误处理</strong>：在请求失败时，提供友好的错误提示，并记录错误日志以便后续分析。</li><li><strong>超时设置</strong>：为请求设置合理的超时时间，避免长时间等待导致用户体验下降。</li><li><strong>重试机制</strong>：在请求失败时，自动重试请求，提高请求成功率。</li><li><strong>监控和报警</strong>：使用监控工具（如Prometheus、Grafana）实时监控应用性能，并在异常时发送报警通知。</li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过封装XHR和Fetch请求方法，我们可以在浏览器中实现简洁、可复用的AJAX请求。在Node.js中，可以使用内置的HTTP&#x2F;HTTPS模块或第三方库（如axios）进行网络请求。通过网络优化和稳定性提升，我们可以显著改善用户体验，确保应用的可靠运行。在实际开发中，可以根据需求进一步优化和扩展这些方法，以满足复杂的业务需求。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is The Internet?</title>
      <link href="/2024/11/01/What%20is%20the%20Internet%EF%BC%9F/"/>
      <url>/2024/11/01/What%20is%20the%20Internet%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-The-Internet"><a href="#What-is-The-Internet" class="headerlink" title="What is The Internet?"></a>What is The Internet?</h1><h5 id="Reading："><a href="#Reading：" class="headerlink" title="Reading："></a>Reading：</h5><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Web_mechanics/How_does_the_Internet_work">How_does_the_Internet_work</a> </li><li><a href="https://cs.fyi/guide/how-does-internet-work">how-does-internet-work</a></li></ul><h5 id="Watching：How-the-Internet-Works-in-5-Minutes"><a href="#Watching：How-the-Internet-Works-in-5-Minutes" class="headerlink" title="Watching：How the Internet Works in 5 Minutes"></a>Watching：<a href="https://www.youtube.com/watch?v=7_LPdttKXPc">How the Internet Works in 5 Minutes</a></h5><h5 id="Outline"><a href="#Outline" class="headerlink" title="Outline:"></a>Outline:</h5><p>互联网通过全球互联的<strong>计算机和服务器</strong>网络工作，通过<strong>标准化协议</strong>进行通信。数据被分解成<strong>数据包</strong>，并使用<strong>互联网协议 (IP)</strong> 通过各种<strong>网络节点</strong>进行路由。这些数据包通过不同的<strong>物理基础设施</strong>传输，包括光纤电缆、卫星和无线网络。<strong>传输控制协议 (TCP)</strong> 确保数据包在目的地可靠地传送和重组。<strong>域名系统 (DNS) 服务器</strong>将人类可读的网站名称转换为 IP 地址。当您访问网站时，您的设备会向相应的服务器<strong>发送请求</strong>，服务器会使用请求的数据进行响应。这个过程由<strong>路由器、交换机和其他网络设备</strong>推动，实现了<strong>远距离信息</strong>的无缝交换，构成了我们数字通信的支柱。</p><h5 id="The-note-is-aiming-at："><a href="#The-note-is-aiming-at：" class="headerlink" title="The note is aiming at："></a>The note is aiming at：</h5><ul><li><strong>What</strong> is the Internet?</li><li>How does the information <strong>move on</strong> the internet?</li><li>How do the networks <strong>talk</strong> to each other and the <strong>protocols</strong> involved?</li><li>What’s the <strong>relationship</strong> between packets, routers, and reliability?</li><li>HTTP and the HTML – How are you viewing this <strong>webpage</strong> in your browser?</li><li>How is the information transfer on the internet <strong>made secure</strong>?</li><li>What is <strong>cybersecurity</strong> and what are some common <strong>internet crimes</strong>?</li></ul><h2 id="What-is-the-internet"><a href="#What-is-the-internet" class="headerlink" title="What is the internet?"></a>What is the internet?</h2><p>互联网是一个由<strong>相互连接的计算机</strong>组成的<strong>全球网络</strong>，这些计算机通过一组<strong>标准化的协议</strong>进行通信。</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91#%E5%8E%86%E5%8F%B2">互联网的历史有些模糊不清</a>。它始于 1960 年美国军方资助的研究项目。1980 年在许多公共大学和公司的支持下，它演变为一种<strong>公共基础设施</strong>。随着时间的变化，各种各样的技术支持着互联网的发展，但是它的工作方式却没有改变多少：<u>互联网确保所有的电脑之间的连接，无论发生什么他们依旧保持连接。</u> </p><h2 id="Wires-Cables-and-Wi-Fi"><a href="#Wires-Cables-and-Wi-Fi" class="headerlink" title="Wires, Cables, and Wi-Fi"></a>Wires, Cables, and Wi-Fi</h2><p>互联网上的信息通过各种介质以 $bit$ 的形式从一台计算机移动到另一台计算机，包括以太网电缆、光纤电缆和无线信号（即无线电波）。</p><ul><li>电缆 —— 廉价 —— 信号遗失</li><li>光缆 —— 快速 &#x2F; NO信号遗失 —— 昂贵 &#x2F; 实现艰难（很多时候铜缆代替）</li><li>无线信号 —— 方便 &#x2F; 移动 —— 无法准确传递到较远的地方<ul><li>但它可依赖有线网络，你所传送的二进制数据被传到无线路由器，再透过网路线等实体线路在互联网世界传递<br>  但是本质都是：互联网中所有数据都会被转换为 0&#x2F;1 ，再通过 电子脉冲、光束、无线电波 传递 信息</li></ul></li></ul><h2 id="IP-Addresses-DNS"><a href="#IP-Addresses-DNS" class="headerlink" title="IP Addresses &amp; DNS"></a>IP Addresses &amp; DNS</h2><p>1970年代，Vin Cerf 和 Bob Khan 发明了<strong>网络通信协议</strong>让互联网的沟通方式得以实现。</p><p>我们可能通过<strong>手机或笔记本</strong>透过<strong>WiFi</strong>上网，<strong>Wi-fi</strong> 则连接到<strong>互联网服务供应商</strong> (Internet Service Provider , ISP)，<strong>ISP</strong>进而透过数以万计相连接的<strong>网络</strong>让我们与世界上数亿的<strong>设备</strong>相连接。</p><p>鲜有人知的是，互联网是一种设计哲学，它由一组协议来表现的结构体系。而一个<strong>通信协议</strong>由一组公认的规则和标准组成。如果参与者都同意使用，就能彼此顺利沟通。 </p><p>这时，互联网“实际上”如何运作显得没的么重要；更重要的是：它的设计哲学能够让互联网调整和纳入新的通信技术，这是因为新的通信技术只需要配合协定，就能以某种方式使用互联网。</p><p>所有设备在互联网中，都拥有一个独一无二的地址，即一组数字，类似于电话&#x2F;街道地址。这些网络地址再一个范围内的网络内对每个电脑或其他设备都是独特的。</p><p>类似于家庭或公司都有邮件地址，我们无需认识对方，即可寄信给他，且，只需要知道他的地址以及如何正确书写地址，这样这封信才能通过邮寄系统送达目的地。互联网中电脑的$Addressing\ System$有类似的作用，并且这形成了最重要的通信协定之一：<strong>互联网协定(Internet Protocol, IP)<strong>。因而一个电脑的地址被称为：</strong>IP地址</strong>。</p><p>浏览一个网站即：你的电脑向另一个电脑征求信息。你的电脑向另一台电脑的IP位址发送信息，同时附带自己的IP位址，所以另一台电脑就知道要回复信息到什么地方。</p><p>我们或许都见过IP位址，它其实就是<strong>一连串数字</strong>，由“<strong>层级</strong>”构成，就像家庭住址：国家.城市.街道.门牌号码；IP地址也可分为许多部分，与所有数据一样，每一个数字都以位(bit)所表示，典型的IP位址的长度是<strong>32位</strong>，每一部分则有<strong>8位</strong>。<strong>前面</strong>的数字，通常可识别设备所在<strong>国家&#x2F;区域</strong>；<strong>接下来</strong>表示<strong>子网域</strong>；<strong>最后</strong>则表示<strong>特定设备的地址</strong>。这个版本的IP协议，被称为$IPv4$，于1973年所设计，并在80年代初被广泛使用。它提供了超过40亿个独一无二的位址，让设备连接到互联网。</p><p>但是！互联网的popularity远比Vinf Cerf想象的<strong>更流行普及</strong>，40亿个不同的位址仍然不够，所以我们正处于转换到更长IP协议(<strong>IPv6</strong>)的过渡期中。$IPv6$的每一个位址的<strong>长度为128位</strong>，可提供超 $340×10^{33}$ 个不同的位址。这，就完全足够了！</p><p>但我们在互联网冲浪时，大多不曾见过或关心IP网络地址；而是遇见诸如：<code>www.example.com</code> 等的网址，这其实就是<strong>网域名称系统(Domain Name System , DNS)</strong> 可将对应的网域名称(<code>www.example.com</code> )与对应的IP位址关联在一起。我们的电脑会使用DNS查询网域名称，来获得对应的IP以连接到互联网上的目的地。</p><p>那么如何设计这样一个系统：在数十亿个设备中找到正确的那一个IP？一台DNS服务器是无法处理这么平凡的查询操作的。<strong>解决方法</strong>是：让所有的DNS服务器以【分布式阶层】串联在一起，并以区域分开，针对主要网域( .org, .com, .net 等) <strong>分开负责</strong>。</p><p>起初，DNS是为了政府和教育机关而设计的开放且公开的通信协定，因为<strong>DNS开放性</strong>，导致其<strong>很容易受到网络攻击</strong>的影响。有一种攻击：<strong>DNS spoofing</strong> —— Hacker入侵一台DNS服务器，并将网域名称修改对应到错误的IP地址；这样攻击者就能把人们传送到【冒名顶替】的假网站，继而若使用者真的使用了这个假网站，这会导致其收到更多问题的侵害。</p><p>（这里可以继续了解DNS的工作原理，通过下面给出的图链接）</p><ul><li><img src="/../assets/images/How_DNS_Work.png" alt="How_DNS_Work.png"></li></ul><p>互联网十分巨大，且每天<strong>变化</strong>增大；因此，DNS以及互联网协议都被设计为<strong>可持续扩充</strong>。</p><h2 id="Package-Routing-Reliability"><a href="#Package-Routing-Reliability" class="headerlink" title="Package, Routing &amp; Reliability"></a>Package, Routing &amp; Reliability</h2><p>做一个假设，如果我们想要播放▶某个网站的音频，我们的计算机是直接连接到该服务器，然后该服务器在专用线路直接向你发送音频吗？事实显然<strong>不是</strong>。如果互联网是有专用线路连接构成，那么随着用户的增加，这样的工作会变得极为巨大繁杂以至不可能保持工作，特别是不能保证每根电线和电脑都能正常工作。So，相反的，数据更不是以<strong>直接</strong>的方式在互联网上传播。</p><p>互联网上的<strong>信息</strong>从一台计算机<strong>传输</strong>到另一台计算机<strong>不需要遵循固定路径</strong>；事实上，它可能在传输过程中改变路径。这种信息传输以<strong>数据包</strong>的形式进行，这些数据包可能会根据<strong>某些因素</strong>遵循不同的路线，就像我们出门旅行，根据交通拥堵和道路状况选择不同的路线达到同一个地方。</p><p>而就像可以在一辆车中装在任意物品传送，许多种数据信息可以用IP包发送，但也有一些<strong>限制</strong>。比如，我们如何将航天飞机装载到卡车里，将其从建造地点移动到发射地点？显而易见，这是不可能的。所以要将它分解成碎片，用一组卡车运输，而它们都可以采取<strong>不同的路线</strong>并在<strong>不同的时间</strong>到达目的地，一旦所有部件都到达后，就可以重新组装完整的航天飞机并发射。</p><p>在<strong>互联网</strong>中，细节<strong>亦是如此</strong>。如果要将<strong>特别大</strong>的图像或视频上传到而网站或发送给朋友，它可能由数以万计的01比特组成，<strong>数量太大</strong>无法集中于一个包发送；由于是计算机上的数据，图像可快速<strong>分解</strong>为数百甚至数千个<strong>较小的部分</strong>，被称作<strong>数据包</strong>。</p><p>与卡车不同，这些数据包没有司机，也未选择路线。每个包仅有它的来源和去向的IP地址。而互联网上，被称作<strong>路由器</strong>的特殊机器就像交通管理者一样，使得数据包顺利通过网络；而若一条线路拥堵，个别数据包肯呢个通过互联网进入不同的线路；它们可能在不同的事件到达目的地，甚至出现故障。</p><p>作为互联网协议的一部分，每个路由器都用于<strong>跟踪发送数据包的多条路径</strong>，并且根据数据包目的IP地址<strong>为每个数据包选择</strong>最“便宜”的可用<strong>路径</strong>（在这里，便宜不是指价钱成本，而是时间和政治、公司之间的关系等非政治因素）。通常，数据传输的最佳路径并不一定是最直接的。<br>对路径有多种选择回使网络<strong>容错</strong>。换句话说，即时发生了什么可怕的错误，网络也能继续发送数据包；这就是互联网关键原则的基础：<strong>可靠性</strong>。</p><p>我们或许还会产生这样的疑问：如果我想请求部分数据而非全部数据呢？如果我想听一首歌如何确定所有数据100%被传输以便完美播放呢？答案是：<strong>传输控制协议（Transmission Control Protocol , TCP）</strong>。TCP以数据包的形式管理所有数据的接受与发送，类似于一个被管控&#x2F;保障着的邮件服务。<br>当你在计算机上请求一首歌曲时，发送端会将一首歌分解为多个数据包，当数据包到达，TCP会进行完整地清点并回复以确认收到每个数据包；若所有数据包都在那里，TCP会“签收”你的交付，你就成功收到了歌曲；相反的则不会签收，而对于每个不完整或丢失的数据包，TCP会去请求发送端重新发送它们。然后，TCP一旦验证了歌曲的数据包齐全，才会把数据交给应用层，歌曲才会开始播放；不然的话，歌曲不会进行播放而处于暂停状态。</p><p><strong>TCP和路由器系统(Router System)</strong> 的优点是它们是<strong>可扩展</strong>的，它们可以工作于8到80亿台设备。事实上，由于这些容错(tolerance)和冗余(redundancy)原则，添加的路由器越多，互联网就越可靠。更棒的是我们可以在不中断它服务的情况下增长和扩展互联网。</p><p>互联网由数十万个网络和数十亿台物理连接的计算机和设备组成，这些组成互联网的系统互相连接、互相通信并协同工作，皆因在互联网上传输数据的方式一致。<br>计算机设备或者网络上的路由器，帮助所有的数据包到达目的地，若有必要在那里重组。这种情况每天发生数以亿次，发送e-mail、浏览网页、视频会话、使用移动app、或互联网上的传感器或设备相互通信时，它都会发生。</p><h2 id="HTTP-HTML"><a href="#HTTP-HTML" class="headerlink" title="HTTP &amp; HTML"></a>HTTP &amp; HTML</h2><p>网页浏览</p><ul><li>打开Web浏览器，如：谷歌、火狐、IE等 —— 用来访问网页的应用</li><li>键入Web地址或URL(Uniform Resource Locator)，如：youtube.com —— 想访问的网站的同一资源定位器<br>在键入Enter后发生了什么，这就是我们所要讨论的。<br>在enter之后，我的计算机开始与被称作<strong>服务器</strong>的另一台计算机通话，距离通常数以千里。在几毫秒内，我的计算机向该服务器<strong>请求网站</strong>，然后服务器以称作<strong>HTTP</strong>的语言与我的计算机回话。</li></ul><p>**HTTP，HyperText Transfer Protocol(超文本传输协议)**，可以看作为一台计算机向另一台计算机索取文档的语言。并且实际上它及其简单。它主要由“Get”请求的东西组成，所以我们尝试登陆油管，就是向油管的服务器发送一个Get请求，上面写着get&#x2F;login；这告诉服务器我需要登陆界面的所有HTML代码。</p><p>所以HTML可以视为告诉Web浏览器如何<strong>做一个页面外观</strong>的语言。例如维基百科就是一个简单的大文档，HTML使它的字体成为正确的字体，使标题变大加粗，使一些文本斜体，链接，图像放在哪边等。</p><p><strong>网页文本</strong>是直接包含在HTML之中；但<strong>图像或视频</strong>等其他部分是<strong>具有自己需要的URL的独立文件</strong>的，浏览器向他们<strong>每一个发送单独请求</strong>并在它们到达时显示它们。也因此，我们在浏览一些具有许多不同图像的网站，会使网页加载速度减慢，因为每个图像产生一个单独的HTTP请求。</p><p>除了<strong>GET请求</strong>的页面，有时我们发送信息，如输入搜索查询，浏览器使用<strong>POST请求</strong>将此信息传输到Web服务器上。就比如登录一个网站，填写账户，密码，发送一个POST请求到服务器，服务器发现这是你，它再发送一个网页写着：Success: 登陆者为谁谁谁，但是除了网页之外，它还附加了一些不可见的<strong>cookie数据</strong>，浏览器可以看到并知道如何<strong>保存这些数据</strong>。这是网站记住你是谁的唯一方式，并且浏览器会保存你的号码，在下次刷新时，Web浏览器会自动知道将该ID号附加发送给服务器的请求中，也就是说：<u>服务器可以看到你的请求以及ID号，并且知道这是你的请求</u>。</p><p>由于互联网<strong>完全开放</strong>，且所有<strong>连接共享</strong>，和<strong>信息以纯文本的形式发送</strong>，黑客就有机会窥探到你通过互联网发送的任何个人信息。但是<strong>安全网站</strong>阻止了这一行为，通过要求Web浏览器使用安全套接字层<strong>Secure Sockets Layer</strong> and its succeccor传输层安全 <strong>Transport Layer Security</strong> 在安全通道进行通信。换句话说，SSL和TLS作为围绕通信的安全层保护它们免遭窥视及篡改。<br>当你看到浏览器地址栏显示HTTPS旁边的小索🔒时，SSL和TLS是活动的。<strong>HTTPS协议</strong>确保你的HTTP请求是安全的、受保护的。</p><p>当网站询问你的浏览器来进行安全链接，网站首先提供<strong>数字证书</strong>，就像官方身份证证明它是它声明的网站。<strong>数字证书由证书颁发机构发布</strong>，证书颁发机构是验证网站身份并为其颁发证书的受信任实体，就像政府颁发签证或护照。如果网站在没有证书的情况下启动安全连接，浏览器会发出警告。</p><p>总而言之，HTTP&amp;DNS管理HTML，媒体文件，或Web上任何内容的发送和接受。让着成为可能的是TCP&#x2F;IP和路由器网络，它们以小数据包的形式分解和传输信息。这些数据包本身由01序列(二进制序列)组成，并通过电线、光纤和无线网络物理上进行发送。</p><p>这些层将一起工作，以规模和可靠性先后传输信息。</p><h2 id="Encryption-Public-Keys"><a href="#Encryption-Public-Keys" class="headerlink" title="Encryption &amp; Public Keys"></a>Encryption &amp; Public Keys</h2><p>互联网是一个开放的公共系统，我们在共享的线路传输与接送信息，当然包括大量的私密数据，如：信用卡号码、账户信息、密码……</p><p>那么这些私人事物要如何保密？通过被称作<strong>加密(Encryption)</strong> 的程序：混乱或改变信息来隐藏原始内容，任何类型的数据得以保密；而<strong>解密(Decryption)</strong> 是一个重排的过程，得以让数据变得可读。</p><p>这种想法其实已有几个世纪了，一个经典的加密方法——【<strong>凯撒密码</strong>】最为人知。它以凯撒大帝命名，这位将军将军命令加密以确保被敌方拦截也无法被解读。</p><p><strong>凯撒密码</strong>的演算规律：将原文中每个字母，按顺序替换为向下一定间隔<strong>数量</strong>的字母。而这个数量只有信息的发送与接收者知道，即被称作“密钥”，它使接受者能够解开加密信息。<br>一个例子：</p><ul><li>原信息【HELLO】</li><li>使用凯撒密码方法加密，密钥是5</li><li>加密后信息【MJQQS】</li><li>而接收者只需将字母向上回滚(反转)密钥5个数就得到原信息</li></ul><p>但是这有一个大问题，在英文字母表中只有26个字母，这意味着<strong>只需尝试26个</strong>键就可得到解秘消息，也就是说破解加密信息太过容易。</p><p>所以一个改善版是：<u>将每个字母横移不同的数量，而不是固定的数量。</u>例如：利用10位长度的密钥加密信息(显示每个连续字母要哦更改的位置)</p><p><img src="/../assets/images/Harder_Encryption.png" alt="Harder_Encryption.png"></p><p>人要猜到这个密钥十分困难，因为使用10位加密，密钥就会由 $10^{10} &#x3D; 10$ 亿种不同的密钥组合。<br>但是对于当今普通计算机来说，这只需要几秒就可尝试100亿种不同的可能组合。所以怎样可以让它更困难已难以破解呢？（这里，<u>太困难指有太多的可能而无法在一个合理的时间被计算出来</u>）</p><p>现在的<strong>安全通信使用256位长度的密钥</strong>来加密，这表示：当坏人拦截了信息，他需要尝试多种可能的密钥才能找到正确的以破解信息。即时拥有100,000台超级计算机，要尝试100万亿可能的密钥。这也需要大概数十年的时间，才能穷尽。</p><p>当然，计算机芯片的速度每年翻倍增长（<strong>摩尔定律？</strong>）。如果这种指数级的发展速度持续下去，今天不能解决的问题将在未来的几百年解决，那么256位的密钥也<strong>不足</strong>以保证安全。<br>事实上，我们已经不得不增加标准密钥的长度来跟上计算机的速度。<br>好消息是，<u>增加密钥的长度不会使加密解密过程变得复杂，但他会成倍增加破解密码所需要的猜测次数。</u></p><p>当发送方与接收方使用<strong>相同的密钥</strong>对信息进行加密和解密，称作<strong>对称加密</strong>，例如：Caesar Cipher。这样密钥就需要两个人事先私下商定，这或许很好。但是互联网是开放的，所以两台计算机不会私下见面。所以，相反的，计算机间使用<strong>非对称密钥加密(Asymmetric encryption)<strong>，即：有一个</strong>公钥</strong>可以与任何人交换，而一个<strong>私钥</strong>不被共享。公钥用于加密数据，任何人都会使用它来创建一条秘密信息，但秘密数据只有具有私钥权力的计算机才能解密。<br>类比，就如同一个个人邮箱，任何人都有钥匙🔑来打开并将邮件存入邮箱，这个钥匙(公钥)可能被你复制多分寄给你的朋友也可以直接公开，So任何人都有可以利用公钥向你的邮箱发送消息。但是只有你自己拥有私钥打开邮箱，访问收到的所有秘密消息。当然你也可以通过你朋友的公钥将秘密消息发送到朋友的邮箱。这样，人们就不需要私钥达成一致的情况下才能安全地交换消息。</p><p><strong>公钥密码学</strong>是开放互联网上所有安全的消息传递的<strong>基础</strong>，包括<strong>SSL</strong>和<strong>TLS</strong>的安全协议，它们在我们浏览互联网的时候保护我们。现在，可以看看你进入的网站，只要在浏览器地址栏看到<strong>🔒或https</strong>，就意味着正在使用公钥加密与所在的网站安全的交换数据。</p><h2 id="Cybersecurity-and-Crime"><a href="#Cybersecurity-and-Crime" class="headerlink" title="Cybersecurity and Crime"></a>Cybersecurity and Crime</h2><p>不必多说，网络犯罪造成巨大的安全问题，不论个人、社会还是国家。信用卡密码被盗、社会安全号码和医疗记录被泄露、核离心机被入侵、无人机被劫持，这样的例子数不胜数。这些都是通过硬件或软件上的漏洞来实现的，或者更常见的，利用使用软件的人无意间做的决定实现的。</p><p>就像现在各个国家不仅需要正规的海陆军，而且拥有一支精良的网络军队。事实上，接下来的战争很多都是信息战，往往不是传统武器，而是入侵他国系统以切断供水、能源网络和运输系统。</p><p>这也是为什么网络安全如此重要的原因之一。</p><p>让我们来看看<strong>网络犯罪</strong>是如何运作的？</p><ul><li><strong>SoftWare viruses(VIRUSES) - 软件病毒</strong></li><li><strong>denial-of-service attacks(DDoS) -拒绝服务攻击</strong></li><li><strong>phishing sacms(PHISHING) - 钓鱼诈骗</strong></li></ul><p>病毒的工作原理类似于生物学上的病毒，它是一种可执行程序，通常被无意安装，会伤害用户和他们的计算机。那么病毒是如何进入我们的电脑呢？</p><p>攻击者可能通过下面几种方式：</p><ul><li>诱使受害者安装一个程序，通常被伪装来欺骗使用者。如：病毒被伪装为安全更新；</li><li>或者电脑上的软件带有漏洞，所以攻击者可以使病毒在不需要许可的情况下自行安装。</li></ul><p>病毒一旦进入计算机，就可以窃取或删除你的文件、控制其他程序，甚至允许其他人远程控制计算机。</p><p>利用计算机病毒，黑客或可以占领全球数百万台计算机，然后利用它们作为数字大军即：僵尸网络，攻击和摧毁网站，这种攻击就被成为**分布式拒绝服务(DDoS)**。</p><p><strong>拒绝服务攻击</strong>是指黑客使用过多的请求淹没一个网站，而当攻击同时来自多台计算机，就被称为<strong>分布式拒绝服务攻击</strong>。</p><p>大多数网站已经准备好每天响应<strong>数百万</strong>个请求。但是如果从不同地方向它们发送<strong>数十亿或数万亿</strong>的请求，计算机就会<strong>过载并停止响应</strong>。</p><p>另一个惯用伎俩是<strong>发送大量垃圾邮件</strong>，试图欺骗人们分享敏感的个人信息。这被称作<strong>网络钓鱼诈骗</strong>。它是当你收到一封看似可信的邮件，要求你登陆你的账户，但点击这封邮件，他把你带到一个虚假的网站，不论如何，只要你登陆了网站，密码就会泄露出去。黑客可以使用你的登录凭证来访问你的真实账户，窃取信息甚至💴。</p><h5 id="More-reading-卡通介绍-DNS-over-HTTPS"><a href="#More-reading-卡通介绍-DNS-over-HTTPS" class="headerlink" title="More reading : 卡通介绍 DNS over HTTPS"></a>More reading : <a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/">卡通介绍 DNS over HTTPS</a></h5>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子非鱼，安知鱼之乐</title>
      <link href="/2024/10/22/%E5%AD%90%E9%9D%9E%E9%B1%BC%EF%BC%8C%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B9%8B%E4%B9%90/"/>
      <url>/2024/10/22/%E5%AD%90%E9%9D%9E%E9%B1%BC%EF%BC%8C%E5%AE%89%E7%9F%A5%E9%B1%BC%E4%B9%8B%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h1 id="子非鱼，安知鱼之乐"><a href="#子非鱼，安知鱼之乐" class="headerlink" title="子非鱼，安知鱼之乐"></a>子非鱼，安知鱼之乐</h1><p>——所谓的“开心”，就是要打开第一人称、主观主义的执念，对于心灵的束缚，就能获得快乐。</p><blockquote><p>正题：子【非】鱼，安知鱼之乐？</p><p>反题：子【非】我，安知我不知？</p><p>庸俗：我不知子，子不知鱼，“全矣。”</p><p>合题：子非鱼，【安】知鱼之乐？（我知之濠上也）</p><p>濠——鱼——子——我</p><p>在庄子看来是平等的</p><p>“乐”可以穿梭其中</p></blockquote><p>这是一个比较经典的辩题</p><p>正题就是惠施，听到庄子说，“鱼好快乐”，他就问：“子非鱼，安知鱼之乐？”——你不是鱼，你怎么知道鱼的快乐？</p><p>庄子条件反射、自我保护式地就反题反驳了一下说，“子非我，安知我不知鱼之乐？”——你不是我，你怎么知道我不知道呢？</p><p>惠施就很聪明了，通过庸俗的辩证法搞了个合题，就是把两个东西拼到一块说什么，“我固非子”——我不是你，我肯定不知道你怎么想的；你也不是鱼，所以你也不知道鱼怎么想的。</p><p>这两个东西加到一块，“全矣。”——整体主义的虚假的辩证法：“全矣。”这两个加在一块就整全了。实际上这种庸俗的辩证法它就是把两个答案拼到一块去，说这两种情况都包含所以就行了，那么就会导致一种主观主义。背后就是说，我不是你，你也不是鱼，所以你都不能知道另外一个对象它内在的感觉就是所谓的快乐。这就导致一种，快乐就变成一个你必须、你只能通过你的第一人称、通过内心才能够知觉察觉到的一个东西。</p><p>那么庄子是怎么来解决这个问题的？他把重音、真正的辩证法转移到 <strong>安</strong> 字上面，<strong>哪里</strong>知道——“子非鱼，<strong>安</strong> 知鱼之乐？”——你问的是 <strong>安</strong> 知鱼之乐，“你是从 <strong>哪里</strong> 知道鱼的快乐？”你的意思就是说，你已经承认我知道鱼的快乐，但是你只不过是不知道它是从哪里被知道的。</p><p>这个其实就动摇了惠施一开始立论的基础。惠施立论的基础就是说知觉这个行为只能通过内心、只能通过第一人称、只能通过非常狭隘的自我意识内部才能够发生，特别是对于快乐的知觉。但是在庄子看来，这个场所不是限制在第一人称内在的，不是限制在你的意识内部的。所以他说“我知之濠上也”——你问我哪里知道的，我是从这座桥上面知道的。从濠水上面这座桥上面知道的。</p><p>所以在庄子看来，快乐这种“内在”的体验它不是内在的、第一人称所独有的一种体验。不是说你一定要成为那个快乐的心灵本身，你占据它的第一人称的视角，你才能体验到快乐。不是这样你才能认识到快乐。在他看来，比如说濠水、鱼、你、我、我的内心；你的内心、鱼、还有濠水——濠水甚至它是一个非生命的东西，鱼是动物，“子”是他人，“我”就是我的内心——在庄子看来，这些东西是平等的。所有这些东西都可以成为所谓的“乐”它发生的一个场域、它被知觉到的一个场域。所以他回答说，“我知之濠上也。”</p><p>这个回答比那些庸俗的“我是看到鱼活蹦乱跳，所以我知道它快乐”要高明很多，因为他把矩阵给拉长了。它并不是因为鱼和我有共同点，我们都是动物所以我知道——不是的。他是直接说了，知道快乐这是不限制于任何事物的。有生命、无生命都是可以发生快乐的一个场域。</p><h2 id="note-part"><a href="#note-part" class="headerlink" title="note part"></a>note part</h2><blockquote><p>庄子与惠子游于濠梁之上。</p><p>庄子曰：“鲦鱼出游从容，是鱼乐也。”</p><p>惠子曰：“子非鱼，安知鱼之乐？”</p><p>庄子曰：“子非我，安知我不知鱼之乐？”</p><p>惠子曰：“我非子，固不知子矣，子固非鱼也，子不知鱼之乐，全矣。”庄子曰：“请循其本。子曰汝安知鱼乐云者，既已知吾知之而问我，我知之濠上也。</p></blockquote><p>子非鱼，<strong>安</strong> 知鱼之乐。</p><p>子非我，安知我知鱼之乐</p><blockquote><p>错误的理解：</p><p>主观主义：你都不能知道另外一个对象的感觉。</p></blockquote><p><strong>安</strong>，不应当解为“怎么”，而应当解为“从哪里”。</p><blockquote><p>濠水、你、我、鱼，在庄子看来都是平等的，都是“乐”发生的场域。</p></blockquote><blockquote><p>知道快乐，是不限制于任何事物的。</p></blockquote><p>评：</p><p>这段本质上是对于语言的抨击，正如名可名，非常名是一回事。我站在濠上看到了鱼游的很开心，是透过表象的动作去猜测的。而惠子知道庄子知道鱼很快乐，是通过庄子的语言确认的，然而语言也同样是一种表象的东西。所以当惠子问出，子非鱼，安知鱼之乐的时候，就已经代表着他和庄子做了同样的事情，即认可了透过表象去猜测。所以，庄子说，请循其本 ，我是在桥上看到的，你是听到的，我们之间没有什么不同，除非你否定你问的这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辩证法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习随记</title>
      <link href="/2024/10/22/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E8%AE%B0/"/>
      <url>/2024/10/22/C%E8%AF%AD%E8%A8%80%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一-结构体、枚举与联合-Structure-Enumeration-Union"><a href="#一-结构体、枚举与联合-Structure-Enumeration-Union" class="headerlink" title="一.结构体、枚举与联合(Structure,Enumeration &amp; Union)"></a>一.结构体、枚举与联合(Structure,Enumeration &amp; Union)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举Enumeration </span></span><br><span class="line"><span class="comment">// 可替代多个#define</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合Union</span></span><br><span class="line"><span class="comment">// 它允许在相同的内存位置存储不同的数据类型。</span></span><br><span class="line"><span class="comment">// 联合体的所有成员共享一块内存空间，大小等于其最大成员的大小。</span></span><br><span class="line"><span class="comment">// 这就意味着在任一时刻，联合体只能存储一个成员的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个变量可能存储多种类型的数据，但是在一个给定时刻里，只是用其中一种的数据类型，这样可以节省内存。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> int_value;</span><br><span class="line">    <span class="type">float</span> float_value;</span><br><span class="line">    <span class="type">char</span>* string_value;</span><br><span class="line">&#125; Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    INT,</span><br><span class="line">    FLOAT,</span><br><span class="line">    STRING</span><br><span class="line">&#125; DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType type;</span><br><span class="line">    Data data;</span><br><span class="line">&#125; TypedData;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_data</span><span class="params">(TypedData* typed_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(typed_data-&gt;type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> INT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Integer: %d\n&quot;</span>,typed_data-&gt;data.int_value);;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLOAT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>,typed_data-&gt;data.float_value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STRING:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;String: %s\n&quot;</span>,typed_data-&gt;data.string_value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现了三者的联用。自己定义一个类型，并按照不同类型去输出；也就是说我想要什么类型就可以做出什么类型，十分灵活。</span></span><br><span class="line"><span class="comment">// Union可以存储不同的数据类型，那我们可以通过这种方式来去控制它什么时候是什么类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TypedData data1 = &#123;INT,&#123;.int_value = <span class="number">10</span>&#125;&#125;; <span class="comment">//我们.这样的写法意思就是它自己data.···</span></span><br><span class="line">    </span><br><span class="line">    TypedData data2 = &#123;FLOAT,&#123;.float_value = <span class="number">3.14</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    TypedData data3 = &#123;INT,&#123;.string_value = <span class="string">&quot;Hello,Chaos!&quot;</span>&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">    print_data(&amp;data1);</span><br><span class="line">    print_data(&amp;data2);</span><br><span class="line">    print_data(&amp;data3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-VS编译器捕获字符串异常的简单方法"><a href="#二-VS编译器捕获字符串异常的简单方法" class="headerlink" title="二.VS编译器捕获字符串异常的简单方法"></a>二.VS编译器捕获字符串异常的简单方法</h3><h4 id="Release方式运行"><a href="#Release方式运行" class="headerlink" title="Release方式运行"></a>Release方式运行</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_invalid_pram_handler</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* expression,<span class="type">const</span> <span class="type">wchar_t</span>* function,<span class="type">const</span> <span class="type">wchar_t</span>* file,<span class="type">unsigned</span> <span class="type">int</span> line,<span class="type">uimtptr_t</span> p_reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">    wprintf(<span class="string">L&quot;Invalid parameter detected in function %s. File: %s Line %d\n&quot;</span>,function,file,line);</span><br><span class="line">    wprintf(<span class="string">L&quot;Expression: %s\n&quot;</span>,expression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _set_invalid_parameter_handler(my_invalid_parm_handler);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> src[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> dest[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">erron_t</span> err = strcpy_s(dest,<span class="keyword">sizeof</span>(dest),src); <span class="comment">// strcpy_s有一个返回值叫作errno_t，实际上是个int整形</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error copying string. Error code: %d\n&quot;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,dest);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-字符串函数"><a href="#三-字符串函数" class="headerlink" title="三.字符串函数"></a>三.字符串函数</h3><h4 id="非法字符匹配"><a href="#非法字符匹配" class="headerlink" title="非法字符匹配"></a>非法字符匹配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证一个字符串是否有非法的那些字符(重命名)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> input[] = <span class="string">&quot;filename.txt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> invalid_chars[] = <span class="string">&quot;/\\:*?\&quot;&lt;&gt;|&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcspn</span>(input,invalid_chars) &lt; <span class="built_in">strlen</span>(input))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input contains invalid characters.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input is valid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数案例"><a href="#常用函数案例" class="headerlink" title="常用函数案例"></a>常用函数案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORD_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELIMS <span class="string">&quot;,.!?\n &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">replaceWord</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* oldWord, <span class="type">const</span> <span class="type">char</span>* newWord, <span class="type">char</span>* result)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">countChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">char</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">countWords</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extractUniqueWords</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">char</span> uniqueWords[][WORD_SIZE], <span class="type">int</span>* uniqueCount)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> text[TEXT_SIZE] = <span class="string">&quot;This is a simple text.This text is for texting.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> replacedText[TEXT_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> oldWord[] = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">    <span class="type">char</span> newWord[] = <span class="string">&quot;example&quot;</span>;</span><br><span class="line">    <span class="type">char</span> countCharTarget = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> uniqueWords[TEXT_SIZE][WORD_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> uniqueCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    replaceWord(text, oldWord, newWord, replacedText);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repaced Text : %s\n&quot;</span>, replacedText);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> charCount = countChar(replacedText, countCharTarget);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Character &#x27;%c&#x27; appears %d times.\n&quot;</span>, countCharTarget, charCount);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> wordCount = countWords(replacedText);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total number of words: %d\n&quot;</span>, wordCount);</span><br><span class="line"></span><br><span class="line">    extractUniqueWords(replacedText, uniqueWords, &amp;uniqueCount);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Unique words:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; uniqueCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, uniqueWords[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">replaceWord</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">const</span> <span class="type">char</span>* oldWord, <span class="type">const</span> <span class="type">char</span>* newWord, <span class="type">char</span>* result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[TEXT_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pos = text;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* temp = text;</span><br><span class="line">    <span class="type">size_t</span> oldlen = <span class="built_in">strlen</span>(oldWord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((temp = <span class="built_in">strstr</span>(pos, oldWord)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        strncat_s(buffer, <span class="keyword">sizeof</span>(buffer), pos, temp - pos);</span><br><span class="line">        strcat_s(buffer, <span class="keyword">sizeof</span>(buffer), newWord);</span><br><span class="line"></span><br><span class="line">        pos = temp + oldlen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strcat_s(buffer, <span class="keyword">sizeof</span>(buffer), pos);</span><br><span class="line">    strcpy_s(result, TEXT_SIZE, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">char</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*text)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*text == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        text++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countWords</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buffer[TEXT_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    strcpy_s(buffer, TEXT_SIZE, text);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* context = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = strtok_s(buffer, DELIMS, &amp;context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        token = strtok_s(<span class="literal">NULL</span>, DELIMS, &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">extractUniqueWords</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* text, <span class="type">char</span> uniqueWords[][WORD_SIZE], <span class="type">int</span>* uniqueCount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tempText[TEXT_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    strcpy_s(tempText, TEXT_SIZE, text);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* context = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* token = strtok_s(tempText, DELIMS, &amp;context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; *uniqueCount; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(token, uniqueWords[j]) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            strcpy_s(uniqueWords[*uniqueCount], WORD_SIZE, token);</span><br><span class="line">            (*uniqueCount)++;</span><br><span class="line">        &#125;</span><br><span class="line">        token = strtok_s(<span class="literal">NULL</span>, DELIMS, &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-文件"><a href="#四-文件" class="headerlink" title="四.文件"></a>四.文件</h3><h4 id="安全读取，追加，清空文件-更新文件"><a href="#安全读取，追加，清空文件-更新文件" class="headerlink" title="安全读取，追加，清空文件 + 更新文件"></a>安全读取，追加，清空文件 + 更新文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全读取配置文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_config_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br><span class="line"><span class="comment">// 安全追加日志文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">append_log_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* msg)</span>;</span><br><span class="line"><span class="comment">// 清空日志文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br><span class="line"><span class="comment">// 安全更新日志记录</span></span><br><span class="line"><span class="type">errno_t</span> <span class="title function_">update_log_record_s</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filrname, <span class="type">const</span> <span class="type">char</span>* search_str, <span class="type">const</span> <span class="type">char</span>* replace_str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// const char* config_filename = &quot;D:\\Desktop\\game_config.txt&quot;;</span></span><br><span class="line"><span class="comment">// const char* log_filename = &quot;D:\\Desktop\\log.txt&quot;;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* log_file = <span class="string">&quot;D:\\Desktop\\chaos.log&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* search_str = <span class="string">&quot;Memory usage exceeds 80% of available memory.&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* replace_str = <span class="string">&quot;[2024-08-20T01:01:00Z] [INFO] Memory usage id back to normal levels&quot;</span>;</span><br><span class="line"><span class="comment">// read_config_safe(config_filename);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* str = &quot;select * from student&quot;;</span></span><br><span class="line"><span class="comment">// append_log_safe(log_filename,str);</span></span><br><span class="line"><span class="type">errno_t</span> result = update_log_record_s(log_file,search_str,replace_str);</span><br><span class="line"><span class="comment">// clear_log(log_filename);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> error_msg[<span class="number">256</span>];</span><br><span class="line">strerror_s(error_msg, <span class="keyword">sizeof</span>(error_msg), errno);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;An error occuered: %s\n&quot;</span>, error_msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Record updated successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">_fcloseall();</span><br><span class="line"><span class="comment">// 确保文件流全部关闭</span></span><br><span class="line"><span class="comment">// int numclosed = _fcolseall();</span></span><br><span class="line"><span class="comment">// printf(&quot;Number of files closed by _fclosed: %u\n&quot;, numclosed);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_config_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* file_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file_ptr, filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || file_ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> error_msg[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 把错误消息保存到字符串(缓冲区)</span></span><br><span class="line">strerror_s(error_msg,<span class="keyword">sizeof</span>(error_msg),errno);</span><br><span class="line"><span class="comment">// 把缓冲区(错误信息)放到标准输出stderr上，弹窗警告</span></span><br><span class="line"><span class="comment">// 当然也不一定是输出在屏幕，所以不能简单的利用printf处理</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open config file for reading: %s\n&quot;</span>, error_msg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">while</span> (fgets(buffer,<span class="keyword">sizeof</span>(buffer),file_ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(file_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> append_log_safe(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">const</span> <span class="type">char</span>* msg)</span><br><span class="line">&#123;</span><br><span class="line">FILE* file_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file_ptr, filename, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || file_ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> error_msg[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 把错误消息保存到字符串(缓冲区)</span></span><br><span class="line">strerror_s(error_msg, <span class="keyword">sizeof</span>(error_msg), errno);</span><br><span class="line"><span class="comment">// 把缓冲区(错误信息)放到标准输出stderr上，弹窗警告</span></span><br><span class="line"><span class="comment">// 当然也不一定是输出在屏幕，所以不能简单的利用printf处理</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open log file for appending: %s\n&quot;</span>, error_msg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(file_ptr, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">fclose(file_ptr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> clear_log(<span class="type">const</span> <span class="type">char</span>* filename)</span><br><span class="line">&#123;</span><br><span class="line">FILE* file_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file_ptr, filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || file_ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> error_msg[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 把错误消息保存到字符串(缓冲区)</span></span><br><span class="line">strerror_s(error_msg, <span class="keyword">sizeof</span>(error_msg), errno);</span><br><span class="line"><span class="comment">// 把缓冲区(错误信息)放到标准输出stderr上，弹窗警告</span></span><br><span class="line"><span class="comment">// 当然也不一定是输出在屏幕，所以不能简单的利用printf处理</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open log file for writing: %s\n&quot;</span>, error_msg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文件已经打开为&quot;w&quot;模式，不进行其他操作，文件被清空，无需写入。</span></span><br><span class="line"></span><br><span class="line">fclose(filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> update_log_record_s(<span class="type">const</span> <span class="type">char</span>* filrname, <span class="type">const</span> <span class="type">char</span>* search_str, <span class="type">const</span> <span class="type">char</span>* replace_str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (filename == <span class="literal">NULL</span> || search_str == <span class="literal">NULL</span> || replace_str == <span class="literal">NULL</span>) <span class="keyword">return</span> EINVAL; <span class="comment">// 返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">FILE* file_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file_ptr, filename, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || file_ptr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> error_msg[<span class="number">256</span>];</span><br><span class="line"><span class="comment">// 把错误消息保存到字符串(缓冲区)</span></span><br><span class="line">strerror_s(error_msg, <span class="keyword">sizeof</span>(error_msg), errno);</span><br><span class="line"><span class="comment">// 把缓冲区(错误信息)放到标准输出stderr上，弹窗警告</span></span><br><span class="line"><span class="comment">// 当然也不一定是输出在屏幕，所以不能简单的利用printf处理</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open log file for reading+: %s\n&quot;</span>, error_msg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file_ptr) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(buffer, search_str) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">found = <span class="number">1</span>;</span><br><span class="line">position = ftell(file_ptr) - (<span class="type">long</span>)<span class="built_in">strlen</span>(buffer) - <span class="number">1</span>; <span class="comment">// -1确保从行首开始替换</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 找到第一个匹配项，立刻停止</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (found)</span><br><span class="line">&#123;</span><br><span class="line">fseek(file_ptr, position, SEEK_SET);<span class="comment">// 移动回到找到记录的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算原文本和替换文本的长度差异</span></span><br><span class="line"><span class="type">size_t</span> replace_len = <span class="built_in">strlen</span>(replace_str);</span><br><span class="line"><span class="type">size_t</span> search_len = <span class="built_in">strlen</span>(search_str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replace_len &gt; BUFFER_SIZE - <span class="number">1</span> || search_len &gt; BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fclose(file_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERANGE; <span class="comment">// 返回错误码，表示字符串长度超出范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入新数据前，清楚所在位置的行数据</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="string">&#x27; &#x27;</span>, <span class="built_in">strlen</span>(buffer) - <span class="number">1</span>); <span class="comment">// 用空格填充，保持文件大小不变</span></span><br><span class="line"></span><br><span class="line">buffer[<span class="built_in">strlen</span>(buffer) - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;<span class="comment">// 保留换行符</span></span><br><span class="line"></span><br><span class="line">fseek(file_ptr, position, SEEK_SET);<span class="comment">// 重新回到标记行的开始</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(buffer, file_ptr);<span class="comment">// 清除原来行的内容</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">fputs</span>(replace_str, file_ptr);<span class="comment">// 写入替换的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == EOF)</span><br><span class="line">&#123;</span><br><span class="line">fclose(file_ptr);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char error_msg[256];</span></span><br><span class="line"><span class="comment">// 把错误消息保存到字符串(缓冲区)</span></span><br><span class="line"><span class="comment">strerror_s(error_msg, sizeof(error_msg), errno);</span></span><br><span class="line"><span class="comment">// 把缓冲区(错误信息)放到标准输出stderr上，弹窗警告</span></span><br><span class="line"><span class="comment">// 当然也不一定是输出在屏幕，所以不能简单的利用printf处理</span></span><br><span class="line"><span class="comment">fprintf(stderr, &quot;Failed to open config file for reading: %s&quot;, error_msg);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"><span class="keyword">return</span> errno;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fclose(file_ptr);</span><br><span class="line"><span class="keyword">return</span> ENOENT;<span class="comment">// 返回未找到匹配项</span></span><br><span class="line">&#125;</span><br><span class="line">fclose(file_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h4><ul><li><p>立刻刷新缓冲区</p></li><li><p>单线程：错误日志</p></li><li><p>多线程</p></li></ul><h4 id="二进制文件操作"><a href="#二进制文件操作" class="headerlink" title="二进制文件操作"></a>二进制文件操作</h4><h5 id="游戏设置小案例"><a href="#游戏设置小案例" class="headerlink" title="游戏设置小案例"></a>游戏设置小案例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GameSettings</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">float</span> volume;</span><br><span class="line"><span class="type">int</span> resolution_x;</span><br><span class="line"><span class="type">int</span> resolution_y;</span><br><span class="line"><span class="type">int</span> difficulty;</span><br><span class="line">&#125;GameSettings;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_game_settings</span><span class="params">(<span class="type">const</span> GameSettings* settings, <span class="type">const</span> <span class="type">char</span>* filename)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">load_game_settings</span><span class="params">(<span class="type">const</span> GameSettings* settings, <span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// fread fwrite</span></span><br><span class="line"><span class="comment">// 读写二进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GameSettings settings = &#123;0.75,1920,1080,1&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">save_game_settings(&amp;settings, &quot;D:\\Desktop\\game_settings.bin&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">GameSettings loaded_settings;</span><br><span class="line"></span><br><span class="line">load_game_settings(&amp;loaded_settings，<span class="string">&quot;D:\\Desktop\\game_settings.bin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;游戏设置已加载! \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;音量: %f\n&quot;</span>, loaded_settings.volume);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分辨率: %dx%d\n&quot;</span>, loaded_settings.resolution_x,loaded_settings.resolution_y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;难度: %d\n&quot;</span>, loaded_settings.difficulty);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_game_settings</span><span class="params">(<span class="type">const</span> GameSettings* settings, <span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* file;</span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file, filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || filename == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;无法打开文件进行写入操作&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fwrite(settings, <span class="keyword">sizeof</span>(GameSettings), <span class="number">1</span>, file);</span><br><span class="line"></span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_game_settings</span><span class="params">(<span class="type">const</span> GameSettings* settings, <span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* file;</span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;file, filename, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || filename == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;无法打开文件进行读取操作&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fread(settings, <span class="keyword">sizeof</span>(GameSettings), <span class="number">1</span>, file);</span><br><span class="line"></span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="文件复制"><a href="#文件复制" class="headerlink" title="文件复制"></a>文件复制</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* source_file, * target_file;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> source_path[] = <span class="string">&quot;D:\\Desktop\\chaos.txt&quot;</span>;</span><br><span class="line"><span class="type">char</span> target_path[] = <span class="string">&quot;D:\\Desktop\\chaos-copy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line"><span class="type">errno_t</span> err = fopen_s(&amp;source_file, source_path, <span class="string">&quot;rb&quot;</span>）;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || source_file == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;无法打开源文件&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = fopen_s(&amp;target_file, target_path, <span class="string">&quot;wb&quot;</span>）;</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span> || target_file == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;无法打开目标文件&quot;</span>);</span><br><span class="line">fclose(source_file);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((bytes_read = fread(buffer,<span class="number">1</span>,<span class="keyword">sizeof</span>(buffer),</span><br><span class="line">source_file)) &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">fwrite(buffer, <span class="number">1</span>, bytes_read, target_file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_fcloseall();</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;文件复制完成!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-math-h"><a href="#五-math-h" class="headerlink" title="五.math.h"></a>五.math.h</h3><h4 id="对于math类别的错误处理"><a href="#对于math类别的错误处理" class="headerlink" title="对于math类别的错误处理"></a>对于math类别的错误处理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS <span class="comment">// 允许使用 C语言 中非安全的函数，忽略报错</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> number = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字以计算其平方根: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;number);</span><br><span class="line"></span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">sqrt</span>(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 sqrt 是否出错 (只列举了一部分)</span></span><br><span class="line"><span class="keyword">if</span> (errno == EDOM)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误: 输入值为负数，无法计算其平方根!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (errno == ERANGE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误: 结果超出范围!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (errno == HUGE_VAL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;错误: 结果超出范围!返回 HUGE_VAL!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数字 %.2f的平方根为：%.2f\n&quot;</span>, number,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于刷题日志的说明</title>
      <link href="/2024/10/22/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/"/>
      <url>/2024/10/22/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="一则通知"><a href="#一则通知" class="headerlink" title="一则通知"></a>一则通知</h2><h4 id="本小站不再进行刷题日志的的更新，之前的日志也全部删除😭😭😭"><a href="#本小站不再进行刷题日志的的更新，之前的日志也全部删除😭😭😭" class="headerlink" title="本小站不再进行刷题日志的的更新，之前的日志也全部删除😭😭😭"></a>本小站不再进行刷题日志的的更新，之前的日志也全部删除😭😭😭</h4><h4 id="如有需要，可前往🚀GitHub我的主页可查找到我的刷题日志🍩🍩🍩"><a href="#如有需要，可前往🚀GitHub我的主页可查找到我的刷题日志🍩🍩🍩" class="headerlink" title="如有需要，可前往🚀GitHub我的主页可查找到我的刷题日志🍩🍩🍩"></a>如有需要，可前往🚀GitHub我的主页可查找到我的刷题日志🍩🍩🍩</h4><h4 id="里面包含了我做过的题目中对我有所帮助的💕💕💕"><a href="#里面包含了我做过的题目中对我有所帮助的💕💕💕" class="headerlink" title="里面包含了我做过的题目中对我有所帮助的💕💕💕"></a>里面包含了我做过的题目中对我有所帮助的💕💕💕</h4><h4 id="🎈由此进入：Algorithm-Problem🎈"><a href="#🎈由此进入：Algorithm-Problem🎈" class="headerlink" title="🎈由此进入：Algorithm-Problem🎈"></a>🎈由此进入：<a href="https://github.com/lvjianchaos/Algorithm-Problem/tree/main">Algorithm-Problem</a>🎈</h4><h2 id="🙇‍非常感谢！❤❤❤"><a href="#🙇‍非常感谢！❤❤❤" class="headerlink" title="🙇‍非常感谢！❤❤❤"></a>🙇‍非常感谢！❤❤❤</h2><h1 id="END！🚀🚀🚀"><a href="#END！🚀🚀🚀" class="headerlink" title="END！🚀🚀🚀"></a>END！🚀🚀🚀</h1>]]></content>
      
      
      <categories>
          
          <category> 刷题日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量名命名的艺术</title>
      <link href="/2024/10/22/%E5%8F%98%E9%87%8F%E5%90%8D%E5%91%BD%E5%90%8D%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2024/10/22/%E5%8F%98%E9%87%8F%E5%90%8D%E5%91%BD%E5%90%8D%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Art-of-Naming-the-Variable-Names"><a href="#The-Art-of-Naming-the-Variable-Names" class="headerlink" title="The Art of Naming the Variable Names"></a>The Art of Naming the Variable Names</h1><h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>身为IT行业的小白，我们不能仅仅沉浸于代码语言的层次上或算法与数据结构的快感中，我们应该思考：但在这些基本都搞定了呢！？我们又该何去何从？</p><p>实际上，最高深的层次往往不是代码的算法与数据结构的构建本身，而是<strong>编程的艺术</strong>。一些大师级别的人物，他们在谈到编程或软件构建上绝不仅停留在代码、语言、算法和数据结构上，而是提升到一个极高的层次——编程的艺术。也就是说：思维和艺术将会决定你写代码的高度。</p><p>而编程的艺术其中一个重要的点便是——<strong>变量名命名</strong>。</p><h3 id="变量名命名的重要性"><a href="#变量名命名的重要性" class="headerlink" title="变量名命名的重要性"></a>变量名命名的重要性</h3><p>变量名真正的命名往往直接决定软件构建的效果、代码的性能，甚至可能影响到软件的安全和效益，以及所出现的问题一半都可能源于变量名命名。</p><p><strong>我们为何如是说呢？</strong><u>“一个好的变量名命名不是一个即时的效果，而是一个长期的效益。”</u>一个例子：我们设想下列情景：</p><p>（1）我养了一只狗🐕，它叫小黑，小黑死去之后，我又养了一只叫小白的狗🐕；这样并无问题，我们都能分清楚。</p><p>（2）可是，如果我养了10000只<strong>不同</strong>（这里说不同只是方便假设，因为这里不能用数组，而是无联系的10000个变量）的鸡，那么一万只鸡我该是这样命名吗？：a,b,c,d…aa,ab,………当第二天我们说<code>鸡chicken</code>下蛋了，那么<code>鸡chicken</code>是谁呢？我们还能搞清吗？所以说变量名命名的方式直接决定变量名的所带来的后果&#x2F;效果。<strong>没有好的变量名命名，会导致程序难以理解和维护</strong>。</p><p>变量名命名的规范</p><p><strong>我们这里以C语言来进行代码部分的编写，以进行具体阐释。</strong></p><p>关于常见的<strong>错误命名</strong>(🔺注意：这是在具有实际开发情景下的代码，不是无实际意义的语法展示示例)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 不明所以，不知其意</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ss = s1 + s2;</span><br><span class="line">    </span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fff</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">havesex</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">qian</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些<strong>规范示范</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> balance = <span class="number">100.00</span>;</span><br><span class="line">    <span class="comment">// double a = 100.00; X错；如果使用这样的代码，过一段时间后，当回看代码时，你还会知道a是余额的意思吗？</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_leap_year</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO==》 意思是:这里还有代码要写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，这是下划线命名，有些命名是使用驼峰命名法，这异曲同工：bool isLeapYear(int year)&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们很容易发现，<strong>不同的变量名命名直接会导致阅读体验的分野</strong>。</p><p>而一个标准规范的变量名命名应具备什么样的<strong>特质</strong>呢？</p><p><strong>可读性好、便于记忆、见名知意</strong>；或者更直白的说：一眼就可以看出这是在干什么。我们应心怀这样一句话去命名变量——<u>“优秀的代码命名都是自解释的”</u>。</p><p>仍是上述的例子：<code>判断是否为闰年</code> -<code>is_leap_year()</code>，(关于为何不用中文拼音命名而采用英语命名，这是由语言自身和历史传统影响的，这里不做阐释)，我们能否将其改为<code>is_leap()</code>呢？不能。<code>leap</code>还有跳跃之意，若是如此命名，必会造成歧义；而一个<strong>好的变量或函数名应准确表达含义</strong>，便于阅读与理解。</p><h3 id="变量名命名的注意"><a href="#变量名命名的注意" class="headerlink" title="变量名命名的注意"></a>变量名命名的注意</h3><p>但是，准确表达含义并不是要求名字严格按照英文使其变得<strong>特别长</strong>。举个例子，我们定义一个变量<code>unsigned int the_max_country_number_of_the_olympic_team = 20</code>；如此定义变量名，我们一定会理解这样的变量是何种意思，但我们不难发现这样的问题：太长了！长到难以使用了！所以说，长度问题也是变量名的一个重要问题；如何<strong>对变量名的长度和完整性进行取舍</strong>，这是我们亟需掌握的能力。</p><p>上述论断中，我们认识到一个优秀的变量名可以使人“一眼就可以看出这是在干什么”，也就是说<strong>给予人最最直观的体验</strong>。所以说，一些变量名往往<strong>以动词开头</strong>，如：<code>double  checkTotal(User user)&#123;return 0.00;&#125;</code>；但是一些诸如<code>double CHECK(User user)&#123;return 0.00&#125;</code>、<code>double checks(User user)&#123;return 0.00&#125;</code>、<code>double havemoney()&#123;&#125;</code>是不合常识与规范的。</p><p>这里，我们写一些好的<strong>变量名命名</strong>(<u>驼峰命名法</u>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于速度</span></span><br><span class="line"><span class="type">double</span> trainVelocity = <span class="number">310.25</span>;<span class="comment">// 高铁运行时速(km/h)</span></span><br><span class="line"><span class="type">double</span> velocityInMph = ;<span class="comment">//</span></span><br><span class="line"><span class="comment">// 关于日期</span></span><br><span class="line">Date currentDate = ;</span><br><span class="line"><span class="comment">// 一些行号</span></span><br><span class="line"><span class="type">int</span> lines;</span><br><span class="line"><span class="type">int</span> linesPerPage;<span class="comment">// 每一页的行数</span></span><br></pre></td></tr></table></figure><p>一个小结：我们的首要认识——变量名命名十分重要，乃至直接决定着我们代码的质量、性能；甚至如果我们的变量命名是有问题的，那么我们的项目到最后总是难以重构与维护。可谓说问题之大了。</p><p>我们不妨看看一些著名的项目如Linux的源码，向大师级别的人物学习。</p><h2 id="二、更为恰当地命名"><a href="#二、更为恰当地命名" class="headerlink" title="二、更为恰当地命名"></a>二、更为恰当地命名</h2><p>我们肯定会有这样的<strong>疑问</strong>：使用像英语这样的语言，我们所要表达一个相同的意思常常会有不同的表述（比如说：表示钱💴，可能有人表示为<code>double wallet = 100.00</code>，而有些人表示为诸如 <code>money</code> <code> balance</code>等其他名称）。<em>所以说，这种命名方式是否为规范或恰当呢？或者说我们是否有更好的命名方式呢？而当我们面对上述这样不同单词表达相同意思的情况，又该如何选择呢？</em></p><p>这里引入这样的”暴论“——一个好的名字应有<strong>2个意思</strong>：<u>1. 表达了什么</u>(如：<code>double balance; //表达的就是(用户/账户的)余额</code>)；<u>2. 单词的立意</u>(上述<code>balance</code>具有多个意思:平衡、保持平横、抵消……)，单词的立意本质上说，它就是与前面的类型等因素相称，不造成歧义即仅表现出一种明确的意思。当一个变量名具备这两种性质，那么就会知道它所要表达的本意。</p><p><strong>注意</strong>：关于变量，我们所要表达的东西一定不能是怎样的；如果是，那么问题出现<u>，因为变量根本不是“怎样的”，而是表达一个”什么“</u>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日常生活用语</span></span><br><span class="line">studentData;</span><br><span class="line"><span class="comment">// input计算机界的学术语==》是更凸显IT界特指的变量</span></span><br><span class="line">input_stu_data;</span><br><span class="line"></span><br><span class="line">inputRec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">double</span> sum;</span><br><span class="line"><span class="comment">// sum的意思？虽然名词词性上是金额总数；但实际上它是属于一种计算机术语还是其他的呢？我们的立意并不清晰</span></span><br><span class="line"><span class="comment">// 假设这个sum变量定义在财务报告系统，那么这个sum是什么？是求和函数还是要干什么？所以会产生歧义，会引起混淆</span></span><br><span class="line"><span class="comment">// 因此为了准确表达总额的含义，我们不妨可以这样定义：double calcValue;这样就会很清晰的知道这是一个值、一个计算总值</span></span><br></pre></td></tr></table></figure><p>所以，我们还是回到上述的2个意思：<u>1. 表达了什么</u>；<u>2. 单词的立意</u>。单词有各种各样的意思，在学术界它是怎样？它是否会有歧义？这是我们所要在乎与考虑的。 </p><h2 id="三、讲究长度的变量"><a href="#三、讲究长度的变量" class="headerlink" title="三、讲究长度的变量"></a>三、讲究长度的变量</h2><p>大家都知道像<code>unsigned int the_max_country_number_of_the_olympic_team = 20</code>；这样的变量名长度一定是有问题的。我们<strong>参考以下论文：<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=44385">Debugging effort estimation using software metrics</a>和这个网站<a href="https://ifsq.org/indicator-SP-5.html">IFSQ:SP-5—Poor Choice of Name</a>的概述</strong>。</p><p><strong>Research Findings:</strong> The effort required to <u>debug a program is minimized</u> when variables had names <u>averaging 10 to 16 characters long</u>.</p><p>实际情况，在国内的企业命名长度要求大多为：9-15、10-16或<strong>8-20</strong>，还有些是8-16个。我们平常选取最大范围8-20的长度，可以说是问题不大。</p><p>这里，我们还可<strong>以参阅这篇文章博客<a href="https://willkoehrsen.github.io/data%20science/software%20engineering/data-scientists-your-variable-names-are-awful-heres-how-to-fix-them/">Data Scientists Your Variable Names Are Awful Heres How To Fix Them</a>的论述</strong>。</p><p>于是，我们对上述极长的代码修改为<code>numTeamMembers</code>。</p><p>注意，变量名往往和其所处的作用域来进一步补充完备意思，所以这里虽不呈现奥林匹克之意，但它应该仅作用于奥林匹克的命名空间之下。这是我们之后要谈的。</p><h2 id="四、变量作用域与长度及规范"><a href="#四、变量作用域与长度及规范" class="headerlink" title="四、变量作用域与长度及规范"></a>四、变量作用域与长度及规范</h2><p>以<code>for</code>语句为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数（OOP 方法） 类</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们会发现i和k的作用域或者说适用范围只在for语句中，这时候准确说来并无问题。</span></span><br><span class="line"><span class="comment">// 这时变量范围被局限住了</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但是</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++)</span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i ++;</span><br><span class="line">i --;</span><br><span class="line"><span class="comment">// 若i超出for的作用范围，这时我们就不能定义为i，因为没人知道这个i是啥；</span></span><br><span class="line"><span class="comment">// 当我们定义在for循环内我们都知道这是计数器，但脱离for之后，我们的i++,i--又表示什么含义呢？</span></span><br><span class="line"><span class="comment">// 不得而知，所以不能这样命名。</span></span><br></pre></td></tr></table></figure><p>因此，我们会发现，<u>变量名命名在什么地方会决定变量名该如何命名，函数（OOP 方法）、类、作用域都会决定你如何去命名变量</u>。</p><p>这里，我们或可以参阅这本书<a href="https://www.amazon.com/exec/obidos/ASIN/0876268165/acmorg-20">Software psychology: Human factors in computer and information systems</a>。</p><p><strong>结果简要概述</strong>：特别短的名字(&lt;8)我们常定义为局部变量，在for循环内可能会更短；它的作用域可能会决定它的长和短：<strong>当一个变量名越短，可能它的作用域就越小</strong>，甚至小到i,k这样的单字符。</p><p>但一些<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B">防御性编程</a>会可能刻意绕开这些短的变量名。</p><p><strong>变量名可能一样</strong>，我们会使用命名空间等所处的域不同来进行划分以<strong>区分变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. wallet</span></span><br><span class="line"><span class="keyword">package</span> com.goolgle.user;</span><br><span class="line"><span class="comment">// mysql sql引入要正确</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. wallet  </span></span><br><span class="line"><span class="keyword">package</span> com.goolgle.dog;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wallet</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更为学术的说，我们称作这为：<strong>划分全局<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4#">命名空间</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> User &#123;</span><br><span class="line">    <span class="comment">// Wallet</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dog &#123;</span><br><span class="line">    <span class="comment">// Wallet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一些不支持上述<strong>划分全局命名空间</strong>的操作的语言如：<code>C</code>语言。我们可以:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">design_Emp</span><br><span class="line">dev_Emp</span><br></pre></td></tr></table></figure><p>而对于可以使用<strong>package</strong>的<code>Java</code>语言，则更为简便:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.goolgle.design;</span><br><span class="line"><span class="comment">// mysql sql引入要正确</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.goolgle.dev;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、细化-关于变量计数词"><a href="#五、细化-关于变量计数词" class="headerlink" title="五、细化:关于变量计数词"></a>五、细化:关于变量计数词</h2><p>我们首先要明确：所要讨论的计数词<strong>是什么</strong>——这个计数不是循环中的<code>i</code>、<code>j</code> 、<code>k</code>，而是我们经常所用的计数，如：总共的人数、总分数和平均数、最大及最小值等各种各样的东西。我们在设计这些<strong>涉及到计算的意思的变量名</strong>，我们该怎样比较确恰地命名，这是此段所要探讨的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// sum，avg/average，max，min，total……</span></span><br><span class="line">    <span class="comment">// num</span></span><br><span class="line">    <span class="comment">// 这些单词的表述都很好，但我们要注意一些点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 举例：员工总数</span></span><br><span class="line">    <span class="comment">// 不建议使用sum，更建议total(总计)</span></span><br><span class="line">    <span class="comment">// int total_emp; // 或直接写全:total_employees</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为什么不用num呢？歧义的风险</span></span><br><span class="line">    <span class="comment">// int num_employees; // =》员工数量</span></span><br><span class="line">    <span class="comment">// int employee_num; // =》员工号？</span></span><br><span class="line">    <span class="comment">// 我们将其倒错会产生截然不同的意思</span></span><br><span class="line">    <span class="comment">// 所以，以上命名都不合理</span></span><br><span class="line">    <span class="comment">// 因此，我们可以对其进行规定约束：基本上，将计数词放在后面，除非特殊要求</span></span><br><span class="line"><span class="comment">// 我们这样写：名词提前-计数词放后</span></span><br><span class="line">    <span class="comment">// 注意：这是为了好看的一种约束，这不是死板的。</span></span><br><span class="line">    <span class="comment">// 对错并无分别，取决于企业的规范</span></span><br><span class="line">    <span class="type">int</span> employee_total;</span><br><span class="line">  <span class="comment">// 若要表达员工号，也是尽可能不用num</span></span><br><span class="line">    <span class="type">int</span> employee_index;</span><br><span class="line">    <span class="comment">// 我们把计数单词放在前面，就意味者它的中心义或内涵</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：常进行一种约束：**<u>名词提前-计数词放后</u>**</p><h2 id="六、细化-对立词选择建议"><a href="#六、细化-对立词选择建议" class="headerlink" title="六、细化:对立词选择建议"></a>六、细化:对立词选择建议</h2><p>在计算机术语中，常有一些有意思的词，他们总是对立的，然后这些对立的词常相匹配组成一些完整的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    up/down</span><br><span class="line">    old/new</span><br><span class="line">first/last</span><br><span class="line">    min/max</span><br><span class="line">    opened/closed</span><br><span class="line">    locked/unlocked</span><br><span class="line">    ...</span><br><span class="line">    begin/end</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、细化-常量、宏与指针"><a href="#七、细化-常量、宏与指针" class="headerlink" title="七、细化:常量、宏与指针"></a>七、细化:常量、宏与指针</h2><p>建议直接参考伟大的项目<a href="https://github.com/torvalds/linux">linux</a>的源码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_FIVE 5  <span class="comment">// × 表示具体数字错误也就是说不能出现FIVE 可以改为数组的容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++的常量：Google常声明常量以k开头</span></span><br><span class="line"><span class="comment">// constant</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInYear = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 题外话：匈牙利命名法</span></span><br><span class="line"><span class="type">int</span> *pSize;</span><br></pre></td></tr></table></figure><p>这只是一个<code>约定</code></p><h2 id="八、细化-循环计数器i-j-k"><a href="#八、细化-循环计数器i-j-k" class="headerlink" title="八、细化:循环计数器i,j,k"></a>八、细化:循环计数器i,j,k</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; totalEmp.count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编程艺术来考虑，循环当中使用<code>i,j,k</code>是否规范？实际情况是<strong>允许</strong>的（<strong>前提是</strong>必须定义<strong>在循环里面</strong>，即<strong>作用域的界定范围在循环中</strong>，不会污染到其他东西）。例：<code>JavaScript</code>这门语言若定义为全局，它就会造成<strong>变量的污染</strong>。</p><p>但是，如果<code>i</code>定义在<strong>循环之外</strong>，这么写是<strong>存在问题</strong>的，因为这样的<code>i</code>很可能被循环之后的代码运用到，那此时这个<code>i</code>是什么数据？它是<strong>垃圾数据</strong>，它并没有得到有效的管理。</p><p>如果我们的<code>i</code>不仅在循环内用到，还在其外用到，那么它就不能定义为<code>i</code>，而应定义为一个<strong>更具体的名称</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> record_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ( condition ) &#123;</span><br><span class="line">        record_count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    record_count ++;</span><br><span class="line">    cout &lt;&lt; record_count &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;j ++) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这样写，并不是很好</span></span><br><span class="line">    <span class="comment">// 如果for循环多且嵌套或数组二维或更高维，那就不要再i,j,k了</span></span><br><span class="line">    <span class="comment">// 因为：我们很可能会不知道谁是谁了</span></span><br><span class="line">    <span class="comment">// 而要规避掉这样的风险，或者说更好一些，只需要对变量名规范命名就可以了；这样在逻辑上，我们可以直接清晰的明白所循环的是什么</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要<strong>指明</strong>：项目工程的开发与维护不可能仅一个人搞，团队协作是常态，因此好的变量命名会带给其他人对你代码直观的理解，别人才更易接手这样的项目。</p><h2 id="九、细化-枚举命名的讲究"><a href="#九、细化-枚举命名的讲究" class="headerlink" title="九、细化:枚举命名的讲究"></a>九、细化:枚举命名的讲究</h2><p>给人的感觉与常量相似，因为也是大写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">AlternateurlTableErrors</span> &#123;</span></span><br><span class="line">        OK = <span class="number">0</span>,</span><br><span class="line">        OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">        MALFORMED_INPUT = <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有些语言、企业会规定加前缀等东西。</p><h2 id="十、细化-临时变量的讲究"><a href="#十、细化-临时变量的讲究" class="headerlink" title="十、细化:临时变量的讲究"></a>十、细化:临时变量的讲究</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果说后面还会用到temp这个变量，那么最好不要定义为temp</span></span><br><span class="line">    <span class="comment">// 它不像在for循环中的，定义作用域在内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">19</span>;i ++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">        ..</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 但是如果后面还要被使用，那就不要定义为temp</span></span><br><span class="line">    <span class="comment">// 比如求三角形周长</span></span><br><span class="line">    <span class="comment">// int temp = a + b + c; ×错 有些随意 缺乏描述</span></span><br><span class="line">    <span class="type">int</span> triangle_perimeter = a + b + c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 变量名命名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广义百合定义的一次尝试</title>
      <link href="/2024/10/22/%E5%B9%BF%E4%B9%89%E7%99%BE%E5%90%88%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>/2024/10/22/%E5%B9%BF%E4%B9%89%E7%99%BE%E5%90%88%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="【翻译】广义百合定义的一次尝试"><a href="#【翻译】广义百合定义的一次尝试" class="headerlink" title="【翻译】广义百合定义的一次尝试"></a>【翻译】广义百合定义的一次尝试</h3><p>当前，“百合”这一概念被广泛用于描述女性之间的多种关系，常引发“什么算是百合？”或“这部作品算不算百合？”的争论。本文试图通过分类，促使人们从“这是否是百合？”的讨论转向“我喜欢哪种百合？”的探索。</p><p>百合的模糊性使其涵盖了不同风格的作品，推动了这一类型的广泛流行。然而，过于细化的分类可能会导致创作和市场的分散，影响百合文化的传播。对于新粉丝或未深入了解的人，百合的模糊定义容易引发困惑，并可能被“○○不是百合”的声音所影响。因此，建立一个涵盖性的定义和分类是有意义的。</p><p>我们尝试将“百合”定义为“女性之间某种特殊关系以及描写这种关系的作品或类型”。通过分析这些关系的情感和行为，我们可以将百合分为三大类：“浪漫与性吸引”、“情感依附或情感超越”、“情感纽带或亲情”。以下是这三类的详细说明：</p><hr><h3 id="1-浪漫与性吸引"><a href="#1-浪漫与性吸引" class="headerlink" title="1. 浪漫与性吸引"></a>1. 浪漫与性吸引</h3><p>这一类描绘女性之间的恋爱或性关系。无论是明确表达的恋情，还是虽未明说但明显可解读为恋爱的作品，都属于此类。</p><p><strong>1-1. 逃避与代偿</strong><br>描绘在社会压力下（如被迫订婚或相亲）女性为逃避异性恋期待而选择同性恋爱，暂时或永久地沉浸其中。</p><p><strong>1-2. 诱惑与矛盾</strong><br>描写主人公因被同性吸引而陷入内心矛盾，挣扎于“禁忌之恋”中，最终卷入同性关系。诱惑者常是带领主人公进入未知领域的角色，许多作品的结局带有悲剧色彩。</p><p><strong>1-3. 自觉与告白</strong><br>主要描写青春期少女在情感动荡中意识到自己的感情，并通过告白发展恋爱关系，常伴随成长与自我认知。</p><p><strong>1-4. 博弈与对话</strong><br>描绘精神成熟的女性之间的恋爱。双方对自身性取向有清晰认识，感情发展中常遇到挑战，通过对话解决问题。</p><p><strong>1-5. 持续与稳定</strong><br>描写已经恋爱或同居的女性情侣，关注共同生活与关系的稳定性，常涉及性描写或对未来规划的思考。</p><p><strong>1-6. 单恋</strong><br>一方对另一方怀有深厚感情，故事中可能始终未告白，或告白后被拒绝。</p><p><strong>例子：</strong></p><ul><li>奥平晓 × 万城目文（志村贵子《青之花》）</li><li>熊仓真理子 × 大桥纪子（森永美留《GIRL FRIENDS》）</li><li>大道寺知世 → 木之本樱（《Card Captor Sakura》）</li></ul><hr><h3 id="2-情感依附或情感超越"><a href="#2-情感依附或情感超越" class="headerlink" title="2. 情感依附或情感超越"></a>2. 情感依附或情感超越</h3><p>这类关系无法简单归类为爱情或友情，通常有着模糊但特殊的情感连接，表现出近似恋爱关系的特征。</p><p><strong>2-1. 引力</strong><br>描写女性之间无法抗拒的吸引力，彼此像被引力般拉近，这类关系常在作品中有强烈的情感张力。</p><p><strong>2-2. 伙伴</strong><br>女性因命运或某些外部原因而建立的强烈精神或身体联系，类似“强制百合”。</p><p><strong>2-3. 庇护所</strong><br>这种关系中，女性彼此之间成为对方的避风港，在现实压力下互相治愈并重建生活。</p><p><strong>2-4. 搭档</strong><br>由于共同目标或使命建立的合作关系，随着时间推移，彼此的情感和信任逐渐加深。</p><p><strong>2-5. 巨大不明感情</strong><br>一方对另一方拥有过于强烈的情感，既可能是憧憬、羡慕，也可能是嫉妒、仇恨等复杂情感交织。</p><p><strong>2-6. 依偎</strong><br>描绘在亲密关系中，彼此以一种放松的方式依靠对方，感受到安全和归属感。</p><p><strong>例子：</strong></p><ul><li>黄前久美子 × 高坂丽奈（《吹响吧！上低音号！》）</li><li>天上乌天 × 姬宫安希（《少女革命》）</li><li>鹿目圆香 × 晓美焰（《魔法少女小圆》）</li></ul><hr><h3 id="3-情感纽带或亲情"><a href="#3-情感纽带或亲情" class="headerlink" title="3. 情感纽带或亲情"></a>3. 情感纽带或亲情</h3><p>这一类描绘的关系不特别强调爱情或模糊关系，而是纯粹的亲密感情，包括友情、家庭爱和愉快的互动。</p><hr><p>通过以上分类，“1. 浪漫与性吸引”可以称为“硬百合”，而“2. 情感依附或情感超越”与“3. 情感纽带或亲情”合称为“软百合”。这些分类帮助我们看到百合作品在情感与关系上的丰富多样性，也使得讨论“我喜欢哪种百合？”更加具体有趣。</p><p>百合，正是因为这些复杂而多样的情感交织，吸引了如此多样化的受众群体。</p><p> 改翻自:<a href="https://yuri315.hatenablog.com/entry/2018/02/01/yuri-definition-3">百合の定義・分類【三訂版】</a></p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re0:提瓦特幸存者</title>
      <link href="/2024/10/22/Rouguelike-%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/"/>
      <url>/2024/10/22/Rouguelike-%E6%8F%90%E7%93%A6%E7%89%B9%E5%B9%B8%E5%AD%98%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Re0-从零开始的C-游戏开发"><a href="#Re0-从零开始的C-游戏开发" class="headerlink" title="Re0:从零开始的C++游戏开发"></a>Re0:从零开始的C++游戏开发</h1><h5 id="前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。"><a href="#前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。" class="headerlink" title="前言：本笔记是Chaos观看B站upVoidmatrix的课程从零开始的提瓦特幸存者的个人笔记；所用为适合新手入门的easyx图形库。"></a>前言：本笔记是Chaos观看B站up<a href="https://space.bilibili.com/25864506">Voidmatrix</a>的课程<a href="https://space.bilibili.com/25864506/channel/collectiondetail?sid=1825182">从零开始的提瓦特幸存者</a>的个人笔记；所用为适合新手入门的easyx图形库。</h5><h2 id="第一集-追鼠标の小球"><a href="#第一集-追鼠标の小球" class="headerlink" title="第一集 追鼠标の小球"></a>第一集 追鼠标の小球</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1280</span>, <span class="number">720</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">640</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">360</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 双缓冲绘图</span></span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"><span class="comment">// 主循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">ExMessage msg;</span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在这里进行消息处理逻辑</span></span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_MOUSEMOVE)</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// 数据处理（由于数据处理逻辑简单，所以嵌套在读取操作中）</span></span><br><span class="line">x = msg.x;</span><br><span class="line">y = msg.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 绘制画面</span></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">solidcircle</span>(x, y, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘图坐标系"><a href="#绘图坐标系" class="headerlink" title="绘图坐标系"></a>绘图坐标系</h3><p>easyx中，绘图坐标系相似于二维数组坐标系，即y轴的反转</p><h3 id="渲染缓冲区"><a href="#渲染缓冲区" class="headerlink" title="渲染缓冲区"></a>渲染缓冲区</h3><p>渲染缓冲区：类似画笔在画布上画画，先绘制的内容就可能被后绘制的内容覆盖掉</p><p><code> cleardevice()</code>就是使当前填充颜色将画布覆盖，默认填充色为黑色</p><p>当我们调用<code>solidcircle()</code>这类绘图函数时，一个无边框的填充圆被“逐渐地”绘制到这张画布上<br>当我们不断清屏，不断画圆，逐渐地过程在“宏观上”体现出来了</p><p>而当我们调用<code>BeginBatchDraw();</code>easyx为我们新建一个渲染缓冲区，不同于窗口的渲染缓冲区，它默认是不可见的，随后执行的所有绘制都将在新的画布上进行<br>而当我们调用<code>FlushBatchDraw();</code>或<code>EndBatchDraw();</code>时，easyx会将窗口所显示的缓冲区和新建的缓冲区进行“迅速”交换，这样的交换迅速到我们不会因绘图过程频繁而导致闪烁</p><h3 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h3><h4 id="主循环"><a href="#主循环" class="headerlink" title="*主循环"></a>*主循环</h4><p>在上述程序中，我们通过一个<code>while(true)</code>死循环阻塞程序退出，同时不断执行清屏和绘制的操作，这其实就是游戏框架最核心的部分——主循环</p><p>在主循环中，我们不断读取玩家的(鼠标、键盘等)操作，将这些操作翻译成我们的数理逻辑，最后再根据现有的数据将画面内容绘制出来<br>简而言之，就是<strong>读取操作、处理数据、绘制画面</strong>这三大要素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">读取操作();</span><br><span class="line">处理数据();</span><br><span class="line">绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure><p>如上述代码，我们游戏的渲染部分只依赖于当前的数据，依旧是变量x和y的值，而与如何处理得到这些数据的处理逻辑并未有直接关系。这就是软件工程理论中的”解耦耦合“，或者说这就是”数据驱动”，或者说“渲染与逻辑分离”中最朴素的思想。</p><p>当然，在主循环开始之前，我们需要把主循环过程中所需要的数据初始化，如：将圆的位置坐标初始化、初始化窗口等。</p><p>而在主循环结束后，需要对游戏程序使用的资源进行释放。</p><h2 id="第二集-进击の井字棋"><a href="#第二集-进击の井字棋" class="headerlink" title="第二集 进击の井字棋"></a>第二集 进击の井字棋</h2><h3 id="三大元素"><a href="#三大元素" class="headerlink" title="三大元素"></a>三大元素</h3><p>在代码编写之前，</p><p>我们首先根据前面所讲述的游戏框架，思考在井字棋的<strong>主循环中三大要素</strong>如何设计实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">读取操作();</span><br><span class="line">处理数据();</span><br><span class="line">绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure><ol><li><h5 id="读取操作："><a href="#读取操作：" class="headerlink" title="读取操作："></a>读取操作：</h5><p>在本程序中，我们只对鼠标输入进行考虑，所以我们只需对鼠标按键按下的消息进行处理：当鼠标点击在空白的棋盘网格时，便执行落子操作。</p></li><li><h5 id="数据处理："><a href="#数据处理：" class="headerlink" title="数据处理："></a>数据处理：</h5><p>我们只需要对游戏的胜负条件进行检测即可，游戏结束的条件是同类型三颗棋子连成一条直线或棋盘被填满。</p><p>游戏结束时，使用弹窗告诉玩家游戏结果，然后退出主循环。</p></li><li><h5 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h5><p>网格棋盘：使用<code>line()</code>函数绘制直线将窗口等分为<code>3X3</code>的网格</p><p><code>X棋子</code>：使用<code>line()</code>函数绘制连接网格对角线的两条直线</p><p><code>O棋子</code>：使用<code>circle()</code>函数绘制圆心在网格中心的无填充原型</p><p>除此之外，我们应会在窗口左上角输出一行文字<code>当前妻子类型：X</code>，用以告诉玩家当前被放置的棋子类型。</p></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>接下来，便是考虑如何组织<strong>游戏的数据结构</strong>。</p><ol><li><h5 id="棋盘："><a href="#棋盘：" class="headerlink" title="棋盘："></a>棋盘：</h5><p>显而易见，我们可以使用<strong>二维数组</strong>来表示棋盘。我们将二维数组中每个元素类型设置为<code>char</code>类型，再<strong>约定</strong><code>&#39;X&#39;字符</code>表示叉号棋子、<code> &#39;O&#39;字符</code>表示圆形棋子、 <code>&#39;-&#39;字符</code>默认值表示网格中没有棋子</p></li><li><h5 id="游戏结束条件"><a href="#游戏结束条件" class="headerlink" title="游戏结束条件"></a>游戏结束条件</h5><p>2.1 某玩家<strong>获胜</strong>的情况</p><p>我们著需要对<code>&#39;X&#39;字符</code>、<code>&#39;O&#39;字符</code>进行穷举，可能出现的情况一共有<strong>8种</strong>：分别是横向的三行棋子出现同类型符号、竖向的三行棋子出现同类型符号和两条对角线的棋子出现同类型符号。</p><p>2.2 两玩家<strong>平局</strong>的情况</p><p>即没有玩家获胜的情况，也就是说数组中的每一个元素<strong>均不是</strong><code>&#39;-&#39;字符</code>，即可判定玩家平局。</p></li></ol><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>到现在，在我们的思路已经十分明晰后，我们着手编写代码。</p><p>在代码编写的过程中，我们同样遵循<strong>先框架后细化</strong>的思路。</p><p>我们先把上述思路转变成代码，细节部分先使用注释进行替代，再将每一部分的注释替换为代码。这样可以确保我们在编写代码的过程中不会被突然出现的代码细节打扰。</p><p>实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 简单粗暴的全局变量并非一个好习惯</span></span><br><span class="line"><span class="type">char</span> board_data[<span class="number">3</span>][<span class="number">3</span>]</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当前落子类型，初始化为&#x27;O&#x27;</span></span><br><span class="line"><span class="type">char</span> cur_piece = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"><span class="comment">// 检测指定棋子的玩家是否获胜</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckWin</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">2</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">2</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测当前是否出现平局</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (board_data[i][j] == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制网格棋盘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBoard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">line</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">line</span>(<span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"><span class="built_in">line</span>(<span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">line</span>(<span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制棋子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPiece</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (board_data[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line"><span class="built_in">circle</span>(<span class="number">200</span> * j + <span class="number">100</span>, <span class="number">200</span> * i + <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line"><span class="built_in">line</span>(<span class="number">200</span> * j, <span class="number">200</span> * i, <span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">line</span>(<span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * i, <span class="number">200</span> * j, <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制左上角文本提示信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTipText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> TCHAR str[<span class="number">64</span>];</span><br><span class="line">_stprintf_s(str, <span class="string">&quot;Current Type of Piece: %c&quot;</span>, cur_piece);</span><br><span class="line"></span><br><span class="line"><span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">225</span>, <span class="number">175</span>, <span class="number">45</span>));</span><br><span class="line"><span class="built_in">outtextxy</span>(<span class="number">0</span>, <span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化窗口</span></span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 控制主循环是否进行下去</span></span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 消息处理</span></span><br><span class="line">ExMessage msg;</span><br><span class="line"><span class="comment">// 双缓冲</span></span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"><span class="comment">// 主循环</span></span><br><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">&#123;</span><br><span class="line">DWORD start_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line"><span class="comment">// 鼠标消息检测</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查鼠标左键按下消息</span></span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_LBUTTONDOWN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 计算点击位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = msg.x;</span><br><span class="line"><span class="type">int</span> y = msg.y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于每个网格都是200X200</span></span><br><span class="line"><span class="type">int</span> ind_x = x / <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> ind_y = y / <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试落子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (board_data[ind_y][ind_x] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">board_data[ind_y][ind_x] = cur_piece;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换棋子类型</span></span><br><span class="line"><span class="keyword">if</span> (cur_piece == <span class="string">&#x27;O&#x27;</span>) cur_piece = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> cur_piece = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绘制图像</span></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawBoard</span>();</span><br><span class="line"><span class="built_in">DrawPiece</span>();</span><br><span class="line"><span class="built_in">DrawTipText</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// X玩家获胜逻辑</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CheckWin</span>(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 弹窗</span></span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;X Player WIN!&quot;</span>, <span class="string">&quot;Game End&quot;</span>, MB_OK);</span><br><span class="line"><span class="comment">// 修改主循环控制条件</span></span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O玩家获胜逻辑</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">CheckWin</span>(<span class="string">&#x27;O&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 弹窗</span></span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;O Player WIN!&quot;</span>, <span class="string">&quot;Game End.&quot;</span>, MB_OK);</span><br><span class="line"><span class="comment">// 修改主循环控制条件</span></span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述条件都不满足时，对游戏平局检测</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CheckDraw</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 弹窗</span></span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), <span class="string">&quot;Ops!It&#x27;s DRAW.&quot;</span>, <span class="string">&quot;Game End.&quot;</span>, MB_OK);</span><br><span class="line"><span class="comment">// 修改主循环控制条件</span></span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依据间隔时间动态分配休眠时间</span></span><br><span class="line">DWORD end_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">DWORD delta_time = end_time - start_time;</span><br><span class="line"><span class="comment">// 按每秒60帧刷新页面</span></span><br><span class="line"><span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">60</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - delta_time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，在程序运行时的程序占用率过高，通过任务管理器也可以发现一个小小的井字棋游戏，CPU占用率甚至已经超过了电脑中的绝大部分软件。这是因为计算机在执行<code>while循环</code>时速度较快，我们编写的主循环在顷刻间已经执行完了成千上万次，占用了大量的CPU时间片。对于大部分物理刷新率仅有<code>60Hz</code>的显示设备来说，这无疑是一种性能浪费。所以我们可以使用<code>Sleep();</code>函数来让程序在执行完一次循环后休眠一小段时间，从而减少计算资源的浪费。</p><p>在大多教程中，这里或许会简答粗暴的写一句<code>Sleep(15)</code>，来让程序在每一次循环结束后强制等待15毫秒。但是，这种设计是不太合适的，随游戏体量的增大，程序每次执行主循环所执行的计算任务可能是不同的，以及涉及到操作系统CPU计算资源的分配，这就导致每次执行主循环所实际消耗的时间可能是不一样的。所以我们需要根据每一帧执行的实际耗时，动态的计算在这之后要休眠多长时间，这是引入一个新的函数<code>GetTickCount()</code>。我们可以使用它来获得程序自运行开始以来到现在的毫秒数<code>DWORD time = GetTickCount();</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DWORD start_time = <span class="built_in">GetTickCount</span>(); <span class="comment">// 获取此次循环初始时间</span></span><br><span class="line">    </span><br><span class="line">读取操作();</span><br><span class="line">处理数据();</span><br><span class="line">绘制画面();</span><br><span class="line">  </span><br><span class="line">DWORD end_time = <span class="built_in">GetTickCount</span>(); <span class="comment">// 获取此次循环结束时间</span></span><br><span class="line">    </span><br><span class="line">DWORD delta_time = end_time - start_time; <span class="comment">// 计算间隔时间</span></span><br><span class="line">    <span class="comment">// 依据间隔时间动态分配休眠时间</span></span><br><span class="line">    <span class="comment">// 按每秒60帧刷新页面</span></span><br><span class="line"><span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">60</span>) <span class="comment">// 如果间隔时间&lt;每秒60帧，要进行休眠；否则不需要。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">60</span> - delta_time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure><h2 id="第三集-提瓦特の幸存者"><a href="#第三集-提瓦特の幸存者" class="headerlink" title="第三集 提瓦特の幸存者"></a>第三集 提瓦特の幸存者</h2><h3 id="3-1-程序动画实现及角色移动"><a href="#3-1-程序动画实现及角色移动" class="headerlink" title="3.1 程序动画实现及角色移动"></a>3.1 程序动画实现及角色移动</h3><p>在开始之前，我们应该认识到，尽管A我们可以通过<strong>点线面</strong>绘制简单的画面，但是想要只用这种<strong>矢量绘图</strong>的方式完成游戏内全部素材是远远不够的。想要绘制一个简单的人物就要洋洋洒洒300+行代码，那更不用提什A么画质精美的3A大作了。</p><p>所以，使用经过专业绘图软件(如：PS等)处理的<strong>位图素材</strong>是必不可少的。<strong>位图素材</strong>也就是我们常说的图片资源素材。</p><p>那么，我们如何在Easyx中<strong>加载并渲染图片资源</strong>呢？我们查看<a href="https://docs.easyx.cn/zh-cn/intro">文档</a>就可发现，Easyx使用了一个叫做**<code>IMAGE</code>的类<strong>来表示</strong>图片对象<strong>；而加载图片使用一个叫做</strong><code>loadimage</code>的函数<strong>，这个函数负责将图片文件数据</strong>加载到<code>IMAGE对象</code>中**、或者直接将图片加载到绘图窗口中，同时这个函数还有一个重载，用以从资源文件中加载图像。                            </p><p> 加载图片完成后，就是如何<strong>渲染图片</strong>，这里使用**<code>putimage</code>函数**。<code>putimage</code>函数同样有两个重载。</p><p>所以整套图片<strong>绘制的流程</strong>就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img,<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">100</span>,<span class="number">200</span>,&amp;img);</span><br></pre></td></tr></table></figure><p>掌握这两个函数后，我们就可以开始编写代码了。</p><p>在一切开始之前按照先前所讲述的，将<strong>游戏框架</strong>写出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">1280</span>, <span class="number">720</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">ExMessage msg;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (running)</span><br><span class="line">&#123;</span><br><span class="line">DWORD start_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line">DWORD end_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">DWORD delta_time = start_time - end_time;</span><br><span class="line"><span class="keyword">if</span> (delta_time &lt; <span class="number">1000</span> / <span class="number">144</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span> / <span class="number">144</span> - delta_time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以将背景绘制在窗口中了：首先，将素材文件copy到工程目录下。<strong>需要注意</strong>的是，<u>VS在调试时使用的相对路径、根目录和新建代码的默认位置相同。</u></p><p>在加载渲染好背景图片后，就到了我们的重点——<strong>如何让画面”动“起来？</strong></p><p>在<strong>游戏开发技术</strong>中，<strong>角色动画</strong>的常见实现可以笼统的分为<strong>两类</strong>：<u>序列帧动画和关键帧动画</u>。<strong>序列帧动画</strong>通常由<strong>一组图片素材</strong>组成，我们在程序中<strong>随着时间的推移不断切换</strong>显示这一序列的图片，借助视觉暂留效应，便有了动画效果；而<strong>关键帧动画</strong>如<strong>骨骼动画</strong>等往往涉及到更复杂的图形学技术，在此暂不作讨论。</p><p>现在我们使用一组二次元人物图片作为游戏素材，要想实现每个一段时间切换一张图片显示，该<strong>如何处理</strong>呢？</p><h4 id="3-1-1-动画实现"><a href="#3-1-1-动画实现" class="headerlink" title="3.1.1 动画实现"></a>3.1.1 动画实现</h4><p>我们或许会想到<code>Sleep()</code>函数，例如：我们希望在一秒钟切换10次图片，那么只需要写下<code>Sleep(100);</code>这样的代码就可以了，吗？但是，我们在之前提及过，当调用<code>Sleep()</code>函数时，程序会卡在这里等待对应的时间，这是一个”<strong>阻塞式</strong>“的行为；而在我们的游戏框架设计中，所有的画面渲染等操作，都应该在一次又一次的循环中进行，每次循环的时间都应该控制在1&#x2F;60秒内，也就是说，我们切换动画轮播的任务，应该分摊在多帧之间进行，而不是在单次循环内一次性解决。</p><p>这就触及到我们游戏编程的一个<strong>核心思想</strong>：<u>主循环内应尽量避免阻塞式的行为或过于繁重且耗时过长的任务</u>。具体可以进入<strong>“高性能”编程领域</strong>深入学习。</p><p>为了<u>确保动画序列帧的能够间隔固定的时间进行切换</u>，我们这里类比定时器的概念实现一个<strong>计数器</strong>。</p><p>首先，定义<code>idx_cur_anim</code>变量来存储当前动画的<strong>帧索引</strong>；再定义一个<code>counter</code>用来记录<strong>当前动画帧</strong>一共播放了几个游戏帧，这里使用<code>staic</code>修饰计数器，<strong>保证</strong>计数器只在第一个游戏帧时被初始化为0，我们不妨每5个游戏帧切换动画帧。</p><p>随后，我们还要考虑到动画帧序列<strong>播放结束后的行为</strong>，我们希望动画是循环播放的，也就是当动画的帧索引到大帧总数时，将索引<strong>重置</strong>为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_ANIM_NUM = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* ...</span></span><br><span class="line"><span class="comment">    ...*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++counter % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx_cur_anim ++;</span><br><span class="line">    &#125;</span><br><span class="line">idx_cur_anim =  idx_cur_anim % PLAYER_ANIM_NUM;</span><br><span class="line">    <span class="comment">/* ...</span></span><br><span class="line"><span class="comment">    ...*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样，我们就完成了动画的<strong>数据逻辑</strong>部分，接下来就是<strong>动画的渲染部分</strong>。</p><p>在这之前，我们首先应该像加载背景图片那样将动画的每一帧图片都<strong>加载</strong>到程序中。定义<code>LoadAnimation()</code>函数。我们将图片规律命名，这样就可以使用循环加载图片。在使用**<code>Unicode</code>字符集**的情况下，我们可以使用<code>wstring</code>来拼凑出文件路径，进而传递给<code>loadimage()</code>函数，将图片加载到数组中。</p><p>现在来到<strong>游戏框架中的画面渲染</strong>部分，之前定义的动画帧索引这时便可以当作IMAGE数组的索引来使用。</p><p>但运行程序我们会发现，虽然人物动画轮播功能是正常的，但人物的周围套上了<strong>黑黑的边框</strong>。看起来图片的透明区域并未发生作用，这是因为<code>putimage()</code>函数在渲染过程中，并没有使用IMAGE对象的透明度信息，所以我们想要绘制类似这种带有透明度的图片素材，就要自己处理这部分逻辑。这里，我们类比<code>putimage()</code>函数<strong>封装</strong>一个<code>putimage_alpha()</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现透明通道混叠 借助系统绘图函数的比较轻巧的实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;MSIMG32.LIB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line"><span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line"><span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h,</span><br><span class="line"><span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, &#123;AC_SRC_OVER, <span class="number">0</span>, <span class="number">255</span>, AC_SRC_ALPHA&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行程序，就可以发现动画被<strong>正常渲染</strong>了。</p><h4 id="3-1-2-角色移动"><a href="#3-1-2-角色移动" class="headerlink" title="3.1.2 角色移动"></a>3.1.2 角色移动</h4><p>接着，我们来实现<strong>键盘控制角色移动</strong>的功能。</p><p>我们首先定义<code>POINT</code>类型的<code>player_pos</code>变量用来存储玩家的位置，记得将玩家坐标初始化。随后将动画渲染的位置更改为<code>player_pos</code>变量的位置。</p><p>这时，只需要在<strong>事件处理部分</strong>根据按键<strong>修改</strong><code>player_pos</code>的值，就可以实现角色的移动。</p><p>我们只需要对<strong>键盘按下的消息</strong>进行处理，定义<code>PLAYER_SPEED</code>常量表示玩家速度，并<strong>约定</strong>使用方向键控制玩家移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.message = WM_KEYDOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    player_pos.y -= PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    player_pos.y += PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    player_pos.x -= PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    player_pos.x += PLAYER_SPEED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br></pre></td></tr></table></figure><p>关于<a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">键码对照表</a>可以查看微软官方文档。</p><p>运行程序，我们可以发现角色可以移动了，但人物的移动“手感”有些奇怪。当我们按下方向键，角色向着对应的方向抽搐了一下，一段时间后才进行较为连贯的移动，在连续移动的过程中顿挫感也十分明显。</p><p>出现此等<strong>原因主要有二</strong>：<em>1</em>.<strong>首先</strong>是持续按下一小段时间后才开始连贯移动的问题。这是因为当我们按下方向键时，会首先有一个<code>WM_KEYDOWN</code>消息进入消息事件队列中，随后，当我们我们保持按键按下状态一段时间后，才会有接连不断的<code>WM_KEYDOWN</code>消息被触发；<em>2</em>.<strong>然后</strong>是移动过程中的卡顿问题。这是因为<code>WM_KEYDOWN</code>消息的产生是与我们的主循环<strong>异步进行</strong>的，且触发的频率与操作系统和硬件设备相关，这就导致在有些游戏帧中事件处理部分对多个<code>WM_KEYDOWN</code>消息进行了处理，而在其余游戏帧中<code>WM_KEYDOWN</code>消息较少或没有，这就导致角色在某些游戏帧中前进的距离较远&#x2F;近一些，在宏观上展现为移动过程中的卡顿感。</p><p>解决问题就要<strong>理清思路</strong>，我们抽象地总结实际的<strong>功能需求</strong>：当按键按下时，我们要确保在每一个游戏帧中都连贯的移动相同的距离；从玩家的行为角度讲，也就是玩家<strong>按下按键</strong>时，<code>WM_KEYDOWN</code>消息触发，标志角色<strong>开始移动</strong>；而当玩家<strong>按键抬起</strong>时，<code>WM_KEYUP</code>消息触发，标志<strong>移动结束</strong>。</p><p>那么我们的<strong>解决方案</strong>就明晰了。我们首先定义4个<code>bool</code>变量分别标志玩家是否向对应方向移动。在<strong>事件处理部分</strong>，不直接对玩家的位置数据进行操作，而是设置这些布尔变量的值，按键按下设为<code>true</code>、按键抬起设为<code>false</code>。在<strong>数据处理部分</strong>，我们再根据这些布尔变量的状态确定是否对玩家的位置进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line"><span class="type">bool</span> is_move_up = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_left = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_right = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line"><span class="keyword">while</span>(running)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.message = WM_KEYDOWN)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    is_move_up = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    is_move_down = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    is_move_left = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    is_move_right = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(msg.message = WM_KEYUP)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> VK_UP:</span><br><span class="line">                    is_move_up = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VK_DOWN:</span><br><span class="line">                    is_move_down = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">                <span class="keyword">case</span> VK_LEFT:</span><br><span class="line">                    is_move_left = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> VK_RIGHT:</span><br><span class="line">                    is_move_right = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(is_move_up) plaayer_pos.y -= PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_down) plaayer_pos.y += PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_left) plaayer_pos.x -= PLAYER_SPEED;</span><br><span class="line">        <span class="keyword">if</span>(is_move_right) plaayer_pos.x += PLAYER_SPEED;</span><br><span class="line">        <span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*...</span></span><br><span class="line"><span class="comment">...*/</span></span><br></pre></td></tr></table></figure><h3 id="3-2-敌人随机生成和索敌逻辑实现"><a href="#3-2-敌人随机生成和索敌逻辑实现" class="headerlink" title="3.2 敌人随机生成和索敌逻辑实现"></a>3.2 敌人随机生成和索敌逻辑实现</h3><h4 id="3-2-1-动画类实现"><a href="#3-2-1-动画类实现" class="headerlink" title="3.2.1 动画类实现"></a>3.2.1 动画类实现</h4><p>到目前为止，我们已经实现了人物面向左的动画，那么面向右的动画同理：定义IMAGE数组，加载图片到IMAGE数组中，然后在主循环中使用计数器来更新动画的帧索引，最后在绘图阶段将对应帧索引的图片绘制出来。但是这样一来，我们就有两部分<strong>能极度相似</strong>的<strong>动画播控代码</strong>了，若后续仍有动画加入到游戏中，我们就还要讲这些代码再写一遍，这就造成了<strong>代码冗余</strong>。</p><p>我们所使用的不同动画之间的<strong>区别</strong>，无非只是加载和显示的图片不同，而其中更新帧索引和绘制的部分都是完全一样的代码。</p><p>于是，我们可以将动画<strong>封装</strong>成结构体或类，相同的逻辑封装成成员方法，不同的部分使用参数传递。没错，这就是面向对象的3大特性之一的<strong>封装</strong>。</p><p>我们这里定义**<code>Animation</code>类<strong>，用来封装动画相关的数据和逻辑。接下来，我们在填充类的细节的时候，要考虑的就是有哪些数据和功能放在</strong>类内部**。</p><p><strong>首先是动画的图片加载。</strong>考虑到动画所包含的图片帧数量可能是不同的，需要动态的为图片对象序列分配内存，所以这里使用动态数组(向量)<code>vector</code>容器来代替我们常见的数组。</p><p><code>vector</code>容器是<strong>STL</strong>(标准模板库，Standard Template Library)中的内容,STL提供了许多方便我们开发中使用的工具。</p><p>为了避免不必要的拷贝构造，我们将<code>vector</code>内部存储的元素定义为IMAGE类型的指针：<code>vector&lt;IMAGE*&gt; -&gt; IMAGE*[]</code>。这里，二者的<strong>主要区别</strong>是，<code>vector</code>是一个根据元素数量动态增长的容器，而不需要像数组那样一开始便固定其容量大小。</p><ol><li><p>我们将动画帧序列的<code>vector</code>容器定义为<strong>私有成员</strong>;</p></li><li><p>加载图片的部分自然就需要放在构造函数里面。这里抽象一下加载动画所需要的参数<code>Animation(LPCTSTR path,int num,int inteval)</code>分别是：图片文件包含的路径、当前动画所使用的图片数量和帧间隔(由于在目前的动画中，帧与帧之间的时间间隔是固定的)；</p></li><li><p>循环加载图片。由于我们使用的图片素材命名都十分规律，所以可以直接将路径参数当作字符串格式化的模板；最后，我们将图片对象的指针添加到<code>vector</code>容器中，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCHAR path_file[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">&#123;</span><br><span class="line">    _stprintf_s(path_file,path,i);</span><br><span class="line">    </span><br><span class="line">    IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">    <span class="built_in">loadimage</span>(frame,path_file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于我们的<code>vector</code>内部存储的元素定义为IMAGE类型的指针，所以我们这里使用了<code>new</code>关键字来开辟内存。</p></li></ol><p>🔺很多人在初学时会忽略掉有关<strong>内存管理</strong>的问题，所以会养成内存泄漏的坏习惯。我们在这里使用了<code>new</code>关键字，那么我们就要马上警惕起来，在哪里使用<code>delete</code>释放掉内存？</p><p>就像在C语言中每个<code>malloc</code>对应一个<code>free</code>一样，在CPP中，我们要养成习惯去检查每一个<code>new</code>也要对应一个<code>delete</code>。</p><p>所以在<strong>析构函数</strong>中，我们需要遍历<code>vector</code>的每一个元素，一次将它<code>delete</code>掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animation</span>(LPCTSTR path,<span class="type">int</span> num,<span class="type">int</span> inteval)</span><br><span class="line">    &#123;</span><br><span class="line">        interval_ms = interval;</span><br><span class="line">        </span><br><span class="line">        TCHAR path_file[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; num;i ++)</span><br><span class="line">&#123;</span><br><span class="line">   _stprintf_s(path_file,path,i);</span><br><span class="line">    </span><br><span class="line">    IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">    <span class="built_in">loadimage</span>(frame,path_file);</span><br><span class="line">            frame_list.<span class="built_in">push_back</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Animation</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意这里使用vector存储原始指针似乎是危险的事情，可以使用智能指针。具体还请移步看相关资料文献。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>;i &lt; frame_list.<span class="built_in">size</span>();i ++)</span><br><span class="line">            <span class="keyword">delete</span> frame_list[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;IMAGE*&gt; frame_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-角色移动优化"><a href="#3-2-2-角色移动优化" class="headerlink" title="3.2.2 角色移动优化"></a>3.2.2 角色移动优化</h4><p><strong>然后是动画播放的部分</strong>。我们定义**<code>Play</code>函数**，暂时将帧索引更新的逻辑和渲染的代码都放置到函数中，这样我们就需要传入<code>x</code>和<code>y</code>两个参数来表示动画当前渲染的位置，最后我们还定义一个参数<code>delta</code>，用来表示距离上一次调用<code>Play</code>函数过去了多久时间。这其实已经将我们之前的动画计数器的思路转变为了计时器的思路。</p><p>那这两种思路之间有什么<strong>区别</strong>呢？</p><p>一般来说，一个动画的播放速度也就是<strong>帧间隔</strong>，应该是与实际时间有关的，而不是与游戏的帧率有关，我们希望的是无论游戏帧的频率有多快，动画的播放速度是一致的，而不是画面刷新越快，动画播放越快，这样整个游戏画面就如同开了“倍速”一样。所以使用与实际时间有关的定时器，会比每一下调用都累加一次的计数器更能满足这种需求。</p><p>我们只需要在每次调用<code>Play</code>函数时，对<code>timer</code>计时器变量增加对应的时间，如果定时器到达帧间隔，那么就切换动画图片到下一帧，同时重置定时器的值。最后通过我们之前定义好的<code>putimage_alpha</code>函数绘制当前动画帧，这是我们就可以使用简洁的代码来加载玩家角色向左向右的动画了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Animation <span class="title">anim_left_player</span><span class="params">(_T(<span class="string">&quot;img/player_left_%d.png&quot;</span>),<span class="number">6</span>,<span class="number">45</span>)</span></span>;</span><br><span class="line"><span class="function">Animation <span class="title">anim_right_player</span><span class="params">(_T(<span class="string">&quot;img/player_right_%d.png&quot;</span>),<span class="number">6</span>,<span class="number">45</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们定义<code>DrawPlayer</code>函数用以绘制玩家动画。由于需要左右翻转还需要传入玩家当前在x轴上的移动方向；动画实现左右翻转的逻辑也很简单：我们定义<code>facing_left</code>静态布尔变量，表示玩家动画是否面向左侧。在绘制动画时，只需要根据<code>facing_left</code>的值判断当前绘制的是向左还是向右的动画即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayer</span><span class="params">(<span class="type">int</span> delta,<span class="type">int</span> dir_x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(dir_x &lt; <span class="number">0</span>)</span><br><span class="line">    facing_left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dir_x &gt; <span class="number">0</span>)</span><br><span class="line">        facing_left = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(facing_left)</span><br><span class="line">    anim_left_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        anim_right_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让玩家再游戏画面中更加醒目，我们考虑在玩家的脚底添加<strong>阴影效果</strong>。阴影的实现同样也是使用图片素材<code>IMAGE img_shadow</code>，将它添加进来，并绘制在玩家的脚底。我们定义三个常量用来存储玩家的图片尺寸和阴影宽度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_WIDTH = <span class="number">80</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PLAYER_HEIGHT = <span class="number">80</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHADOW_WIDTH = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>在计算阴影的<strong>水平</strong>位置时，我们考虑将阴影居中，<code>int pos_shadow_x = player_pos_x + (PLAYER_WIDTH / 2 - SHADOW_WIDTH / 2);</code>；在计算<strong>竖直</strong>位置时，我们将它放到玩家脚底偏移一小段的地方。然后在绘制玩家动画之前绘制阴影图片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayer</span><span class="params">(<span class="type">int</span> delta,<span class="type">int</span> dir_x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos_shadow_x = player_pos_x + (PLAYER_WIDTH / <span class="number">2</span> - SHADOW_WIDTH / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> pos_shadow_y = player_pos_y + PLAYER_HEIGHT - <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">putimage_alpha</span>(pos_shadow_x,pos_shadow_y,&amp;img_shadow);</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(dir_x &lt; <span class="number">0</span>)</span><br><span class="line">    facing_left = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(dir_x &gt; <span class="number">0</span>)</span><br><span class="line">        facing_left = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(facing_left)</span><br><span class="line">    anim_left_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        anim_right_player.<span class="built_in">Player</span>(player_pos.x,player_pos.y,delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在玩家所有的<strong>移动功能都已经完成</strong>了。但是，移动手感似乎有些奇怪，玩家在斜向移动的时候速度快一些。</p><p>在处理玩家移动的代码中，我们发现，当我们同时按下处于x和y轴两个方向的按键时，玩家的位置坐标就在这一帧内向着两个方向<strong>都</strong>移动了一个单位距离，由勾股定理，这就导致这一帧玩家的位移距离是<strong>根号二</strong>倍的速度，于是就有了<strong>斜向移动更快</strong>的现象。我们这里可以通过<code>if else</code>来判断当玩家按下处于x和y轴两个方向的按键时，x和y坐标改变的数值变为<code>PALYER_SPPED/根号2</code>，但是要处理多种组合的情况，使用<code>if else</code>有些过于<strong>冗长</strong>，所以我们这里只需要借用一点点向量运算的知识，来确保玩家每次位移的大小都是相同的。</p><p>只需要确保运算时的速度方向向量是单位向量即可。</p><p>这里使用<code>double</code>来尽可能避免浮点数和整形互相转换的精度丢失问题，可是依旧会有小问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir_x = is_move_right - is_move_left;</span><br><span class="line"><span class="type">int</span> dir_y = is_move_down - is_move_up;</span><br><span class="line"><span class="type">double</span> len_dir = <span class="built_in">sqrt</span>(die_x * die_x + dir_y + dir_y);</span><br><span class="line"><span class="keyword">if</span>(len_dir != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> nomalized_x = dir_x / len_dir;</span><br><span class="line">    <span class="type">double</span> nomalized_y = dir_y / len_dir;</span><br><span class="line">    player_pos.x += (<span class="type">int</span>)(PLAYER_SPEED * normalized_x);</span><br><span class="line">    player_pos.y += (<span class="type">int</span>)(PLAYER_SPEED * normalized_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>,<span class="number">0</span>,&amp;img_backguond);</span><br><span class="line"><span class="built_in">DrawPlayer</span>(<span class="number">1000</span> / <span class="number">144</span>,dir_x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br></pre></td></tr></table></figure><p>再次运行程序，玩家的移动速度在各个方向上都确定了。</p><p>在玩家移动上，我们还有一个细节仍待处理：我们需要玩家<strong>始终处于画面内</strong>，也就是说玩家动画所在矩形必须位于1280X720尺寸的窗口内部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_WIDTH = <span class="number">1280</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> WINDOW_HEIGHT = <span class="number">720</span>;</span><br></pre></td></tr></table></figure><p>再根据按键输入更新玩家的位置后，我们就还需要对玩家的位置进行<strong>校准</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(player_pos.x &lt; <span class="number">0</span>) player_pos.x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(player_pos.y &lt; <span class="number">0</span>) player_pos.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(play_pos.x + PLAYER_WIDTH &gt; WINDOW_WIDTH) player_pos.x = WINDOW_WIDTH - PLAYER_WIDTH;</span><br><span class="line"><span class="keyword">if</span>(play_pos.y + PLAYER_HEIGHT &gt; WINDOW_HEIGHT) player_pos.y = WINDOW_HEIGHT - PLAYER_HEIGHT;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-玩家类和敌人类实现"><a href="#3-2-3-玩家类和敌人类实现" class="headerlink" title="3.2.3 玩家类和敌人类实现"></a>3.2.3 玩家类和敌人类实现</h4><p>我们使用野猪🐗表示敌人，野猪同样也有面向左和右两套动画，从<strong>代码设计角度考虑</strong>讲，让这些野猪Animation对象与玩家的Animation对象<strong>混杂</strong>在一起显然不好。</p><p>所以我们再次使用<strong>封装</strong>这一特性，将玩家的逻辑封装到<code>Player</code>类中，而与敌人相关的逻辑就封装在<code>Enemy</code>类中。虽然我们可以将玩家和敌人共同的逻辑<strong>抽象出来</strong>，定义<strong>更基础的类</strong>，如<code>Character</code>角色或<code>GameObject</code>游戏对象，这些设计会涉及到面向对象中另<strong>两大特性</strong>——<strong>继承和多态</strong>。</p><p>但，目前我们不使用继承和多态进行实践，而仅使用封装来确保数据和逻辑。</p><p><strong>首先，玩家类<code>Player</code>的实现。</strong></p><p>我们<strong>首先</strong>将和玩家类相关的散落在外部的成员变量和常量放在<code>Player类</code>中；然后定义<code>ProcessEvent</code>函数来处理玩家的操作消息、定义<code>Move</code>函数来处理玩家的移动、定义<code>Draw</code>函数来绘制玩家；然后将对应逻辑的代码移动到函数内部，注意一些微调整。最终玩家类的代码就完成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Player</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img_shadow, _T(<span class="string">&quot;img/shadow_player.png&quot;</span>));</span><br><span class="line">anim_left = <span class="keyword">new</span> <span class="built_in">Animation</span>(_T(<span class="string">&quot;img/player_left_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>);</span><br><span class="line">anim_right = <span class="keyword">new</span> <span class="built_in">Animation</span>(_T(<span class="string">&quot;img/player_right_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Player</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> anim_left;</span><br><span class="line"><span class="keyword">delete</span> anim_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessEvent</span><span class="params">(<span class="type">const</span> ExMessage&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPEED = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME_WIDTH = <span class="number">80</span>; <span class="comment">// 玩家宽度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FRAME_HEIGHT = <span class="number">80</span>; <span class="comment">// 玩家高度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SHADOW_WIDTH = <span class="number">32</span>; <span class="comment">// 阴影宽度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IMAGE img_shadow;</span><br><span class="line">Animation* anim_left;</span><br><span class="line">Animation* anim_right;</span><br><span class="line">POINT position = &#123; <span class="number">500</span>,<span class="number">500</span> &#125;; <span class="comment">// 玩家位置</span></span><br><span class="line"><span class="type">bool</span> is_move_up = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_left = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_right = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>然后，是子弹类<code>Bullet</code>的实现。</strong></p><p>其中并没有太多复杂的数据和逻辑。成员变量只需要有位置信息，而在<strong>渲染方法</strong><code>Draw</code>里面我们使用橙红色填充圆来进行绘制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">POINT position = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Bullet</span>() = <span class="keyword">default</span>;</span><br><span class="line">~<span class="built_in">Bullet</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">setlinecolor</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">155</span>, <span class="number">50</span>));</span><br><span class="line"><span class="built_in">setfillcolor</span>(<span class="built_in">RGB</span>(<span class="number">200</span>, <span class="number">75</span>, <span class="number">10</span>));</span><br><span class="line"><span class="built_in">fillcircle</span>(position.x, position.y, RADIUS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> RADIUS = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>随后，是敌人类<code>Enemy</code>的实现。</strong></p><p>我们<strong>仿照</strong>着Player类定义Enemy类。</p><p>接下来便是设计敌人类中的成员方法，不过在此之前，我们要先想清楚敌人的<strong>行动逻辑</strong>：我们希望敌人从地图外的<strong>随机位置刷新</strong>出来，并<strong>向着玩家移动</strong>，敌人<strong>触碰玩家</strong>时会对玩家造成伤害<strong>游戏结束</strong>；敌人<strong>触碰</strong>到玩家周围的<strong>子弹</strong>时会<strong>消失</strong>。</p><p><strong>首先是敌人的刷新机制</strong>，即敌人在生成时随机初始化自己位置。所以此逻辑要放在<strong>构造函数</strong>中。地图有四条边，这里定义<code>SpawnEdge</code>枚举用以标识敌人出生的边界，使用<strong>随机数%4</strong>后便可实现随机地图边界的效果。接下来是地图的坐标值，分类讨论，对于上边界它的x位置坐标应该是随机的，其他同理推出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敌人生出边界</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">SpawnEdge</span></span><br><span class="line">&#123;</span><br><span class="line">Up = <span class="number">0</span>,</span><br><span class="line">Down,</span><br><span class="line">Left,</span><br><span class="line">Right</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将敌人放置在地图边界外的随机处</span></span><br><span class="line">SpawnEdge edge = (SpawnEdge)(<span class="built_in">rand</span>() % <span class="number">4</span>);</span><br><span class="line"><span class="keyword">switch</span> (edge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Up:</span><br><span class="line">position.x = <span class="built_in">rand</span>() % WINDOW_WIDTH;</span><br><span class="line">position.y = -FRAME_HEIGHT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Down:</span><br><span class="line">position.x = <span class="built_in">rand</span>() % WINDOW_WIDTH;</span><br><span class="line">position.y = WINDOW_HEIGHT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Left:</span><br><span class="line">position.x = -FRAME_WIDTH;</span><br><span class="line">position.y = <span class="built_in">rand</span>() % WINDOW_HEIGHT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SpawnEdge::Right:</span><br><span class="line">position.x = WINDOW_WIDTH;</span><br><span class="line">position.y = <span class="built_in">rand</span>() % WINDOW_HEIGHT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后是碰撞向相关函数</strong>，检测与子弹发生的碰撞传入<code>Bullet</code>参数，检测与玩家发生的碰撞传入<code>Player</code>参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBulletCollision</span><span class="params">(<span class="type">const</span> Bullet&amp; bullet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckPlayerCollision</span><span class="params">(<span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Move</code>函数需要始终追寻玩家移动，所以传入<code>Player</code>参数。</p><p><strong>值得注意的是</strong>，<u>我们传入的参数都应添加引用这与使用指针进行参数传递类似，都是为了避免在传入参数过程中对传入的对象进行了不必要的拷贝构造；同时，又添加<code>const</code>限定符来避免在函数内部不小心对参数进行了修改，这是一个好习惯。</u></p><p><strong><code>Move</code>函数实现逻辑与玩家类十分相似</strong>，我们只需要将玩家的位置与敌人的位置进行作差，即可得到敌人需要移动的向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> POINT&amp; player_position = player.<span class="built_in">GetPosition</span>();</span><br><span class="line"><span class="type">int</span> dir_x = player_position.x - position.x;</span><br><span class="line"><span class="type">int</span> dir_y = player_position.y - position.y;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> len_dir = <span class="built_in">sqrt</span>(dir_x * dir_x + dir_y * dir_y);</span><br><span class="line"><span class="keyword">if</span> (len_dir != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> nomalized_x = dir_x / len_dir;</span><br><span class="line"><span class="type">double</span> nomalized_y = dir_y / len_dir;</span><br><span class="line">position.x += (<span class="type">int</span>)(SPEED * nomalized_x);</span><br><span class="line">position.y += (<span class="type">int</span>)(SPEED * nomalized_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dir_x &lt; <span class="number">0</span>) facing_left = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> facing_left = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>随后是绘制敌人的<code>Draw</code>函数</strong>，也与玩家类中的实现十分相似。由于敌人始终处于移动状态，所以我们不需要使用<code>static</code>变量静态保存无移动时的动画翻转状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pos_shadow_x = position.x + (FRAME_WIDTH / <span class="number">2</span> - SHADOW_WIDTH / <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> pos_shadow_y = position.y + FRAME_HEIGHT - <span class="number">35</span>;</span><br><span class="line"><span class="built_in">putimage_alpha</span>(pos_shadow_x, pos_shadow_y, &amp;img_shadow);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (facing_left)</span><br><span class="line">anim_left-&gt;<span class="built_in">Play</span>(position.x, position.y, delta);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">anim_right-&gt;<span class="built_in">Play</span>(position.x, position.y, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏中的面向对象的设计已初具雏形，现在我们要考虑的是：如何在主循环<strong>实例化</strong>这些对象。</p><p>玩家对象全局只有一个，所以我们定义在<strong>主循环外部</strong>；在<strong>消息处理</strong>部分，调用<code>Player</code>类的<code>ProcessEvent</code>方法处理玩家在操作事件；在数据处理部分调用<code>Move</code>进行移动；在渲染部分调用<code>Draw</code>来绘制画面。</p><p>由于游戏中敌人数量也是<strong>动态</strong>的，所以我们这里同样使用<code>vector</code>来存储<code>Enemy</code>的对象指针。在主循环中，我们使用一个定义<code>TryGenerateEnemy</code>函数来生成敌人，为了简单起见，函数内置了一个计数器，当到达指定时间间隔便向容器中添加新的敌人。在数据如理部分，我们遍历<code>vector</code>中的每一个敌人依次调用<code>Move</code>方法，在渲染部分也依次调用<code>Draw</code>方法。</p><p><del>（PS ：最后，我们会发现<code>Move()</code>函数中，角色位置改变运用了浮点型强转为整形所造成精度丢失，是玩家和敌人的SPEED范围有限，这是一个问题。）</del></p><h3 id="3-3-2D碰撞检测和音效播控"><a href="#3-3-2D碰撞检测和音效播控" class="headerlink" title="3.3 2D碰撞检测和音效播控"></a>3.3 2D碰撞检测和音效播控</h3><h4 id="3-3-1-子弹碰撞逻辑"><a href="#3-3-1-子弹碰撞逻辑" class="headerlink" title="3.3.1 子弹碰撞逻辑"></a>3.3.1 子弹碰撞逻辑</h4><p>在前面的代码中，我们已经定义了子弹类，也定义了敌人与子弹和玩家的碰撞方法。但实际的<strong>碰撞逻辑仍未实现</strong>。</p><p><strong>首先是敌人和子弹的碰撞</strong>。在<code>CheckBulletCollision</code>方法中，我们将子弹等效为一个点。如果想要检定这两者的碰撞，那么只要检测这个<strong>点是否在敌人所处矩形内</strong>。而判断二维平面内点在矩形内十分简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckBulletCollision</span><span class="params">(<span class="type">const</span> Bullet&amp; bullet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将子弹等效为点</span></span><br><span class="line"><span class="type">bool</span> is_overlap_x = bullet.position.x &gt;= position.x &amp;&amp; bullet.position.x &lt;= position.x + FRAME_WIDTH;</span><br><span class="line"><span class="type">bool</span> is_overlap_y = bullet.position.y &gt;= position.y &amp;&amp; bullet.position.y &lt;= position.y + FRAME_HEIGHT;</span><br><span class="line"><span class="keyword">return</span> is_overlap_x &amp;&amp; is_overlap_y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后是敌人和玩家的碰撞检测</strong>，这就涉及到<strong>两个矩形之间的相交检测</strong>。但是，如果我们将二者的碰撞模型抽象成两个矩形的相交，我们考虑这样一种极端情景：敌人的位置处于玩家的对角线方向处，此时二者并未重合，但是数据逻辑上却判定为碰撞，这会让玩家非常困惑。所以，<u>在大部分2D游戏作品中的程序设计中，对于这类受击碰撞箱，其实是要小于玩家所在的碰撞箱</u>。考虑到我们的游戏敌人的尺寸并不大，以及这类割草游戏中对于碰撞的检定不应过于严格，所以我们<strong>以敌人的中心点位置作为其碰撞坐标</strong>，只有当敌人的中心点在玩家矩形箱内，二者才发生碰撞，敌人才能对玩家造成伤害。所以在<code>CheckPlayerCollision</code>方法中，我们<strong>首先</strong>应该计算出敌人的判定点位置，<strong>随后</strong>再判断这个点是否在玩家当前所在矩形内。注意，由于我们这里需要获取玩家的实时位置，所以我们扩展了玩家类的方法，为它提供了一个<code>GetPosition</code>方法来返回玩家当前坐标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> POINT&amp; <span class="title">GetPosition</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，我们还需要在<strong>主循环</strong>中遍历敌人列表，依次检测他们是否与玩家发生了碰撞，当二者发生碰撞时，我们弹出提示信息，结束游戏。</p><p><strong>接下来</strong>，我们要让<strong>子弹</strong>显示在画面中了。</p><p>首先定义子弹<code>vector</code>并初始化它的长度为3。随后，我们定义<code>UpdateBullets</code>函数用以在主循环实现子弹实时跟随玩家的逻辑。</p><p>三颗子弹只是均匀做圆周运动太过死板，所以我们让子弹有除去圆周运动的切向速度外，还有一个不断波动的径向速度；在视觉效果上，这些子弹会围绕着玩家进行时近时远的圆周运动。</p><p>我们<strong>首先定义子弹的径向速度和切向速度</strong>。切向速度决定了圆周运动的快慢，而径向速度决定了子弹距离玩家时近时远波动速度。计算子弹之间的角度间隔也十分简单。最后我们遍历子弹列表中的每一个子弹，根据玩家当前的位置依次修改它们的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateBullets</span><span class="params">(std::vector&lt;Bullet&gt;&amp; bullet_list, <span class="type">const</span> Player&amp; player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> RADIAL_SPEED = <span class="number">0.0045</span>; <span class="comment">// 径向</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> TANGENT_SPEED = <span class="number">0.0055</span>; <span class="comment">// 切向</span></span><br><span class="line"><span class="type">double</span> radian_interval = <span class="number">2</span> * <span class="number">3.14159</span> / bullet_list.<span class="built_in">size</span>(); <span class="comment">// 子弹之间的弧度间隔</span></span><br><span class="line">POINT player_position = player.<span class="built_in">GetPosition</span>();</span><br><span class="line"><span class="type">double</span> radius = <span class="number">100</span> + <span class="number">25</span> * <span class="built_in">sin</span>(<span class="built_in">GetTickCount</span>() * RADIAL_SPEED);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bullet_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> radian = <span class="built_in">GetTickCount</span>() * TANGENT_SPEED + radian_interval * i;</span><br><span class="line">bullet_list[i].position.x = player_position.x + player.FRAME_WIDTH / <span class="number">2</span> + (<span class="type">int</span>)(radius * <span class="built_in">sin</span>(radian));</span><br><span class="line">bullet_list[i].position.y = player_position.y + player.FRAME_HEIGHT / <span class="number">2</span> + (<span class="type">int</span>)(radius * <span class="built_in">cos</span>(radian));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，我们要编写<strong>敌人受击消失</strong>的逻辑了。</p><p>为了更通用的设计，我们给<code>Enemy</code>类中新增了两个方法<code>Hurt</code>和<code>CheckAlive</code>，同时，新增<code>alive</code>布尔变量标识敌人当前是否是存活状态。</p><p><code>Hurt</code>方法为受击方法，当敌人收到攻击时便会调用；<code>CheckAlive</code>方法为敌人存活检测方法，函数直接返回<code>alive</code>成员的值，用来在类外获取当前敌人存活状态。</p><p>在<code>Hurt</code>方法中，常见的思路是递减敌人血量，这里我们使用最简单的方法，让敌人一被击必杀。</p><p>那么在主循环中，当<code>CheckBulletCollision</code>成功时，便要调用敌人类的<code>Hurt</code>方法，而在碰撞检测结束后，我们还需要遍历现存的敌人列表，依次检查已经被击杀的敌人，并将它们从游戏中删掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Enemy* enemy : enemy_list)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> Bullet&amp; bullet : bullet_list)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (enemy-&gt;<span class="built_in">CheckBulletCollision</span>(bullet))</span><br><span class="line">&#123;</span><br><span class="line">enemy-&gt;<span class="built_in">Hurt</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用<code>swap</code>和<code>pop_back</code>组合技来实现从<code>vector</code>中删除元素，这是一种<strong>在元素次序无关时性能较好的删除方法</strong>，原理十分简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; enemy_list.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Enemy* enemy = enemy_list[i];</span><br><span class="line"><span class="keyword">if</span> (!enemy-&gt;<span class="built_in">CheckAlive</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(enemy_list[i], enemy_list.<span class="built_in">back</span>());</span><br><span class="line">enemy_list.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">delete</span> enemy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仿照其他游戏，<strong>得分机制</strong>是必不可少的。</p><p>所以，我们定义<code>score</code>变量记录玩家得分，并定义<code>DrawPlayerScore()</code>绘制得分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制玩家得分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPlayerScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> TCHAR text[<span class="number">64</span>];</span><br><span class="line">_stprintf_s(text, _T(<span class="string">&quot;当前玩家得分：%d&quot;</span>), score);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line"><span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">85</span>, <span class="number">185</span>));</span><br><span class="line"><span class="built_in">outtextxy</span>(<span class="number">10</span>, <span class="number">10</span>, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的游戏基本上已经完成，但总感觉不得劲，哎？没错，音效和音乐。</p><h4 id="3-3-2-音效音乐播控"><a href="#3-3-2-音效音乐播控" class="headerlink" title="3.3.2 音效音乐播控"></a>3.3.2 音效音乐播控</h4><p>这里提供一种较为简单轻巧的<strong>音乐播放实现</strong>方式：<code>mciSendString</code>。</p><p>我们首先需要将<code>mus</code>文件素材放置对应目录下，随后在代码种来链接对应的库<code>#pragma comment(lib,&quot;Winnm.lib&quot;)</code>。</p><p>这个函数的前三个字母<code>mci</code>代表了<code>Media Control Interface</code>即：媒体控制接口。它的作用更像是我们对<code>Windows</code>系统发号施令，我们把字符串形式的命令告诉系统，让它们来帮我们播放声音。</p><p><a href="https://learn.microsoft.com/en-us/previous-versions/dd757161(v=vs.85)">使用文档</a></p><p>我们只需要关注第一个参数，也就是我们要对<code>Windows</code>系统发出的“命令”，当我们<strong>加载背景音乐</strong>的时候，我们可以编写这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;open mus/bgm.mp3 alias bgm&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样便是告诉系统：你要把<code>mus</code>目录下<code>bgm.mp3</code>文件加载到程序中，并且在后续的命令中，我们给这个音乐取名为”<code>bgm</code>“。</p><p>当我们需要<strong>播放背景音乐</strong>时，我们呢&#x3D;只需要写下这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;play bgm repeat from 0&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>这样就是在和系统说：现在我要播放先前已经追备好的名为<code>bgm</code>的音乐，并让它从头循环播放。于是，背景音乐便添加完成。</p><p>那么子弹击中敌人的音效也十分简单，我们编写相似的代码加载<code>hit.wav</code>文件并取名为<code>hit</code>，并在子弹碰撞时播放，注意此时并未添加<code>repeat</code>命令，来确保受击音效不会出发后永无休止的循环播放下去。</p><p>至此，游戏内部数据逻辑已全部完成，除去一些卡顿的bug，会在后续课程中优化。</p><h3 id="3-4-用户界面实现和设计模式基础"><a href="#3-4-用户界面实现和设计模式基础" class="headerlink" title="3.4 用户界面实现和设计模式基础"></a>3.4 用户界面实现和设计模式基础</h3><h4 id="3-4-1-导言"><a href="#3-4-1-导言" class="headerlink" title="3.4.1 导言"></a>3.4.1 导言</h4><p>假设这样一个场景：在一个游戏中，出现在你的视野中的树木数以千计，虽然我们会惊叹建模师和贴图美术师们逼真的还原水平，但程序并不在乎。它只关心如何从磁盘中加载这些数据，并将其高效地渲染在游戏窗口。</p><p>我们随意挑出一棵树，若这棵树是绘制在3D场景中，构成它的资源可以笼统的分为模型和贴图两类。在许多3A大作的游戏资源包中，模型和贴图相关的资源所占的比例是极高的。它们不仅占据了大量的硬盘空间，也占据了游戏启动时加载的大部分时间。如果我们把一棵树在内存中所占用的资源为10MB计算，场景中1000棵树就需要10000MB，也就是说，只是为了把屏幕上把这些树绘制出来就需要占用电脑9.8GB左右的内存。这对于玩家显然是不合理的，况且想要从磁盘上加载1000个模型，也需要十分恐怖的加载时间。</p><p>那么我们可能会问，我<strong>只需要加载一棵树</strong>的模型，然后再游戏里把他绘制1000次不就好了？确实如次，虽然在现代的游戏技术中，对于树木这种大批量出现的渲染任务已有许多成熟的解决方案，但他们都离不开一个设计模式——<strong>“享元模式”</strong>。</p><h4 id="3-4-2-享元模式"><a href="#3-4-2-享元模式" class="headerlink" title="3.4.2 享元模式"></a>3.4.2 享元模式</h4><p>“<strong>享元</strong>”即“共享元素”的意思。”<strong>享元模式</strong>“是设计模式中使用热度极高的模式之一。（<strong>设计模式</strong>是一套被反复使用 多数人知晓的 经过分类编码的 代码设计经验的总结），他不像<code>C++</code>等编程语言的语法那样白纸黑字，但也是一套自成体系的<strong>方法论</strong>。</p><p>若我们把算法比作功夫中的内功，那么设计模式就是外功招式。</p><p>就像在引言所讲述的树林场景，我们在设计对应代码结构时，直截了当的思路是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    Model model; <span class="comment">// 树的模型</span></span><br><span class="line">    Texture texture; <span class="comment">// 树的贴图</span></span><br><span class="line">    <span class="type">int</span> x,y,z; <span class="comment">// 树的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在使用享元模式进行重新设计后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树的资产结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    Model model; <span class="comment">// 树的模型</span></span><br><span class="line">    Texture texture; <span class="comment">// 树的贴图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 树结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeAsset* asset; <span class="comment">// 资产指针</span></span><br><span class="line">    <span class="type">int</span> x,y,x; <span class="comment">// 树的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再重新设计的代码中，我们把绘制一棵树所需的数据里面最庞大的部分挑出来。1000个Tree对象中模型和贴图均使用<strong>同一个</strong><code>TreeAsset</code>对象中的数据，这样就可以节省大量的内存空间。</p><p>回看我们的代码，这时我们可以看到：在<code>Animation</code>的设计中，每一个<code>Animation</code>对象都拥有自己的动画帧列表；而在<code>Enemy</code>类中，每一个敌人，都拥有两个<code>Animation</code>对象，这就意味着我们在游戏中每次随机刷新一个野猪，都会从磁盘中加载两套动画的图片到内存中，虽然我们所使用的图片不如3D模型那般恐怖，并不会导致严重的内存爆满问题，但是从磁盘上读取数据的这个I&#x2F;O操作本身就是十分耗时的工作，尤其是在一些机械硬盘上磁盘速度较慢的情况时，刷新敌人的时候便会有明显的卡顿感。在主循环中动态的从磁盘中加载数据，这本身也违背了我们之前认识到的：“主循环中应尽量避免耗时过长的任务”这一设计准则。<strong>加载数据</strong>的工作应该放置到我们游戏框架中<strong>初始化</strong>的部分去做。毕竟从游戏体验角度，对玩家来说，比起在游戏过程中出现卡帧和掉帧等情况，更愿接受在加载时稍微多等一会儿。</p><p>所以这里我们要对<code>Animation</code>类进行重新的拆分和设计。我们思考一下：游戏画面中的野猪们在动画方面可以共享的元素有哪些呢？</p><p>那当然是<code>IMAGE</code>对象构成的<code>vector</code>了；而动画当前正在播放第几帧等状态信息就各异了，所以就不能放在共享的数据里面。</p><p>因此，我们重新定义<code>Atlas</code>类来表示动画所使用的“图集”，其所需的成员变量，构造和析构函数都是从<code>Animation</code>中“拆分”下来的。而在整个游戏中，我们只需要用四个共用的<code>Atlas</code>对象，也就是玩家和敌人分别向左和向右的动画。我们将它们的指针定义为全局变量，稍后进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Atlas</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Atlas</span>(LPCTSTR path, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">TCHAR path_file[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">_stprintf_s(path_file, path, i);</span><br><span class="line"></span><br><span class="line">IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line"><span class="built_in">loadimage</span>(frame, path_file);</span><br><span class="line">frame_list.<span class="built_in">push_back</span>(frame);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Atlas</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; frame_list.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="keyword">delete</span> frame_list[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::vector&lt;IMAGE*&gt; frame_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而将图片序列拆分出去的<code>Animation</code>类，就需要持有<code>ATlas</code>类对象的指针了，在初始化时，将它保存在成员变量中。</p><p>这里需要<strong>注意</strong>：由于<code>Atlas</code>是<code>Animation</code>之间共享的<strong>公共资产</strong>，所以千万不能在<code>Animation</code>的析构函数中使用<code>delete</code>将<code>Atlas</code>指针释放掉，<code>Atlas</code>的生命周期应由更上一层的代码进行控制。</p><p>这样敌人刷新时可能的卡顿就一去不复返了。这里蒟蒻注意到在每个对象中阴影图片的绘制也是都要读取、再加载渲染。可以试着用类似的思想实现一下。</p><h4 id="3-4-3-用户界面"><a href="#3-4-3-用户界面" class="headerlink" title="3.4.3 用户界面"></a>3.4.3 用户界面</h4><p>众所周知，<code>EasyX</code>作为2D图形库，它与GUI库是有区别的。我们可以十分便利的调用函数绘制点线面各种图形。但是想要在窗口中实现一个带有交互效果的按钮，这就需要我们自己实现了。</p><p>Qt作为GUI程序开发框架的定位，决定了它必然会屏蔽太多底层设计。例如我们在目前程序中所使用的“主循环”，这些封装和屏蔽从工程角度讲是再合适不过的，但是我们在探索游戏开发的初期也就是以学习为目的进行实践的过程中，我们更希望有一个功能简单直接容易上手的图形库来让我们选取，而不是直接使用GUI库。当然，在游戏开发中，Qt这些有着明确定位的GUI框架一般也不会直接参与到游戏程序本身的制作中，而是作为游戏开发工具链上的一环。想要在游戏这种即时渲染的框架中渲染更具有通用性的GUI，<code>imGUI</code>等技术是在合适不过的了。那么想要实现GUI组件，在现有程序中该如何编写呢？</p><p>这里，有一句<strong>GUI设计哲学</strong>“<u>一个按钮之所以是一个按钮，不是因为它长得像一个按钮，而是因为它能够对交互事件做出响应</u>”。无论是文本还是图片，如果能够对玩家的点击事件进行捕获，并修改对应的数据进行响应，那么它就是一个按钮。</p><p>这里我们每个按钮提供了3张图片，分别对应了按钮的<code>iale</code>、<code>hovered</code>、<code>push</code>形态。</p><p>现在回到代码，来考虑<strong>按钮类</strong>该如何设计。</p><p>按钮必然需要一个RECT变量来描述自己的位置和大小，这在判断鼠标响应时是必须的。然后是3张<code>IMAGE</code>图片变量。最后我们还应定义按钮当前的状态枚举变量。，这是因为按钮的悬停、按下等状态实在消息处理时进行判断的 ，而在主循环的每一帧画面渲染时，我们都需要根据现有状态选择对应图片进行绘制。</p><p>然后就是内部成员函数的编写，绘制函数、事件处理函数。注意在开始编写之前一定要理清代码逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Button</span>(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_hovered, LPCTSTR path_img_pushed)</span><br><span class="line">&#123;</span><br><span class="line">region = rect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img_idle, path_img_idle);</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img_hovered, path_img_hovered);</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img_pushed, path_img_pushed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Button</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProccessEvent</span><span class="params">(<span class="type">const</span> ExMessage&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg.message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_MOUSEMOVE:</span><br><span class="line"><span class="keyword">if</span> (status == Status::Idle &amp;&amp; <span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">status = Status::Hovered;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status == Status::Hovered &amp;&amp; !<span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">status = Status::Idle;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CheckCursoHit</span>(msg.x, msg.y))</span><br><span class="line">status = Status::Pushed;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONUP:</span><br><span class="line"><span class="keyword">if</span> (status == Status::Pushed)</span><br><span class="line"><span class="built_in">OnClick</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Status::Idle:</span><br><span class="line"><span class="built_in">putimage</span>(region.left, region.top, &amp;img_idle);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Status::Hovered:</span><br><span class="line"><span class="built_in">putimage</span>(region.left, region.top, &amp;img_hovered);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Status::Pushed:</span><br><span class="line"><span class="built_in">putimage</span>(region.left, region.top, &amp;img_pushed);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span></span><br><span class="line">&#123;</span><br><span class="line">Idle = <span class="number">0</span>,</span><br><span class="line">Hovered,</span><br><span class="line">Pushed</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RECT region;</span><br><span class="line">IMAGE img_idle;</span><br><span class="line">IMAGE img_hovered;</span><br><span class="line">IMAGE img_pushed;</span><br><span class="line">Status status = Status::Idle;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 检测鼠标点击</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckCursoHit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt;= region.left &amp;&amp; x &lt;= region.right &amp;&amp; y &gt;= region.top &amp;&amp; y &lt;= region.bottom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，便可以此为基类编写特殊按钮类了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuitGameButton</span> :<span class="keyword">public</span> Button</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">QuitGameButton</span>(RECT rect,LPCTSTR path_img_idle, LPCTSTR path_img_howered, LPCTSTR path_img_pushed)</span><br><span class="line">:<span class="built_in">Button</span>(rect,path_img_idle,path_img_howered,path_img_pushed)&#123;&#125;</span><br><span class="line">~<span class="built_in">QuitGameButton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StartGameButton</span> :<span class="keyword">public</span> Button</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">StartGameButton</span>(RECT rect, LPCTSTR path_img_idle, LPCTSTR path_img_howered, LPCTSTR path_img_pushed)</span><br><span class="line">:<span class="built_in">Button</span>(rect, path_img_idle, path_img_howered, path_img_pushed) &#123;&#125;</span><br><span class="line">~<span class="built_in">StartGameButton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnClick</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">is_game_started = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mciSendString</span>(_T(<span class="string">&quot;play bgm repeat from 0&quot;</span>), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意我们在这里，将主循环的播放音乐移了过来。</p><p>另外还设置了2个全局变量<code>running</code>和<code>is_game_start</code>。</p><p>再对主函数内代码稍加修改，此次的项目就竣工了。</p><p>当然，这只是游戏基本操作的实现，还可以加入其他东西。</p><p>请前往B站up**<a href="https://space.bilibili.com/25864506">Voidmatrix</a>**那里进一步学习。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习与考试</title>
      <link href="/2024/10/22/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%80%83%E8%AF%95/"/>
      <url>/2024/10/22/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>写于2021年秋</p><h2 id="学习与考试"><a href="#学习与考试" class="headerlink" title="学习与考试"></a>学习与考试</h2><p>一个紧急的必要是，我们要明辨<strong>今日学习之目的</strong>。</p><p>​而一个非常常见的错误状态是认为<strong>学习的目的是考试</strong>。<br>学习是手段，考试是目的。那么这种观点就隐含着这样一种庸俗的实践观：把考试看成是一种实践，而把学习看成是一种认识。考试为什么是实践？考试可以带来好处，获得利益。因此，很多人是把考试看成一种实践活动：考试就是混文凭、拿证书，捞身份，进圈子，抬地位，赚好处……关键是，我们需要意识到学习确实是认识，认识如何得到上面的奖励，来有益于自身生存发展——不管是物质层面的充裕，还是精神层面的富足。<br>但是在这种情况下，通过考试得到基本的这些好处之后的具体实践怎么办？绝大部分都会变成沉溺于声色犬马的“享乐主义”，或“躲进小楼，不知西东”自以为精神超脱之人。由这样一环一环的考试来驱动你学习，那就会失去严肃的、有组织计划的、有学习意愿的主动性，就会失去“选择学哪些东西，考什么东西”的这种本能。</p><p>​同时，今日学生可能从初中就意识到考试本身不是目的，<strong>考试是以学习为目的</strong>，换言之，学习是为了让自己可以进一步的学习。<br>比如初中学习为了到市重点更好的学习，而高中学习为了进双一流受到更严格的科学训练和人文训练。这种以学习本身为目的的学习，也就像列宁主义的一个很重要的口号“学习，学习，再学习！”是以他智性能力的增长本身为目的的。<br>人类这种动物，感觉到自己智性能力的增长似乎会带来极大的快乐。或者说，好奇心被满足了，会有欲望，会带来快乐。刷个不停抖音或更进一步说低俗的标题党都是利用人的好奇心来俘获你。好奇会让我们满足，所以人类的智性能力的增长，它有一种自发的欲望。<br>因此，一旦我们以此为目的学习，这个学习会让我们的生活有更多的技能，更多的知识去支撑，让我们的生活变得越来越好，那我们就会有更多的富余去学习，实际上是具有极大实践指导意义。</p><p>​但按上述逻辑，学习考试只是让我们有更充裕的资源来学习，进而提高自己、发展自己，那么我们需要追问：发展自己<strong>最终是为了什么？</strong></p><p>​<strong>为人生的变故，为历史的变革做好准备。</strong></p><p>​为什么高考好像表面上会成为学习的目的？<br>不是因为它是考试，而是因为它是一次人生的重大变故，它不仅仅对于我们的求学，更对于我们的人生具有重大的意义。</p><p>​一代人有一代人的长征，每个时代赋予每个时代青年不同的使命，从古代追求经世济民，国泰民安而皓首穷经的书生到我们一般所说的为中华之崛起而读书。那现在中华已然可以算是崛起了，我们进一步要说为社会进步和发展而学习，为人民的利益和幸福而学习，为人类的解放和正义而学习。<br>学习具有时代指向性，我们在这个时代主要面对的就是生产活动本身的社会性和生产资料的私有性之间的一个矛盾，它会导致了两极分化和重复出现的危机、各种乱象。但我们要做好各式各样的准备去面对这些东西。这个准备就包含知识学习的准备。<br>你不能说躺平在地上，就不管了。我辈要去主动迎接那些变故，要主动去预估、去探索，看到会有什么样的变故在里面等着我，或者说自己可以去寻找一条新的进阶之路，去发展、去进步。<br>恰如习书记对青年寄语“新时代中国青年要增强学习紧迫感，如饥似渴、孜孜不倦学习，在学习中增长知识、锤炼品格，在实践中增长才干、练就本领，以真才实学服务人民！”勿要沦为如放羊娃那样的人生悲剧轮回。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旧文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的姥爷</title>
      <link href="/2024/10/22/%E6%88%91%E7%9A%84%E5%A7%A5%E7%88%B7/"/>
      <url>/2024/10/22/%E6%88%91%E7%9A%84%E5%A7%A5%E7%88%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="我的姥爷"><a href="#我的姥爷" class="headerlink" title="我的姥爷"></a>我的姥爷</h2><p>我的姥爷，在我心中一直是值得敬仰的人。自幼起，便对他有一种深藏的崇拜。他不常说夸人的话，却总能从他脸上的细微表情中，读出他对我们的期待与关心。</p><p>家里人常说，姥爷是个柔弱的人——身体柔弱，性格也柔和。他的父亲，即我的老太，是一位地主，但并不像影视剧中的那种凶恶剥削者。事实上，有些地主，如同我老太一般，与民同耕作、同分享丰收果实。我姥爷出生在1949年，新中国成立前后。虽然家道中落，但生活依然富足安定。姥爷就在这样的环境下，仿若温室中的花朵，娇养长大。</p><p>然而，命运似乎总有反转。也许是命中注定柔弱的姥爷遇上了如我姥娘般刚强的女人。姥娘的刚毅不仅体现在她的体格强健，更体现在她的果敢决断和老谋深算。她与人交锋时从不退让，始终威风凛凛。而姥爷却显得有些怕斗，或者说是不愿与人争斗，他更喜欢沉默寡言。他们白头偕老，至今已相携五十余载，风雨同舟。即便日常中仍会拌嘴，但自从有了重孙丞丞，争吵也变得少了，取而代之的是笑容，笑得嘴角合不拢。</p><p>家中人都说姥爷柔弱，确实，姥爷一生没干过脏活累活，手也远不如姥娘的粗糙。然而，在我的记忆中，姥爷那份温和中带着一丝不为人察觉的坚韧。他不爱在家人面前表现脆弱，虽偶尔会在暗处抹眼泪，但每当面对孩儿们时，他总是眼中含着笑，鼓励我们要好好读书。姥爷是个知识分子，写得一手好字，却在文革中被耽搁了。</p><p>近些年，姥爷的身体开始抱恙，稍有不适便会忧心忡忡，频繁地去看医生。但每次抱着重孙丞丞时，他的眼睛仍旧笑得眯成一条缝，仿佛一切的忧愁都被这小小生命的力量所冲淡了。我知道，姥爷珍惜他的生命，更不愿与我们分离。</p><p>我还记得小时候上幼儿园时，姥爷那时已退休，却常常开着他那辆看似庞大的三轮车去拉人。幼时的我总觉得那车是如此巨大，而随着我一点点长大，三轮车也在我眼中渐渐变得不再高大。它逐渐残破，直到有一天，彻底废弃，便再也没见过它的踪影了。它的颜色、形状在我的记忆中早已模糊不清，仿若一场远去的幻梦。</p><p>就这样，曾经在青年时四处奔波的姥爷，最终停下了脚步，回归了家庭，不再离开。他在外伸出的枝桠，终究被时间一一折断，而他，也叶落归根。</p><p>如今，姥爷看着他的子女成家立业，后代一代代出生、成长。那些曾经各不相同的人生，如今在生命的长河中交织传承。姥爷感受着生命的延续，感受着重孙丞丞带来的喜悦。而我，则站在一旁，默默感受着他人生最后的余晖。</p><p>回首往事，姥爷已老。</p><p>他的那些记忆，恐怕也只能深藏在心中，无法言说，默默回味。</p><p>而我，仍是那个年少的我，只不过到了该走出家门、闯荡四方的年纪了。</p><p>姥爷依然是姥爷，只不过再也无法随风去远方了…</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>夏日午后</title>
      <link href="/2024/10/22/%E5%A4%8F%E6%97%A5%E5%8D%88%E5%90%8E/"/>
      <url>/2024/10/22/%E5%A4%8F%E6%97%A5%E5%8D%88%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="夏日午后"><a href="#夏日午后" class="headerlink" title="夏日午后"></a>夏日午后</h2><p>黑云翻涌，寒蝉鸣泣。比往日更加闷热的夏日午后，我的脑海像一团糟乱的线，嗡嗡作响。耳鸣撕裂我的意识，周围人此起彼伏的哭喊声像沉重的呓语，断断续续。我看着他们，一个个张着口，仿佛乌鸦般发出沉闷的叫声。“哇——”</p><p>我转过身，抬起右手，遮挡着刺眼的阳光。视线昏暗模糊，远处枝桠上栖息的大鸟半眯着眼，静静看着我。我低头，忽然瞥见自己煞白的右手，那是曾留有你余温的手。我呆立在原地，脑海中只回响着那些没能抓住的话语。</p><p><strong>“要是我当时握紧你的手……”</strong></p><p>内心闪过一丝苦笑。无力的假设，荒谬至极。</p><p>那时，初夏。</p><p>蝉声如雨，“嗤——嗤——”撕裂着空气，天边隐约传来雷鸣，闷热的空气像罩住了一切。你牵着我的手，汗水渗出，凉意与燥热混杂在一起。我们在街上无头苍蝇般四处乱窜。</p><p>“接下来去哪儿？”</p><p>“不知道。”</p><p>“好热。”</p><p>“嗯。”</p><p>“回去吧。”</p><p>“……”</p><p>“……”</p><p>“回去吧。”</p><p>奇怪的是，街上空无一人，只有我们两个人，手牵着手，走在空荡荡的街道上。没有人，没有声响，仿佛整个世界都在等待着某种注定发生的事情。<strong>“要努力了呀。”</strong>你突然挣脱我的手，跑到前方，转身对我说着什么。</p><p>你的声音被距离吞噬，模糊不清。你咧嘴一笑，发梢掠过额头，轻轻撩开汗湿的发丝。那天，阳光灼烈，你的脸上已经有了汗珠，我看着你潮红的美丽脸庞，没听清你说了什么。试图让你再说一遍，但你的声音仿佛被整个夏天吞没。无论我怎么呼喊，你始终只是微笑着。空间扭曲了，我追不上你。就像两条渐行渐远的直线，我们注定无法交汇。</p><p>未尽的话语，未传达的声音，永远悬在那片燥热的空气中。</p><p>夏日骤雨突如其来，蝉声淹没了我们的脚步。雨打在我握紧的右手上，那手中还残留着你曾经的温度。我在雨中奔跑，雨幕遮住了我的眼，朦胧了你的身影。我的视线模糊，心中的你越来越遥远。</p><p>醒来时，已是今天——夏末的一天。而你，已然……</p><p><strong>“我想和你一起——”</strong></p><p>“将一切扭转！！”</p><p>我弯下腰，撕声呼喊。周围的人愤怒地注视着我，仿佛我是疯子。我并不在乎，只注视着那棵树上望着我的大鸟，微笑着。<br>我拼命奔跑，为了不被悔意吞噬。即便前方是一片无尽的黑暗，只要你手中余下的那丝温暖还在，我就能继续前行，苟延残喘？可我能残留下什么呢？即便如此，夏日的骤雨依旧连绵不绝，淹没了一切。我永远记得那一瞬间，海浪席卷而来的瞬间，即便它裹挟走所有的回忆，我也愿与你重写一切，哪怕只有我，哪怕这只有一次的机会。</p><p><strong>“能残留些什么呢？”</strong></p><p><strong>“你会永远活着。”</strong></p><p><strong>“要努力了呀。”</strong></p><p>“你没死。”</p><p>“嗯。”</p><p>……</p><p>我们仍然手牵着手，回到了那个遥远的夏日午后。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>庄兄生日有感</title>
      <link href="/2024/10/22/%E5%BA%84%E5%85%84%E7%94%9F%E6%97%A5%E6%9C%89%E6%84%9F/"/>
      <url>/2024/10/22/%E5%BA%84%E5%85%84%E7%94%9F%E6%97%A5%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="庄兄生日有感"><a href="#庄兄生日有感" class="headerlink" title="庄兄生日有感"></a>庄兄生日有感</h2><p>诸位同学，昨日乃九月二十三，今日为二十四，明日即立冬。</p><p>此刻，我提及今日并无意标榜其特别之处。诚然，今日乃庄君之诞辰，意义不凡，理应庆贺。但我们亦应审视，时间不过是人类衡量生命长短的尺度，岁月流转，人事更替，所谓的“生日”也不过是人为设定的象征，或许更像是对逝去时光的一种虚幻的留恋。</p><p>因此，吾人应自问：生日究竟为何物？我们常言“生日快乐”，此祝词简单直白，但其中隐含的是否是一种理所应当的期待？即生日之日，便该欢欣自得。然世事纷纭，未曾让人有一日真正得以摆脱其扰，生日不过是片刻的仪式，将人从琐碎中短暂抽离，返归生命的本真。此时我们得以凝望自身的过去，丈量踏过的路途，确认自己虽置身荒诞，仍步履坚定。亲朋好友的祝福如轻风拂面，提醒我们，这世间旅途并非孤独一人，山川流水与同行者皆值得珍惜。</p><p>换言之，生日的意义在于内心，而非外在的欢娱与物质的享乐；它是心灵的凝视，是对生命真谛的审视，而非对虚无的庆典。<br>而今，因庄兄生日，我们得以重聚，谈论过去、当下与未来。</p><p>我们如同积蓄了十二年的雨水，在这短暂的时光里倾泻而出。未来数年中，我们或许在梦中仍会见到那场暴雨，它如同那朵沉重的云，曾经笼罩我们，挥之不去。高考，似乎是人生中的一道门槛，然而，它更像一堵高墙，挡住了未来的视野。透过那门缝，我们隐约窥见门后的人儿，轻舞飞扬，而我们却背负着沉重的期待与焦虑。</p><p>守门人微笑着欺骗我们：“跨过这扇门，十二年的重担便可放下。”可那语气，宛如冥河边的摆渡人，而我们却无从寻得那枚渡资的金币。</p><p>我以为高考无需回忆。笑过、泪过、愤怒过、背负过，终究，我们未曾料到，竟也会在某个时刻生出留恋之情。高考，是一场命运的孤注一掷，难有人愿意再度经历。它耗尽了我们的心力，而给与的却不过是一张通知书，远不足以弥补那些失落的情感与青春的热忱。</p><p>为了制度的“合理性”，我们这些可怜人牺牲了太多。臂膀被高高举起，却也因未曾自主用力而愈发感到无力。高考并非向我们索取太多，而是让我们甘愿奉献出那颗“天不怕地不怕”的心。</p><p>高考，如一场注定的大雨，不论如何防备，只要愿意迎着雨走，我们终将被浇透。高考的成绩，只不过是看我们是否有力气拧干那被打湿的衣服，以及能否带回那把风雨中的伞。简而言之，高考让我们在失措与尴尬中，拾回了多少属于自己的颜面。</p><p>或许我不该走出那扇门。若是如此，我便无需一次次地拧干那被雨淋湿的衣衫，尽管我深知，雨总会继续下。</p><p>终于，暴雨似乎停止了，或许它只是暂时收敛。我们无法预知它是否会以另一种形式再次降临，但我们已学会珍惜手中简简单单的伞。</p><p>高考并未远去。它将在未来，以另一种面貌出现在我们的生命中：工作、房贷、职称、手术、官司、股市……它们都是那场雨的兄弟。守门人依旧宣称：“过了这扇门，重担便可卸下。”但我们不再轻信。因为，我们深知，尽管衣物可晒干，心灵的温暖与自由的尊严若失去了，将再难重拾。</p><p>一扇门打开了，又有更多扇。一堵墙穿过了，又有无数堵 —— 这是一个巨大的城堡，和童话里的那个毫不一致。抬头，只有阴晴不定的天空，处处不是温暖的壁炉，而是虚弱者掩息的呻吟和溃烂，下的这场大雨，冲刷了许多也淹没了许多，这到底该还是不该呢？彩虹不会给出答案。七色光穿不透那重重岩壁。我们要仰望太阳，而非仅仅追逐彩虹。<br>值得庆幸的是，雨水已在我们的脊背上蒸干。而此时此刻，离别让相聚显得如此短暂。记得苏轼在《赤壁赋》中曾言：</p><p>“逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。”</p><p>流水虽逝，未尝真的远去。世间变幻无常，若仅执着于此，便会迷失在永恒的追逐中。然若能体悟那不变之理，便能超脱于时空之中，见证那亘古长存的真理。<br>这轮明月，何尝不在我们的心中？既然我们心中皆有一方不变的守望，纵然天各一方，亦无所谓相聚与别离。<br>此时，我又不禁忆起李之仪的《卜算子》，愿与诸君共勉：</p><blockquote><p>卜算子<br>李之仪<br>我住长江头，君住长江尾。<br>日日思君不见君，共饮长江水。<br>此水几时休，此恨何时已？<br>但愿君心似我心，定不负相思意。</p></blockquote><p>感谢诸君，亦祝庄兄生日快乐！</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛夏，死蝉与逝去的朋友</title>
      <link href="/2024/10/22/%E7%9B%9B%E5%A4%8F%E3%80%81%E6%AD%BB%E8%9D%89%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E6%9C%8B%E5%8F%8B/"/>
      <url>/2024/10/22/%E7%9B%9B%E5%A4%8F%E3%80%81%E6%AD%BB%E8%9D%89%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E6%9C%8B%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="盛夏的死蝉"><a href="#盛夏的死蝉" class="headerlink" title="盛夏的死蝉"></a>盛夏的死蝉</h2><p>“嗤——！嗤——！”蝉噪如雨。<br>阳光无情地透过窗户，将对面的白墙映出窗帘的图案。斑驳的阴影，灰尘在房间游荡，空调卖命地吹着冷气，地板上层层叠叠的纸箱寂然。<br>“哎——要走了吗？” 面对满地纸箱，想起这些年的际遇，胸口仿佛要撕裂一般，说不出话。<br>“妈，工作被辞了。我有点累了，我……”<br>“回家一趟吧，儿子，没事，以后还……”母亲少有地打断我诉苦水。<br><strong>“Time takes a cigarette, puts it in yo——”</strong><br>手机铃声响起——搬家公司到了。装满这些年回忆的箱子陆陆续续被搬离公寓。转眼间，屋内只剩我一人。门缓缓地被关上，发出厚重的闭合声。我长舒一口气，也该回去看看了。<br>“？——几本书？”<br>我蹲下，缓缓地捡起零星散落在地上的书。翻出的那本日记本带着些许发黄的页角，静静躺在灰尘中。那是多久以前的？<br>随手翻开第一页，略显粗糙的笔迹映入眼帘——<strong>“2018年，八月。”</strong><br>我怔住了。记忆在瞬间被拉回到十年前，那个夏天，那些错综复杂的情感，还有那个不曾再见的朋友——吕游。<br><strong>“你有多久没想过他了？”</strong>心中忽然冒出这样一个声音，刺痛得令人窒息。我紧握着日记，指尖微微发白，翻阅的动作却停不下来。那些曾经压在时间尘埃下的情感，像这燥热的空气一般翻涌而上。<br>[‘吕游死了。’]<br>日记的某页上，简洁地记录着这样一行字，笔迹微微颤抖，带着当时的无措和震惊。十六岁的我，在某个如今天一般燥热的夏末里，笨拙地写下了这条消息。</p><hr><p>初秋的夜晚，蝉鸣依稀，零星几声刺耳，像是濒死的低语。<br>三天，两夜。我记得吕游失踪的那几天，所有人都在找他。他去了哪里？没人知道。夜晚的河畔，月光像刀一样在水面上切割出银色的碎片。我那时只感到一片混乱，心中却不知为何还残留着一丝不安。<br>吕游性格内向，总是安静的。他不像别人那样争强好胜，也从不表现出任何的激进。但当他消失的那几天，我却第一次意识到自己从未真正了解过他。人群中的议论声渐渐变得刺耳，他们的评价如同无形的枷锁，压得我喘不过气来。<br>[‘吕游可能是自杀的。’]<br>这个消息最早是从谁口中传出来的？我已经记不清了。只是，我当时并不相信，甚至有些抗拒——他会自杀？怎么可能？他从来没说过什么悲观的话，我们只是无数次讨论着未来，聊着毕业后的理想与生活。<br>那年初秋，河水寒冷。吕游的身体被发现时，我才意识到，所有的争论、所有的猜测，已经变得毫无意义。<br>蝉声如针，细细刺入耳中。<br>葬礼上，人们的哭声、窃窃私语、不断振翅的蝉鸣交织成了刺耳的噪音。人们说着吕游的名字，却仿佛已经遗忘了他的真实模样。那一刻，我站在人群之外，像局外人般看着这一切，心中空荡荡的，什么话也说不出口。</p><hr><p>我合上日记本，轻轻叹了口气。那些年少时的记忆如潮水般涌来，却又迅速退去，留下的只有空虚。我的手指依然紧紧握着那本日记，仿佛它能唤回什么逝去的东西。<br>[‘盛夏的死蝉。’]<br>我默默念出这句话，眼前浮现出鸣蝉的画面。蝉，那些盛夏的生物，在生命最喧嚣的时候，鸣叫得无比疯狂。而当它们死去，声音便戛然而止，带着无尽的沉寂。<br>曾经的吕游，他在我们看不到的地方承受着太多的压力、太多的痛苦。直到最后，“扑通“一声闷响！<br>而我呢？<br>十年过去了，我已然成了社会中的一颗齿轮。忙碌、奔波，渐渐忘记了那些曾经让我困惑和挣扎的理想。<br>现在，站在这间空荡的房子里，面对着空调吹出的冷风和寂静的房间，突然觉得自己和那死去的蝉并无两样。</p><hr><p>楼下的搬家公司已经在催促我下去。我将日记本小心翼翼地放进一个我的行李箱，准备好离开。<br>走出公寓的那一刻，耳边传来远处的蝉鸣，声声入耳。那是盛夏最后的声音，也许过不了几天，它们就会像吕游一样，悄无声息地消失。<br>我停下脚步，回望了一眼已经搬空的房间，心里突然涌上了一阵莫名的惆怅。<br><strong>“要努力了呀……”</strong><br>仿佛在遥远的记忆深处，吕游的声音再次响起。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>姥娘、我与逝去的大黄</title>
      <link href="/2024/10/22/%E5%A7%A5%E5%A8%98%E3%80%81%E6%88%91%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E5%A4%A7%E9%BB%84/"/>
      <url>/2024/10/22/%E5%A7%A5%E5%A8%98%E3%80%81%E6%88%91%E4%B8%8E%E9%80%9D%E5%8E%BB%E7%9A%84%E5%A4%A7%E9%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="姥娘、我与逝去的大黄"><a href="#姥娘、我与逝去的大黄" class="headerlink" title="姥娘、我与逝去的大黄"></a>姥娘、我与逝去的大黄</h2><p>不久前，丞丞诞生了。他是姥娘的曾孙，亦是我的侄儿。自此，每次探望姥娘，更多是在丞丞家中。有了这个新生命，姥娘似乎焕发了几分神采，精神比往日更为明朗。她逗得丞丞笑声不断，自己的笑容也随之绽放，那双眼睛眯成了一道缝，笑得连补了瓷的牙也露了出来。</p><p>姥娘已是耄耋之年，而丞丞才刚在这世上存在了四个月。生命如同一条奔腾的河流，缓缓流淌着，将火焰从一代传递到下一代。但这火焰，却常常在皑皑白雪中显得如此脆弱。</p><p>姥娘的一生充满了风雨坎坷。她经历了新中国的成立、大跃进、人民公社的艰难岁月，甚至文革时期的动荡与磨难。她啃过树皮，挨过批斗，却依然坚强地走了过来。如今，她的目光凝视着丞丞，双眼虽已昏花，脚步亦不复从前的矫健，但心中仍有那不变的温柔与期待。看着她如今的模样，我不禁发问：人类是否真的如此永无止境地延续下去？在这个新生的孩子面前，我并未感受到该有的喜悦，反而如白雪中的火团一般，感到一种刺目的熄灭。</p><p>我想起了从前，那时的姥娘还很强健。她照顾着南堰上的猪场，天高云淡，路途遥远，生活虽不富足，却有一种平凡中的踏实感。家还未拆迁，南堰依旧在，她走一步，我便跑两步，跟随在她高大的身影之后。那些模糊的记忆里，妈妈上夜班的夜晚，昏黄的灯光下，她轻轻拍着我入睡。那时的她笑得如此纯粹，像是安静的港湾。而如今，她的笑颜未曾改变，只是脸上多了几道皱纹。</p><p>那时是她等我，如今，我早已跑过她的脚步，她再也望不见我的背影。她看着自己的子孙一代代成长，拖着老迈的身躯，似乎仍试图追赶，想要与我们同行，但终究，我们早已越过了她将要伫立的墓地。她终将站在那儿，目送我们远去，渐行渐远。</p><p>我仍记得姥娘养过的一只黄狗，大黄。我很喜欢她，她比我大两岁，现在我却已是她的两倍年纪。大黄死去已有十年了。那一天，我感到悲伤，但第二天便遗忘了。只是如今，每每想起，心中总有些许惶恐。她是在哪里死去的？为何要独自出走？我喊她时，她是否曾回头？记忆早已模糊不清。她离世前卧在窝里数日，而那天突然回光返照，跑了起来。我并未多想，只觉她依然如常，未曾意识到她走向了一个无人知晓的角落，悄然死去。</p><p>记忆如同一条残缺不全的带子，忽然想起某些无关紧要的片段。那时，姥娘给了大黄一块肉，她咬不动，已是垂垂老矣。她的儿孙早被分给了邻里，她孤独地呜咽一声，将肉吐了出来，“都老了……”姥娘把肉切成薄片，扔给她，她吃没吃，我已忘记。我只记得自己曾蹲下身，与她对视。她的眼神仿佛一片漆黑的夜，深不见底，似要将我吸入其中。在她眼中，我又是怎样的呢？那时的她与那时的我，彼此的心境究竟发生了什么？我无从知晓。恐怕这些情感只能深深埋在心底，随着岁月一同沉寂。</p><p>她死在几天后，死在了姥娘最初捡到她的地方——南堰。那个她最熟悉的地方，或许也是她心中最后的归处。</p>]]></content>
      
      
      <categories>
          
          <category> 文字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
